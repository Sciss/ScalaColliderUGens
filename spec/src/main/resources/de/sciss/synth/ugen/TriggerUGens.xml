<ugens revision="3">
    <!-- all documented -->
    <ugen name="Trig1">
        <rate name="audio"/>
        <rate name="control"/>
        <arg name="in" type="trig">
            <doc>
                the trigger. This can be any signal. A trigger happens when the signal changes
                from non-positive to positive.
            </doc>
        </arg>
        <arg name="dur" default="0.1">
            <doc>
                the duration for which the ugens holds the value of 1 when triggered
            </doc>
        </arg>
        <doc>
            <text>
                A UGen which outputs a value of 1 for a given duration when triggered.

                When a trigger occurs at the input, a value of 1 is output for the specified duration,
                otherwise zero is output. When a new trigger occurs while this ugens outputs 1, the
                hold-time is reset to the duration.
            </text>
            <example name="hold dust spikes">
                Trig1.ar(Dust.ar(1), 0.2) * SinOsc.ar(800) * 0.2
            </example>
            <see>ugen.Trig</see>
        </doc>
    </ugen>
    <ugen name="Trig">
        <rate name="audio"/>
        <rate name="control"/>
        <arg name="in" type="trig">
            <doc>
                the trigger. This can be any signal. A trigger happens when the signal changes
                from non-positive to positive.
            </doc>
        </arg>
        <arg name="dur" default="0.1">
            <doc>
                the duration for which the ugens holds the value of the input signal when triggered
            </doc>
        </arg>
        <doc>
            <text>
                A UGen which holds and outputs an input value for a given duration when triggered.

                When a trigger occurs at the input, the input value is sampled and output for the specified duration,
                otherwise zero is output. When a new trigger occurs while this ugens outputs 1, the
                hold-time is reset to the duration.
            </text>
            <example name="hold dust spikes">
                Trig.ar(Dust.ar(1), 0.2) * SinOsc.ar(800) * 0.2
            </example>
            <see>ugen.Trig1</see>
        </doc>
    </ugen>
    <ugen name="SendTrig" side-effect="true">
        <rate name="audio"/>
        <rate name="control"/>
        <arg name="trig" type="trig" pos="0" rate="ugen">
            <doc>
                the trigger signal causing the value to be read and sent. A trigger occurs
                when passing from non-positive to positive.
            </doc>
        </arg>
        <arg name="id" default="0" pos="2">
            <doc>
                an arbitrary integer that will be sent along with the `"/tr"` message.
                This is useful to distinguish between several SendTrig instances per SynthDef.
            </doc>
        </arg>
        <arg name="value" default="0.0" pos="1">
            <doc>
                a changing signal or constant that will be polled at the time of trigger,
                and its value passed with the trigger message
            </doc>
        </arg>
        <doc warn-pos="true">
            <text>
                A UGen that sends a value from the server to all notified clients upon receiving triggers.
                The message sent is `OSCMessage("/tr", &lt;(Int) nodeID&gt;, &lt;(Int) trigID&gt;, &lt;(Float) value&gt;)`.

                For sending an array of values, or using an arbitrary reply command, see `SendReply`.
            </text>
            <see>ugen.SendReply</see>
        </doc>
    </ugen>

    <ugen name="SendReply" side-effect="true">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="trig" type="trig" pos="0" rate="ugen">
            <doc>
                a non-positive to positive transition triggers a message
            </doc>
        </arg>
        <arg name="id" default="0" pos="3">
            <doc>
                an integer identifier which is contained in the reply message. While you can
                distinguish different `SendReply` instances from the same Synth by choosing different
                OSCMessage names, depending on the application you may use the same message name but
                different ids (similar to `SendTrig`).
            </doc>
        </arg>
        <arg name="msgName" type="ge-string" default="/reply" pos="2">
            <doc>
                a string specifying the OSCMessage's name. by convention, this should
                start with a forward slash and contain only 7-bit ascii characters.
            </doc>
        </arg>
        <arg name="values" variadic="true" pos="1">
            <doc>
                a graph element comprising the signal channels to be polled
            </doc>
        </arg>
        <doc warn-pos="true">
            <text>
                A UGen which sends an sequence of values from the server to all notified clients upon receiving triggers.
                The message sent is `OSCMessage(&lt;(String) msgName&gt;, &lt;(Int) nodeID&gt;, &lt;(Int) replyID&gt;, &lt;(Float) values&gt;*)`.

                For sending a single value, `SendTrig` provides an alternative.
            </text>
            <see>ugen.SendTrig</see>
        </doc>
    </ugen>

    <ugen name="Poll" side-effect="true">
        <rate name="audio"/>
        <rate name="control"/>
        <arg name="trig" type="trig" pos="0" rate="ugen">
            <doc>
                a non-positive to positive transition telling Poll to return a value
            </doc>
        </arg>
        <arg name="in" pos="1">
            <doc>
                the signal you want to poll
            </doc>
        </arg>
        <arg name="trigID" default="-1" pos="3">
            <doc>
                if greater then 0, a `"/tr"` OSC message is sent back to the client
                (similar to `SendTrig`)
            </doc>
        </arg>
        <arg name="label" type="ge-string" default="poll" pos="2">
            <doc>
                a string or symbol to be printed with the polled value
            </doc>
        </arg>
        <doc>
            <text>
                A UGen for printing the current output value of its input to the console.
            </text>
            <see>ugen.SendTrig</see>
        </doc>
    </ugen>

    <ugen name="ToggleFF">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="trig" type="trig">
            <doc>
                a signal to trigger the flip-flop. a trigger occurs when the signal
                changes from non-positive to positive.
            </doc>
        </arg>
        <doc>
            <text>
                A UGen that toggles like a flip-flop between zero and one upon receiving a trigger.
                The flip-flop initially outputs zero and changes to one when the first trigger
                arrives.
            </text>
            <example name="mouse-button toggle">
                // make sure lag is zero, otherwise the output
                // never falls back exactly to zero!
                val tr = MouseButton.kr(lag = 0)
                val ff = ToggleFF.kr(tr)
                SinOsc.ar(ff.madd(400, 800)) * 0.1
            </example>
            <see>ugen.SetResetFF</see>
        </doc>
    </ugen>
    <ugen name="SetResetFF">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="trig" type="trig">
            <doc>
                trigger that sets output to 1. A trigger happens when the signal changes from non-positive
                to positive.
            </doc>
        </arg>
        <arg name="reset" type="trig">
            <doc>
                trigger that sets output to 0. A trigger happens when the signal changes from non-positive
                to positive.
            </doc>
        </arg>
        <doc>
            <text>
                A flip-flop UGen with two inputs, one (set) triggering an output of 1.0, the other (reset)
                triggering an output of 0.0. Subsequent triggers happening within the same input slot have no
                effect. If both inputs receive a trigger at the same time, the ''reset'' input takes precedence.
            </text>
            <example name="mouse-button toggle">
                // make sure lag is zero, otherwise the output
                // never falls back exactly to zero!
                val set   = MouseButton.kr(lag = 0)
                val reset = Impulse.kr(1)
                val ff    = SetResetFF.kr(set, reset)
                SinOsc.ar(ff.madd(400, 800)) * 0.1
            </example>
            <see>ugen.ToggleFF</see>
        </doc>
    </ugen>
    <ugen name="Latch">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in">
            <doc>
                the input signal
            </doc>
        </arg>
        <arg name="trig" type="trig" default="high">
            <doc>
                the trigger. The can be any signal. A trigger happens when the signal changes from
                non-positive to positive.
            </doc>
        </arg>
        <doc>
            <text>
                A sample-and-hold UGen. When triggered, a new value is taken from the input and
                hold until the next trigger occurs.
            </text>
            <see>ugen.Gate</see>
            <see>ugen.Demand</see>
        </doc>
    </ugen>
    <ugen name="Gate">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in">
            <doc>
                the input signal to gate
            </doc>
        </arg>
        <arg name="gate" type="gate">
            <doc>
                the signal specifying whether to pass the input signal (when greater than zero) or
                whether to close the gate and hold the last value (when less than or equal to zero)
            </doc>
        </arg>
        <doc>
            <text>
                A gate or hold UGen.
                It allows the input signal value to pass when the `gate` argument is positive,
                otherwise it holds last value.
            </text>
            <see>ugen.Latch</see>
        </doc>
    </ugen>
    <ugen name="Schmidt">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in">
            <doc>
                input signal to be analyzed
            </doc>
        </arg>
        <arg name="lo" default="0.0">
            <doc>
                low threshold
            </doc>
        </arg>
        <arg name="hi" default="1.0">
            <doc>
                high threshold
            </doc>
        </arg>
        <doc>
            <text>
                A Schmidt trigger UGen. Initially it outputs zero. When the input signal rises above `hi`,
                its output switches to 1.0, which is hold until the signal falls below `lo`, switching the
                output again to 0.0. The produces a kind of hysteresis behavior, preventing heavy
                oscillations in a noisy system which might occur with a single-threshold trigger.
            </text>
        </doc>
    </ugen>
    <ugen name="PulseDivider">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="trig" type="trig">
            <doc>
                a trigger occurs when the signal changes from non-positive to positive.
            </doc>
        </arg>
        <arg name="div" default="2">
            <doc>
                decimation factor of the UGen. A value of 1 would cause an output trigger for each
                input trigger, whereas a value of 2 would cause an output trigger each time the internal
                counter has seen two input triggers.
            </doc>
        </arg>
        <arg name="start" default="0">
            <doc>
                value of the internal counter. For example, if `div` is `2`, then a `start` value of `0`
                (default) means that the first output trigger happens after two input triggers, a `start`
                value of `1` means that the first output trigger happens after just one input trigger.
                Negative values can increase the number of required input triggers for the first output trigger.
                For example, if `start` is `-1`, the first output trigger happens after three input triggers.
            </doc>
        </arg>
        <doc>
            <text>
                A UGen that decimates trigger by outputting one impulse each time a certain number of triggers
                at its input have been received.
            </text>
            <example name="every two mouse-button clicks">
                val in  = MouseButton.kr(lag = 0)
                in.poll(in, "in")
                val out = PulseDivider.kr(in, 2, -1)
                out.poll(out, "out")
                ()
            </example>
            <example name="rhythmic 1:4 pattern">
                val p = Impulse.ar(8)
                val d = PulseDivider.ar(p, 4)
                val a = SinOsc.ar(1200) * Decay2.ar(p, 0.005, 0.1) * 0.3
                val b = SinOsc.ar( 600) * Decay2.ar(d, 0.005, 0.5) * 0.3
                Seq(a, b)
            </example>
            <see>ugen.PulseCount</see>
            <see>ugen.Stepper</see>
        </doc>
    </ugen>
    <ugen name="PulseCount">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="trig" type="trig" rate="ugen">
            <doc>
                a trigger happens when the signal changes from non-positive to positive
            </doc>
        </arg>
        <arg name="reset" type="trig" default="low">
            <doc>
                when triggered, resets the counter to zero. When both `trig` and `reset` are triggered at the same
                time, the `reset` takes precedence (output will be zero).
            </doc>
        </arg>
        <doc>
            <text>
                A UGen that counts the number of triggers observed.
            </text>
            <example name="count mouse clicks, reset at 10">
                val tr    = MouseButton.kr(lag = 0)
                val reset = PulseDivider.kr(tr, 10)
                val c     = PulseCount.kr(tr, reset)
                c.poll(tr + Impulse.kr(0), "count")
                ()
            </example>
            <see>ugen.Stepper</see>
        </doc>
    </ugen>
    <ugen name="Stepper">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="trig" type="trig" rate="ugen">
            <doc>
                The trigger signal which increments the counter. A trigger happens when the signal
                changes from non-positive to positive. Note that if the UGen is created with the
                trigger initially high, the counter will also be incremented immediately. Thus
                a `Stepper.kr(Impulse.kr(1))` will begin by outputting `1`. If you want to avoid this,
                you could their subtract `Impulse.kr(0)` from the trigger input, or set `resetVal`
                to `hi`. E.g. `Stepper.kr(Impulse.kr(1), lo = 0, hi = 4, resetVal = 4)` will produce
                the sequence 0, 1, 2, 4, 0, ...
            </doc>
        </arg>
        <arg name="reset" type="trig" default="low">
            <doc>
                A trigger which resets the counter to `resetVal` immediately.
            </doc>
        </arg>
        <arg name="lo" default="0">
            <doc>
                The minimum value output. For a decremental `step` value, the counter jumps
                to `hi` if it were to fall below `lo`.
            </doc>
        </arg>
        <arg name="hi" default="7">
            <doc>
                The maximum value output. For an incremental `step` value, the counter jumps
                to `lo` if it were to rise beyond `hi`.
            </doc>
        </arg>
        <arg name="step" default="1">
            <doc>
                The amount by which the counter increases or decreases upon receiving triggers.
                Note that if you use a decremental counter, still `lo` must be the minimum and
                `hi` must be the maximum value output. If `lo` > `hi`, the UGen behaves wrongly.
                In the case of decremental counter, set `resetVal` to `hi`. E.g. to count
                from 4 down to 0, use `Stepper.kr(trig, lo = 0, hi = 4, step = -1, resetVal = 4)`, or,
                if you want to ignore an initial high trigger, you could do
                `Stepper.kr(Impulse.kr(1), lo = 0, hi = 4, step = -1, resetVal = 0)` --
                so `resetVal` is `lo` but due to the initial trigger from `Impulse`
                the `Stepper` will in fact start outputting from `4`.
            </doc>
        </arg>
        <arg name="resetVal" default="0"/>
        <doc>
            <text>
                A pulse counting UGen. Each trigger increments a counter which is output as a signal.
                The counter wraps inside the interval from `lo` to `hi` (inclusive). That if you
                use a `lo` other than zero, you might want to adjust `resetVal` as well. `Stepper`
                always starts with the value in `resetVal`, no matter what `lo` is or whether
                the `reset` trigger is high or not.
            </text>
            <example name="arpeggio">
                val tr    = Impulse.ar(10)
                val step  = Stepper.ar(tr, lo = 4, hi = 16)
                val freq  = step * 100
                SinOsc.ar(freq) * AmpComp.ar(freq) * 0.1
            </example>
            <see>ugen.PulseCount</see>
        </doc>
    </ugen>
    <ugen name="TDelay">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="trig" type="trig">
            <doc>
                The input trigger. A trigger is recognized when the signal passes from
                non-positive to positive. Note that, no matter what the amplitude of
                the input trigger is, the UGen will output a delayed trigger of
                amplitude 1.0.
            </doc>
        </arg>
        <arg name="dur" default="0.1">
            <doc>
                The delay time in seconds.
            </doc>
        </arg>
        <doc>
            <text>
                A delay UGen for trigger signals. Other than a normal buffer delay,
                any new trigger arriving in the time between the previous trigger
                and the passing of the delay time is ignored.
            </text>
        </doc>
    </ugen>
    <ugen name="ZeroCrossing">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            signal to analyze
        </arg>
        <doc>
            <text>
                A pitch estimation UGen based on counting the zero-crossings of the input signal.
                This is a very crude pitch follower, but can be useful in some situations.
            </text>
            <example name="reconstruct sine frequency">
                val f1 = SinOsc.kr(0.2).madd(600, 700).roundTo(100)
                val a  = SinOsc.ar(f1) * 0.1
                val f2 = ZeroCrossing.ar(a)
                f2.poll(10, "estimation")
                val b  = SinOsc.ar(f2) * 0.1
                Seq(a, b)
            </example>
            <see>ugen.Pitch</see>
        </doc>
    </ugen>
    <ugen name="Timer">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="trig" type="trig" rate="ugen">
            <doc>
                the trigger to update the output signal.
                A trigger occurs when trig signal crosses from non-positive to positive.
            </doc>
        </arg>
        <doc>
            <text>
                A UGen that returns time since last triggered.
                The time returned is in seconds and is measured from the last received trigger.
                Note that currently it seems the initial memory is at -1 sample, so for
                `Impulse.ar(1)` the result (at 44.1 kHz) is 2.26757e-05, followed strangely
                by 1.00002, and then (as expected) 1.0.
            </text>
            <see>ugen.Sweep</see>
        </doc>
    </ugen>
    <ugen name="Sweep">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="trig" type="trig">
            <doc>
                the trigger that restarts the ramp, when passing from
                non-positive to positive
            </doc>
        </arg>
        <arg name="speed">
            <doc>
                the amount of increment of the output signal per second.
                In SCLang this argument is named `rate`, while ScalaCollider uses
                `speed` to avoid conflict with the UGen's calculation rate.
            </doc>
        </arg>
        <doc>
            <text>
                A UGen which starts a linear raise from zero each time it is
                triggered.

                When speed is one, one gets a continually-updating measurement
                of the time (in seconds) since the last trigger.
            </text>
            <see>ugen.Ramp</see>
            <see>ugen.Phasor</see>
            <see>ugen.Line</see>
        </doc>
    </ugen>
    <ugen name="Phasor">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="trig" type="trig" default="low">
            <doc>
                trigger signal that causes the phasor to jump to the `resetVal` position
            </doc>
        </arg>
        <arg name="speed" default="1.0">
            <doc>
                amount of increment ''per sample frame''. I.e at a speed of 1, each sample output by the
                UGen will be 1 greater than the preceding sample. To achieve a specific frequency `f` in Hertz,
                use a speed value of `f / SampleRate.ir`.
            </doc>
        </arg>
        <arg name="lo" default="0.0">
            <doc>
                start value of the ramp
            </doc>
        </arg>
        <arg name="hi" default="1.0">
            <doc>
                end value of the ramp (exclusive)
            </doc>
        </arg>
        <arg name="resetVal" default="0.0">
            <doc>
                value to jump to upon receiving a trigger in the `trig` input
            </doc>
        </arg>
        <doc>
            <text>
                A linear repeating ramp UGen between start and end values. Using a trigger input, it can be
                reset to a specific position. Upon reaching the end of its ramp, `Phasor` will wrap back to its
                start value. '''Note''': Since `end` is defined as the wrap point, its value is never actually
                output.
            </text>
            <example name="glissandi">
                // mouse-x controls phasor speed
                val freq  = MouseX.kr(0.2, 2, 1)
                // mouse button can be used to jump back
                val reset = MouseButton.kr(lag = 0)
                val p     = Phasor.ar(reset, freq / SampleRate.ir)
                SinOsc.ar(p.linlin(0, 1, 600, 1000)) * 0.1
            </example>
            <see>ugen.Ramp</see>
            <see>ugen.Stepper</see>
            <see>ugen.Line</see>
            <see>ugen.LFSaw</see>
        </doc>
    </ugen>
    <ugen name="Peak">
        <rate name="control"/>
        <rate name="audio">
            <arg name="in" rate="ugen"/> <!-- workaround -->
        </rate>
        <arg name="in">
            <doc>
                input signal to analyze
            </doc>
        </arg>
        <arg name="trig" type="trig">
            <doc>
                resets the maximum observed value to the current absolute value of the input signal
            </doc>
        </arg>
        <doc>
            <text>
                A UGen to measure a signal's peak amplitude. Technically, this UGen works like `RunningMax` after the
                absolute value of the input signal is taken.

                The UGen keeps an internal state that reflects the maximum absolute input value observed. When a
                trigger occurs at the reset input, it first copies the current maximum value to its output and then
                (quasi-simultaneously) resets its internal state to the current absolute input value. This way,
                the peak value seen from the outside at trigger time is the correct peak value up to that moment.
                See the 'illustrate timing' example to understand this timing.
            </text>
            <example name="illustrate timing">
                val i  = Impulse.ar(0)
                // first impulse after 100ms
                val t1 = DelayN.ar(i * 1.0 , 0.100, 0.100)
                // one sample later
                val t2 = Delay1.ar(t1) * 0.5
                // another sample later
                val t3 = Delay1.ar(t2)
                val p  = Peak.ar(t1 + t2, t2)
                // at t1, peak has already seen t1
                p.poll(t1, "t1")
                // at t2, peak still reports 1.0, while internally resetting
                p.poll(t2, "t2")
                // at t3, we observe 0.5, therefore peak did reset at t2
                p.poll(t3, "t3")
                ()
            </example>
            <see>ugen.RunningMin</see>
            <see>ugen.RunningMax</see>
            <see>ugen.RunningSum</see>
            <see>ugen.PeakFollower</see>
            <see>ugen.Amplitude</see>
        </doc>
    </ugen>
    <ugen name="RunningMin">
        <rate name="control"/>
        <rate name="audio">
            <arg name="in" rate="ugen"/> <!-- workaround -->
        </rate>
        <arg name="in">
            <doc>
                input signal to analyze
            </doc>
        </arg>
        <arg name="trig" type="trig">
            <doc>
                resets the minimum observed value to the current value of the input signal
            </doc>
        </arg>
        <doc>
            <text>
                A UGen to measure a signal's minimum value between triggers.

                The UGen keeps an internal state that reflects the minimum input value observed. When a
                trigger occurs at the reset input, it first copies the current minimum value to its output and then
                (quasi-simultaneously) resets its internal state to the current input value.
            </text>
            <example name="illustrate timing">
                val n = BrownNoise.ar
                val t = Impulse.ar(4)
                val r = RunningMin.ar(n, t)
                // value at the moment the reset
                // is triggered
                n.poll(t, "cur")
                // this is the minimum of the
                // recent two input samples
                // (the one during reset and
                // the current one), therefore
                // equal or slightly less than
                // the 'cur' value
                r.poll(Delay1.ar(t), "min")
                ()
            </example>
            <see>ugen.RunningMax</see>
            <see>ugen.Peak</see>
            <see>ugen.RunningSum</see>
        </doc>
    </ugen>
    <ugen name="RunningMax">
        <rate name="control"/>
        <rate name="audio">
            <arg name="in" rate="ugen"/> <!-- workaround -->
        </rate>
        <arg name="in">
            <doc>
                input signal to analyze
            </doc>
        </arg>
        <arg name="trig" type="trig">
            <doc>
                resets the maximum observed value to the current value of the input signal
            </doc>
        </arg>
        <doc>
            <text>
                A UGen to measure a signal's maximum value between triggers.

                The UGen keeps an internal state that reflects the maximum input value observed. When a
                trigger occurs at the reset input, it first copies the current maximum value to its output and then
                (quasi-simultaneously) resets its internal state to the current input value.
            </text>
            <example name="illustrate timing">
                val n = BrownNoise.ar
                val t = Impulse.ar(4)
                val r = RunningMax.ar(n, t)
                // value at the moment the reset
                // is triggered
                n.poll(t, "cur")
                // this is the maximum of the
                // recent two input samples
                // (the one during reset and
                // the current one), therefore
                // equal or slightly greater than
                // the 'cur' value
                r.poll(Delay1.ar(t), "max")
                ()
            </example>
            <see>ugen.RunningMin</see>
            <see>ugen.Peak</see>
            <see>ugen.RunningSum</see>
        </doc>
    </ugen>
    <ugen name="PeakFollower">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in">
            <doc>

            </doc>
        </arg>
        <arg name="decay" default="0.999">
            <doc>

            </doc>
        </arg>
        <doc>
            <text>
                A UGen that continually reports the peak amplitude of the signal received at the input. If the
                absolute input level drops below the observed peak value, this value decreases by the factor given
                as `decay` parameter (but no more than the current absolute input level).
            </text>
            <example name="mouse-controlled decay">
                val in    = Impulse.ar(2)
                val decay = MouseX.kr(0.995, 1.0001, 1).min(1.0)
                decay.poll(HPZ1.kr(decay).abs, "decay")
                val p     = PeakFollower.ar(in, decay)
                val tr    = Impulse.ar(20)
                val pm    = RunningMax.ar(p, tr)
                pm.roundTo(0.001).poll(20, "peak")
                in
            </example>
            <see>ugen.Peak</see>
            <see>ugen.Amplitude</see>
            <see>ugen.RunningSum</see>
            <see>ugen.LagUD</see>
        </doc>
    </ugen>
    <ugen name="MostChange">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="a">
            <doc>
                first input signal to select from
            </doc>
        </arg>
        <arg name="b">
            <doc>
                second input signal to select from
            </doc>
        </arg>
        <doc>
            <text>
                A UGen that switches between two input signal depending on which is changing more.
                Change is based on the absolute of the differentiation of the respective signals.
            </text>
            <example name="mouse-x versus mouse-y">
                val x   = MouseX.kr(lag = 1)
                val y   = MouseY.kr(lag = 1)
                val c   = MostChange.kr(x, y)
                val isX = c sig_== x
                val isY = 1 - isX
                // if X change stronger, modulate pan position
                val p   = LFTri.ar(c * 10 * isX)
                // if Y change stronger, modulate sine frequency
                val f   = LFTri.ar(c * 10 * isY).linexp(-1, 1, 100, 4000)
                // report current state
                c.poll(5, "c")
                x.poll(isX, "now X")
                y.poll(isY, "now Y")
                Pan2.ar(SinOsc.ar(f) * 0.1, p)
            </example>
            <see>ugen.LeastChange</see>
        </doc>
    </ugen>
    <ugen name="LeastChange">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="a">
            <doc>
                first input signal to select from
            </doc>
        </arg>
        <arg name="b">
            <doc>
                second input signal to select from
            </doc>
        </arg>
        <doc>
            <text>
                A UGen that switches between two input signal depending on which is changing less.
                Change is based on the absolute of the differentiation of the respective signals.
            </text>
            <example name="mouse-x versus mouse-y">
                val x   = MouseX.kr(lag = 1)
                val y   = MouseY.kr(lag = 1)
                val c   = LeastChange.kr(x, y)
                val isX = c sig_== x
                val isY = 1 - isX
                // if X change weaker, modulate pan position
                val p   = LFTri.ar(c * 10 * isX)
                // if Y change weaker, modulate sine frequency
                val f   = LFTri.ar(c * 10 * isY).linexp(-1, 1, 100, 4000)
                // report current state
                c.poll(5, "c")
                x.poll(isX, "now X")
                y.poll(isY, "now Y")
                Pan2.ar(SinOsc.ar(f) * 0.1, p)
            </example>
            <see>ugen.MostChange</see>
        </doc>
    </ugen>
    <ugen name="LastValue">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in">
            <doc>
                input signal to analyze and filter
            </doc>
        </arg>
        <arg name="thresh" default="0.01">
            <doc>
                threshold below which the input sign
            </doc>
        </arg>
        <doc>
            <text>
                A sample-and-hold UGen that outputs the last value before the input changed more than a threshold.
                Change is based on the absolute of the differentiation of input signal.
            </text>
            <example name="distortion">
                val in     = SinOsc.ar(262)
                val thresh = MouseX.kr(1.0e-3, 2.0, 1, lag = 1)
                thresh.poll(5, "thresh")
                LeakDC.ar(LastValue.ar(in, thresh)) * 0.1
            </example>
            <see>ugen.Slew</see>
        </doc>
    </ugen>
    <ugen name="Done" side-effect="true">
        <rate name="control" implied="true"/>
        <arg name="src" type="done-flag">
            <doc>
                the UGen to track
            </doc>
        </arg>
        <doc>
            <text>
                A UGen which monitors another UGen to see when it is finished.
                Some UGens, such as `PlayBuf`, `RecordBuf`, `Line`, `XLine`, `EnvGen`, `Linen`, `BufRd`, `BufWr`, `DbufRd`,
                and the Buffer delay UGens set a 'done' flag when they are finished playing. This UGen echoes that flag
                as an explicit output signal when it is set to track a particular UGen. When the tracked UGen changes
                to done, the output signal changes from zero to one.
            </text>
            <see>ugen.PlayBuf</see>
            <see>ugen.Line</see>
            <see>ugen.EnvGen</see>
        </doc>
    </ugen>
    <ugen name="Pause" side-effect="true">
        <rate name="control" implied="true"/>
        <arg name="gate" type="gate"> <!-- actually checks for _ == 0f -->
            <doc>
                when 0, node is paused, when 1, node is resumed
            </doc>
        </arg>
        <arg name="node" type="ge-int">
            <doc>
                the id of the node to be paused or resumed
            </doc>
        </arg>
        <doc>
            <text>
                A UGen which pauses and resumes another node.
                Note that the UGen initially assumes the node is running, that is,
                if `gate` is initially 1, this will '''not''' resume a paused node.
                Instead, the gate must go to zero and back to one to resume the node.
                Additionally, this UGen will only cause action if the gate value
                changes, that is, if the node is paused or resumed otherwise, this
                UGen will not interfere with that action, unless the gate value is
                adjusted.
            </text>
            <see>ugen.Free</see>
            <see>ugen.PauseSelf</see>
        </doc>
    </ugen>
    <ugen name="FreeSelf" side-effect="true">
        <rate name="control" implied="true"/>
        <arg name="trig" type="trig">
            <doc>
                the input signal which will trigger the action.
            </doc>
        </arg>
        <doc>
            <text>
                A UGen that, when triggered, frees enclosing synth.
                It frees the enclosing synth when the input signal crosses from non-positive to positive.

                This UGen outputs its input signal for convenience.
            </text>
            <see>ugen.Free</see>
            <see>ugen.PauseSelf</see>
        </doc>
    </ugen>
    <ugen name="PauseSelf" side-effect="true">
        <rate name="control" implied="true"/>
        <arg name="trig" type="trig">
            <doc>
                the input signal which will trigger the action.
            </doc>
        </arg>
        <doc>
            <text>
                A UGen that, when triggered, pauses enclosing synth.
                It pauses the enclosing synth when the input signal crosses from non-positive to positive.

                This UGen outputs its input signal for convenience.
            </text>
            <see>ugen.Pause</see>
            <see>ugen.FreeSelf</see>
        </doc>
    </ugen>
    <ugen name="Free" side-effect="true">
        <rate name="control" implied="true"/>
        <arg name="trig" type="trig">
            <doc>
                the trigger to cause the action
            </doc>
        </arg>
        <arg name="node" type="ge-int">
            <doc>
                the id of the target node to free upon receiving the trigger
            </doc>
        </arg>
        <doc>
            <text>
                A UGen that, when triggered, frees a given node.

                This UGen outputs its trig input signal for convenience.
            </text>
            <see>ugen.Pause</see>
            <see>ugen.FreeSelf</see>
        </doc>
    </ugen>
    <ugen name="FreeSelfWhenDone" side-effect="true">
        <rate name="control" implied="true"/>
        <arg name="src" type="done-flag">
            <doc>
                the input UGen which when finished will trigger the action.
            </doc>
        </arg>
        <doc>
            <text>
                A UGen that, when its input UGen is finished, frees enclosing synth.
                This is essentially a shortcut for `FreeSelf.kr(Done.kr(src))`, so instead
                of providing a trigger signal it reads directly the done flag of an
                appropriate ugen (such as `Line` or `PlayBuf`).

                This UGen outputs its input signal for convenience.
            </text>
            <see>ugen.Free</see>
            <see>ugen.FreeSelf</see>
            <see>ugen.PauseSelfWhenDone</see>
            <see>ugen.Done</see>
        </doc>
    </ugen>
    <ugen name="PauseSelfWhenDone" side-effect="true">
        <rate name="control" implied="true"/>
        <arg name="src" type="done-flag">
            <doc>
                the input UGen which when finished will trigger the action.
            </doc>
        </arg>
        <doc>
            <text>
                A UGen that, when its input UGen is finished, pauses enclosing synth.
                This is essentially a shortcut for `PauseSelf.kr(Done.kr(src))`, so instead
                of providing a trigger signal it reads directly the done flag of an
                appropriate ugen (such as `Line` or `PlayBuf`).

                This UGen outputs its input signal for convenience.
            </text>
            <see>ugen.Pause</see>
            <see>ugen.PauseSelf</see>
            <see>ugen.FreeSelfWhenDone</see>
            <see>ugen.Done</see>
        </doc>
    </ugen>
</ugens>