<ugens revision="1">
    <ugen name="Trig1">
        <rate name="audio"/>
        <rate name="control"/>
        <arg name="in" type="trig">
            <doc>
                the trigger. This can be any signal. A trigger happens when the signal changes
                from non-positive to positive.
            </doc>
        </arg>
        <arg name="dur" default="0.1">
            <doc>
                the duration for which the ugens holds the value of 1 when triggered
            </doc>
        </arg>
        <doc>
            <text>
                A UGen which outputs a value of 1 for a given duration when triggered.

                When a trigger occurs at the input, a value of 1 is output for the specified duration,
                otherwise zero is output. When a new trigger occurs while this ugens outputs 1, the
                hold-time is reset to the duration.
            </text>
            <see>ugen.Trig</see>
        </doc>
    </ugen>
    <ugen name="Trig">
        <rate name="audio"/>
        <rate name="control"/>
        <arg name="in" type="trig">
            <doc>
                the trigger. This can be any signal. A trigger happens when the signal changes
                from non-positive to positive.
            </doc>
        </arg>
        <arg name="dur" default="0.1">
            <doc>
                the duration for which the ugens holds the value of the input signal when triggered
            </doc>
        </arg>
    </ugen>
    <ugen name="SendTrig" side-effect="true">
        <rate name="audio"/>
        <rate name="control"/>
        <arg name="trig" type="trig" pos="0" rate="ugen">
            <doc>
                the trigger signal causing the value to be read and sent. A trigger occurs
                when passing from non-positive to positive.
            </doc>
        </arg>
        <arg name="id" default="0" pos="2">
            <doc>
                an arbitrary integer that will be sent along with the `"/tr"` message.
                This is useful to distinguish between several SendTrig instances per SynthDef.
            </doc>
        </arg>
        <arg name="value" default="0.0" pos="1">
            <doc>
                a changing signal or constant that will be polled at the time of trigger,
                and its value passed with the trigger message
            </doc>
        </arg>
        <doc warn-pos="true">
            <text>
                A UGen that sends a value from the server to all notified clients upon receiving triggers.
                The message sent is `OSCMessage("/tr", &lt;(Int) nodeID&gt;, &lt;(Int) trigID&gt;, &lt;(Float) value&gt;)`.

                For sending an array of values, or using an arbitrary reply command, see `SendReply`.
            </text>
            <see>ugen.SendReply</see>
        </doc>
    </ugen>

    <ugen name="SendReply" side-effect="true">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="trig" type="trig" pos="0" rate="ugen">
            <doc>
                a non-positive to positive transition triggers a message
            </doc>
        </arg>
        <arg name="id" default="0" pos="3">
            <doc>
                an integer identifier which is contained in the reply message. While you can
                distinguish different `SendReply` instances from the same Synth by choosing different
                OSCMessage names, depending on the application you may use the same message name but
                different ids (similar to `SendTrig`).
            </doc>
        </arg>
        <arg name="msgName" type="ge-string" default="/reply" pos="2">
            <doc>
                a string specifying the OSCMessage's name. by convention, this should
                start with a forward slash and contain only 7-bit ascii characters.
            </doc>
        </arg>
        <arg name="values" variadic="true" pos="1">
            <doc>
                a graph element comprising the signal channels to be polled
            </doc>
        </arg>
        <doc warn-pos="true">
            <text>
                A UGen which sends an sequence of values from the server to all notified clients upon receiving triggers.
                The message sent is `OSCMessage(&lt;(String) msgName&gt;, &lt;(Int) nodeID&gt;, &lt;(Int) replyID&gt;, &lt;(Float) values&gt;*)`.

                For sending a single value, `SendTrig` provides an alternative.
            </text>
            <see>ugen.SendTrig</see>
        </doc>
    </ugen>

    <ugen name="Poll" side-effect="true">
        <rate name="audio"/>
        <rate name="control"/>
        <arg name="trig" type="trig" pos="0" rate="ugen">
            <doc>
                a non-positive to positive transition telling Poll to return a value
            </doc>
        </arg>
        <arg name="in" pos="1">
            <doc>
                the signal you want to poll
            </doc>
        </arg>
        <arg name="trigID" default="-1" pos="3">
            <doc>
                if greater then 0, a `"/tr"` OSC message is sent back to the client
                (similar to `SendTrig`)
            </doc>
        </arg>
        <arg name="label" type="ge-string" default="poll" pos="2">
            <doc>
                a string or symbol to be printed with the polled value
            </doc>
        </arg>
        <doc>
            <text>
                A UGen for printing the current output value of its input to the console.
            </text>
            <see>ugen.SendTrig</see>
        </doc>
    </ugen>

    <ugen name="ToggleFF">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="trig" type="trig">
            <doc>
                a signal to trigger the flip-flop. a trigger occurs when the signal
                changes from non-positive to positive.
            </doc>
        </arg>
        <doc>
            <text>
                A UGen that toggles like a flip-flop between zero and one upon receiving a trigger.
                The flip-flop initially outputs zero and changes to one when the first trigger
                arrives.
            </text>
        </doc>
    </ugen>
    <ugen name="SetResetFF">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="trig" type="trig"/>
        <arg name="reset" type="trig"/>
    </ugen>
    <ugen name="Latch">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in">
            <doc>
                the input signal
            </doc>
        </arg>
        <arg name="trig" type="trig" default="high">
            <doc>
                the trigger. The can be any signal. A trigger happens when the signal changes from
                non-positive to positive.
            </doc>
        </arg>
        <doc>
            <text>
                A sample-and-hold UGen. When triggered, a new value is taken from the input and
                hold until the next trigger occurs.
            </text>
            <see>ugen.Gate</see>
            <see>ugen.Demand</see>
        </doc>
    </ugen>
    <ugen name="Gate">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in">
            <doc>
                the input signal to gate
            </doc>
        </arg>
        <arg name="gate" type="gate">
            <doc>
                the signal specifying whether to pass the input signal (when greater than zero) or
                whether to close the gate and hold the last value (when less than or equal to zero)
            </doc>
        </arg>
        <doc>
            <text>
                A gate or hold UGen.
                It allows the input signal value to pass when the `gate` argument is positive,
                otherwise it holds last value.
            </text>
            <see>ugen.Latch</see>
        </doc>
    </ugen>
    <ugen name="Schmidt">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in">
            The input signal to be analyzed.
        </arg>
        <arg name="lo" default="0.0">
            <doc>
                The low threshold.
            </doc>
        </arg>
        <arg name="hi" default="1.0">
            <doc>
                The high threshold.
            </doc>
        </arg>
        <doc>
            <text>
                A Schmidt trigger UGen. Initially it outputs zero. When the input signalÂ rises above `hi`,
                its output switches to 1.0, which is hold until the signal falls below `lo`, switching the
                output again to 0.0. The produces a kind of hysteresis behavior, preventing heavy
                oscillations in a noisy system which might occur with a single-threshold trigger.
            </text>
        </doc>
    </ugen>
    <ugen name="PulseDivider">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="trig" type="trig"/>
        <arg name="div" default="2"/>
        <arg name="start" default="0"/>
    </ugen>
    <ugen name="PulseCount">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="trig" type="trig" rate="ugen"/>
        <arg name="reset" type="trig" default="low"/>
    </ugen>
    <ugen name="Stepper">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="trig" type="trig" rate="ugen">
            <doc>
                The trigger signal which increments the counter. A trigger happens when the signal
                changes from non-positive to positive. Note that if the UGen is created with the
                trigger initially high, the counter will also be incremented immediately. Thus
                a `Stepper.kr(Impulse.kr(1))` will begin by outputting `1`. If you want to avoid this,
                you could their subtract `Impulse.kr(0)` from the trigger input, or set `resetVal`
                to `hi`. E.g. `Stepper.kr(Impulse.kr(1), lo = 0, hi = 4, resetVal = 4)` will produce
                the sequence 0, 1, 2, 4, 0, ...
            </doc>
        </arg>
        <arg name="reset" type="trig" default="low">
            <doc>
                A trigger which resets the counter to `resetVal` immediately.
            </doc>
        </arg>
        <arg name="lo" default="0">
            <doc>
                The minimum value output. For a decremental `step` value, the counter jumps
                to `hi` if it were to fall below `lo`.
            </doc>
        </arg>
        <arg name="hi" default="7">
            <doc>
                The maximum value output. For an incremental `step` value, the counter jumps
                to `lo` if it were to rise beyond `hi`.
            </doc>
        </arg>
        <arg name="step" default="1">
            <doc>
                The amount by which the counter increases or decreases upon receiving triggers.
                Note that if you use a decremental counter, still `lo` must be the minimum and
                `hi` must be the maximum value output. If `lo` > `hi`, the UGen behaves wrongly.
                In the case of decremental counter, set `resetVal` to `hi`. E.g. to count
                from 4 down to 0, use `Stepper.kr(trig, lo = 0, hi = 4, step = -1, resetVal = 4)`, or,
                if you want to ignore an initial high trigger, you could do
                `Stepper.kr(Impulse.kr(1), lo = 0, hi = 4, step = -1, resetVal = 0)` --
                so `resetVal` is `lo` but due to the initial trigger from `Impulse`
                the `Stepper` will in fact start outputting from `4`.
            </doc>
        </arg>
        <arg name="resetVal" default="0"/>
        <doc>
            <text>
                A pulse counting UGen. Each trigger increments a counter which is output as a signal.
                The counter wraps inside the interval from `lo` to `hi` (inclusive). That if you
                use a `lo` other than zero, you might want to adjust `resetVal` as well. `Stepper`
                always starts with the value in `resetVal`, no matter what `lo` is or whether
                the `reset` trigger is high or not.
            </text>
            <see>ugen.PulseCount</see>
        </doc>
    </ugen>
    <ugen name="TDelay">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="trig" type="trig">
            <doc>
                The input trigger. A trigger is recognized when the signal passes from
                non-positive to positive. Note that, no matter what the amplitude of
                the input trigger is, the UGen will output a delayed trigger of
                amplitude 1.0.
            </doc>
        </arg>
        <arg name="dur" default="0.1">
            <doc>
                The delay time in seconds.
            </doc>
        </arg>
        <doc>
            <text>
                A delay UGen for trigger signals. Other than a normal buffer delay,
                any new trigger arriving in the time between the previous trigger
                and the passing of the delay time is ignored.
            </text>
        </doc>
    </ugen>
    <ugen name="ZeroCrossing">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen"/>
    </ugen>
    <ugen name="Timer">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="trig" type="trig" rate="ugen">
            <doc>
                the trigger to update the output signal.
                A trigger occurs when trig signal crosses from non-positive to positive.
            </doc>
        </arg>
        <doc>
            <text>
                A UGen that returns time since last triggered.
                The time returned is in seconds and is measured from the last received trigger.
                Note that currently it seems the initial memory is at -1 sample, so for
                `Impulse.ar(1)` the result (at 44.1 kHz) is 2.26757e-05, followed strangely
                by 1.00002, and then (as expected) 1.0.
            </text>
        </doc>
    </ugen>
    <ugen name="Sweep">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="trig" type="trig">
            <doc>
                the trigger that restarts the ramp, when passing from
                non-positive to positive
            </doc>
        </arg>
        <arg name="speed">
            <doc>
                the amount of increment of the output signal per second.
                In SCLang this argument is named `rate`, while ScalaCollider uses
                `speed` to avoid conflict with the UGen's calculation rate.
            </doc>
        </arg>
        <doc>
            <text>
                A UGen which starts a linear raise from zero each time it is
                triggered.
            </text>
            <see>ugen.Ramp</see>
            <see>ugen.Phasor</see>
            <see>ugen.Line</see>
        </doc>
    </ugen>
    <ugen name="Phasor">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="trig" type="trig" default="low">
            <doc>
                Warning: SC 3.4 has a bug where an initial trig value of 1 will
                be ignored (you need to feed it zero first)
            </doc>
        </arg>
        <arg name="speed" default="1.0"/>
        <arg name="lo" default="0.0"/>
        <arg name="hi" default="1.0"/>
        <arg name="resetVal" default="0.0"/>
    </ugen>
    <ugen name="Peak">
        <rate name="control"/>
        <rate name="audio">
            <arg name="in" rate="ugen"/> <!-- workaround -->
        </rate>
        <arg name="in"/>
        <arg name="trig" type="trig"/>
    </ugen>
    <ugen name="RunningMin">
        <rate name="control"/>
        <rate name="audio">
            <arg name="in" rate="ugen"/> <!-- workaround -->
        </rate>
        <arg name="in"/>
        <arg name="trig" type="trig"/>
    </ugen>
    <ugen name="RunningMax">
        <rate name="control"/>
        <rate name="audio">
            <arg name="in" rate="ugen"/> <!-- workaround -->
        </rate>
        <arg name="in"/>
        <arg name="trig" type="trig"/>
    </ugen>
    <ugen name="PeakFollower">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in"/>
        <arg name="decay" default="0.999"/>
    </ugen>
    <ugen name="MostChange">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="a"/>
        <arg name="b"/>
    </ugen>
    <ugen name="LeastChange">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="a"/>
        <arg name="b"/>
    </ugen>
    <ugen name="LastValue">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in"/>
        <arg name="thresh" default="0.01"/>
    </ugen>
    <ugen name="Done" side-effect="true">
        <rate name="control" implied="true"/>
        <arg name="src" type="done-flag">
            <doc>
                the UGen to track
            </doc>
        </arg>
        <doc>
            <text>
                A UGen which monitors another UGen to see when it is finished.
                Some UGens, such as `PlayBuf`, `RecordBuf`, `Line`, `XLine`, `EnvGen`, `Linen`, `BufRd`, `BufWr`, `DbufRd`,
                and the Buffer delay UGens set a 'done' flag when they are finished playing. This UGen echoes that flag
                as an explicit output signal when it is set to track a particular UGen. When the tracked UGen changes
                to done, the output signal changes from zero to one.
            </text>
            <see>ugen.PlayBuf</see>
            <see>ugen.Line</see>
            <see>ugen.EnvGen</see>
        </doc>
    </ugen>
    <ugen name="Pause" side-effect="true">
        <rate name="control" implied="true"/>
        <arg name="gate" type="gate"> <!-- actually checks for _ == 0f -->
            <doc>
                when 0, node is paused, when 1, node is resumed
            </doc>
        </arg>
        <arg name="node" type="ge-int">
            <doc>
                the id of the node to be paused or resumed
            </doc>
        </arg>
        <doc>
            <text>
                A UGen which pauses and resumes another node.
                Note that the UGen initially assumes the node is running, that is,
                if `gate` is initially 1, this will '''not''' resume a paused node.
                Instead, the gate must go to zero and back to one to resume the node.
                Additionally, this UGen will only cause action if the gate value
                changes, that is, if the node is paused or resumed otherwise, this
                UGen will not interfere with that action, unless the gate value is
                adjusted.
            </text>
            <see>ugen.Free</see>
            <see>ugen.PauseSelf</see>
        </doc>
    </ugen>
    <ugen name="FreeSelf" side-effect="true">
        <rate name="control" implied="true"/>
        <arg name="trig" type="trig">
            <doc>
                the input signal which will trigger the action.
            </doc>
        </arg>
        <doc>
            <text>
                A UGen that, when triggered, frees enclosing synth.
                It frees the enclosing synth when the input signal crosses from non-positive to positive.

                This UGen outputs its input signal for convenience.
            </text>
            <see>ugen.Free</see>
            <see>ugen.PauseSelf</see>
        </doc>
    </ugen>
    <ugen name="PauseSelf" side-effect="true">
        <rate name="control" implied="true"/>
        <arg name="trig" type="trig">
            <doc>
                the input signal which will trigger the action.
            </doc>
        </arg>
        <doc>
            <text>
                A UGen that, when triggered, pauses enclosing synth.
                It pauses the enclosing synth when the input signal crosses from non-positive to positive.

                This UGen outputs its input signal for convenience.
            </text>
            <see>ugen.Pause</see>
            <see>ugen.FreeSelf</see>
        </doc>
    </ugen>
    <ugen name="Free" side-effect="true">
        <rate name="control" implied="true"/>
        <arg name="trig" type="trig">
            <doc>
                the trigger to cause the action
            </doc>
        </arg>
        <arg name="node" type="ge-int">
            <doc>
                the id of the target node to free upon receiving the trigger
            </doc>
        </arg>
        <doc>
            <text>
                A UGen that, when triggered, frees a given node.

                This UGen outputs its trig input signal for convenience.
            </text>
            <see>ugen.Pause</see>
            <see>ugen.FreeSelf</see>
        </doc>
    </ugen>
    <ugen name="FreeSelfWhenDone" side-effect="true">
        <rate name="control" implied="true"/>
        <arg name="src" type="done-flag">
            <doc>
                the input UGen which when finished will trigger the action.
            </doc>
        </arg>
        <doc>
            <text>
                A UGen that, when its input UGen is finished, frees enclosing synth.
                This is essentially a shortcut for `FreeSelf.kr(Done.kr(src))`, so instead
                of providing a trigger signal it reads directly the done flag of an
                appropriate ugen (such as `Line` or `PlayBuf`).

                This UGen outputs its input signal for convenience.
            </text>
            <see>ugen.Free</see>
            <see>ugen.FreeSelf</see>
            <see>ugen.PauseSelfWhenDone</see>
            <see>ugen.Done</see>
        </doc>
    </ugen>
    <ugen name="PauseSelfWhenDone" side-effect="true">
        <rate name="control" implied="true"/>
        <arg name="src" type="done-flag">
            <doc>
                the input UGen which when finished will trigger the action.
            </doc>
        </arg>
        <doc>
            <text>
                A UGen that, when its input UGen is finished, pauses enclosing synth.
                This is essentially a shortcut for `PauseSelf.kr(Done.kr(src))`, so instead
                of providing a trigger signal it reads directly the done flag of an
                appropriate ugen (such as `Line` or `PlayBuf`).

                This UGen outputs its input signal for convenience.
            </text>
            <see>ugen.Pause</see>
            <see>ugen.PauseSelf</see>
            <see>ugen.FreeSelfWhenDone</see>
            <see>ugen.Done</see>
        </doc>
    </ugen>
</ugens>