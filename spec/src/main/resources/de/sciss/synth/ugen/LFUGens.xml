<ugens revision="5">
    <ugen name="Vibrato">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="freq" default="440.0">
            <doc>
                fundamental frequency in Hertz. If the Vibrato UGen is running at audio rate, this must
                be an audio-rate input as well.
            </doc>
        </arg>
        <arg name="beat" default="6.0">
            <doc>
                vibrato rate, that is the speed of wobble in Hertz. Note that if this is set to a too low value,
                you may never get vibrato back, since this input is only checked at the end of a cycle.
            </doc>
        </arg>
        <arg name="depth" default="0.02">
            <doc>
                amount of vibrato frequency deviation around the fundamental, as a proportion of the fundamental.
            </doc>
        </arg>
        <arg name="delay" default="0.0" init="true">
            <doc>
                delay in seconds before vibrato is established.
            </doc>
        </arg>
        <arg name="onset" default="0.0" init="true">
            <doc>
                transition time in seconds from no vibrato to full vibrato after the initial delay time.
            </doc>
        </arg>
        <arg name="beatVar" default="0.04">
            <doc>
                random (noise) variation on the beat parameter, expressed as a proportion of `beat`. It can
                change once per cycle of vibrato.
            </doc>
        </arg>
        <arg name="depthVar" default="0.1">
            <doc>
                random (noise) variation on the depth of modulation, expressed as a proportion of `depth`. It can
                change once per cycle of vibrato. The noise affects independently the up and the down part of
                vibrato shape within a cycle.
            </doc>
        </arg>
        <arg name="iphase" default="0.0" init="true">
            <doc>
                initial phase of vibrato modulation, allowing starting above or below the fundamental rather
                than on it.
            </doc>
        </arg>
        <doc>
            <text>
                A low frequency oscillator UGen for modelling vibrato. It produces a modulating frequency value in
                Hertz that can be used as the frequency parameter of another UGen.

                By setting more extreme settings, one
                can get back to the timbres of FM synthesis. One can also add in some noise to the vibrato rate
                and vibrato size (modulation depth) to make for a more realistic motor pattern.

                The vibrato output is a waveform based on a squared envelope shape with four stages marking out
                0.0 to 1.0, 1.0 to 0.0, 0.0 to -1.0, and -1.0 back to 0.0. The vibrato rate determines how quickly
                one moves through these stages.
            </text>
            <example name="constant setting">
                SinOsc.ar(Vibrato.ar(DC.ar(400.0), 1, 0.02)) * 0.2
            </example>
            <example name="beat and beatVar mouse control">
                val beat    = MouseX.kr(2.0, 100.0)
                val beatVar = MouseY.kr(0.0, 1.0)
                val freq    = Vibrato.ar(DC.ar(400.0), beat, 0.1, 1.0, 1.0, beatVar, 0.1)
                SinOsc.ar(freq) * 0.2
            </example>
        </doc>
    </ugen>
    <ugen name="LFPulse">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="freq" default="440.0">
            <doc>
                oscillator frequency in Hertz
            </doc>
        </arg>
        <arg name="iphase" default="0.0" init="true">
            <doc>
                initial phase offset in cycles (`0..1`). If you think
                of a buffer of one cycle of the waveform, this is the starting offset
                into this buffer. Hence, an `iphase` of `0.25` means that you will hear
                the first impulse after `0.75` periods! If you prefer to specify the
                perceived delay instead, you could use an `iphase` of `-0.25 + 1` which
                is more intuitive. Note that the phase is not automatically wrapped
                into the range of `0..1`, so putting an `iphase` of `-0.25` currently
                results in a strange initial signal which only stabilizes to the
                correct behaviour after one period!
            </doc>
        </arg>
        <arg name="width" default="0.5">
            <doc>
                pulse width duty cycle from zero to one. If you want to
                specify the width rather in seconds, you can use the formula
                `width = freq * dur`, e.g. for a single sample impulse use
                `width = freq * SampleDur.ir`.
            </doc>
        </arg>
        <doc>
            <text>
                A non-band-limited pulse oscillator UGen.
                Outputs a high value of one and a low value of zero.
            </text>
            <example name="modulating frequency">
                LFPulse.ar(XLine.kr(1, 200, 10), 0, 0.2) * 0.1
            </example>
            <example name="modulating amplitude">
                LFPulse.kr(XLine.kr(1, 200, 10), 0, 0.2) * SinOsc.ar(440) * 0.1
            </example>
            <example name="used as both oscillator and LFO">
                LFPulse.ar(LFPulse.kr(3, 0, 0.3).madd(200, 200), 0, 0.2) * 0.1
            </example>
            <see>ugen.Pulse</see>
        </doc>
    </ugen>
    <ugen name="LFSaw">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="freq" default="440.0">
            <doc>
                oscillator frequency in Hertz
            </doc>
        </arg>
        <arg name="iphase" default="0.0" init="true">
            <doc>
                initial phase offset. For efficiency reasons this is a
                value ranging from -1 to 1 (thus equal to the initial output value).
                Note that a phase of zero (default) means the wave starts at 0 and
                rises to +1 before jumping down to -1. Use a phase of 1 to have the wave start at -1.
            </doc>
        </arg>
        <doc>
            <text>
                A sawtooth oscillator UGen. The oscillator is creating an aliased sawtooth,
                that is it does not use band-limiting. For a band-limited version use
                `Saw` instead. The signal range is -1 to +1.
            </text>
            <example name="modulating frequency">
                LFSaw.ar(XLine.kr(1, 200, 10)) * 0.1
            </example>
            <example name="modulating amplitude">
                LFSaw.kr(XLine.kr(1, 200, 10)) * SinOsc.ar(440) * 0.1
            </example>
            <example name="neuer deutscher SÃ¤gezahn">
                LFSaw.ar(LFSaw.kr(3).madd(200, 200)) * 0.1
            </example>
            <see>ugen.Saw</see>
        </doc>
    </ugen>
    <ugen name="LFPar">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="freq" default="440.0">
            <doc>
                oscillator frequency in Hertz
            </doc>
        </arg>
        <arg name="iphase" default="0.0" init="true">
            <doc>
                initial phase in cycle (0 to 1)
            </doc>
        </arg>
        <doc>
            <text>
                A sine-like oscillator UGen with a shape made of two parabolas. It has audible odd harmonics
                and is non-band-limited. Its output ranges from -1 to +1.
            </text>
            <example name="modulating frequency">
                LFPar.ar(XLine.kr(100, 20000, 10)) * 0.1
            </example>
            <example name="modulating amplitude">
                LFPar.kr(XLine.kr(1, 200, 10)) * SinOsc.ar(440) * 0.1
            </example>
            <example name="used as both oscillator and LFO">
                LFPar.ar(LFPar.kr(LFPar.kr(0.2).madd(8,10)).madd(400,800)) * 0.1
            </example>
            <see>ugen.LFCub</see>
        </doc>
    </ugen>
    <ugen name="LFCub">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="freq" default="440.0">
            <doc>
                oscillator frequency in Hertz
            </doc>
        </arg>
        <arg name="iphase" default="0.0" init="true">
            <doc>
                initial phase in cycle (0 to 1)
            </doc>
        </arg>
        <doc>
            <text>
                A sine-like oscillator UGen with a shape made of two cubic pieces. It is smoother than `LFPar`.
            </text>
            <example name="modulating frequency">
                LFPar.ar(XLine.kr(100, 20000, 10)) * 0.1
            </example>
            <example name="modulating amplitude">
                LFPar.kr(XLine.kr(1, 200, 10)) * SinOsc.ar(440) * 0.1
            </example>
            <example name="used as both oscillator and LFO">
                LFPar.ar(LFPar.kr(LFPar.kr(0.2).madd(8,10)).madd(400,800)) * 0.1
            </example>
            <see>ugen.LFPar</see>
        </doc>
    </ugen>
    <ugen name="LFTri">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="freq" default="440.0">
            <doc>
                frequency in Hertz
            </doc>
        </arg>
        <arg name="iphase" default="0.0" init="true">
            <doc>
                initial phase of the oscillator. A full phase (2 Pi or 360 degrees) is represented by
                an `iphase` value of 4. The initial phase cannot be modulated.
            </doc>
        </arg>
        <doc>
            <text>
                A triangle oscillator UGen designed for low frequency control signals (being non-band-limited).
                The output varies from -1 to 1.

                With an initial phase of zero, the oscillator begins at 0, rises to 1, then falls to -1 and goes
                back to zero after one complete phase. With an initial phase of 1 (corresponding to 90 degrees),
                the oscillator begins at 1 and then falls to -1. With an initial phase of 3 (or 270 degrees),
                the oscillator begins at -1 and then rises to 1.
            </text>
            <example name="modulating frequency">
                LFTri.ar(XLine.kr(100, 20000, 10)) * 0.1
            </example>
            <example name="modulating amplitude">
                LFTri.kr(XLine.kr(1, 200, 10)) * SinOsc.ar(440) * 0.1
            </example>
            <example name="used as both oscillator and LFO">
                LFTri.ar(LFTri.kr(LFTri.kr(0.2).madd(8,10)).madd(400,800)) * 0.1
            </example>
        </doc>
    </ugen>
    <ugen name="LFGauss">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="dur" default="1.0">
            <doc>
                duration in seconds of a full -1 &lt;= x &lt;= 1 cycle, or the reciprocal of the frequency
            </doc>
        </arg>
        <arg name="width" default="0.1">
            <doc>
                relative width of the bell. Best to keep below 0.25 when used as envelope.
            </doc>
        </arg>
        <arg name="phase" default="0.0">    <!-- in the current implementation can be modulated! -->
            <doc>
                phase offset
            </doc>
        </arg>
        <arg name="loop" default="true">
            <doc>
                if greater than zero, the UGen oscillates. Otherwise it calls `doneAction` after one cycle.
            </doc>
        </arg>
        <arg name="doneAction" default="doNothing">
            <doc>
                evaluated after cycle completes
            </doc>
        </arg>
        <doc>
            <text>
                A non-band-limited gaussian function oscillator UGen. Output ranges from `minVal` to 1. It
                implements the formula:
                {{{
                f(x) = exp((x - phase).squared / (-2 * width.squared))
                }}}
                where `x` is to vary in the range -1 to 1 over the period `dur`. `minVal` is the initial value
                at -1. E.g. for default parameters, it is `exp(-50)` or roughly zero.
            </text>
            <example name="dur and width can be modulated at audio rate">
                val dur = SinOsc.ar(MouseX.kr(2, 1000, 1) * Seq(1.0, 1.1)).linlin(-1, 1, 0.0006, 0.01)
                val width = SinOsc.ar(Seq(0.5, 0.55)).linlin(-1, 1, 0.01, 0.3)
                LFGauss.ar(dur, width) * 0.2
            </example>
            <example name="several frequencies and widths combined">
                val x    = MouseX.kr(1, 0.07, 1)
                val y    = MouseY.kr(1, 3)
                val mod  = LFGauss.ar(x, (-1 to -6 by -1).map(i => y.pow(i)))
                val carr = SinOsc.ar((0 to 5).map(i => 200 * 1.3.pow(i)))
                Mix(carr * mod) * 0.1
            </example>
            <example name="test spectrum">
                val son = LeakDC.ar(LFGauss.ar(0.005, 0.2))
                BPF.ar(son * 3, MouseX.kr(60, 2000, 1), 0.05)
            </example>
        </doc>
    </ugen>
    <ugen name="Impulse">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="freq" default="440.0">
            <doc>
                frequency in Hertz. A value of zero can be used to generate a singular impulse.
            </doc>
        </arg>
        <arg name="phase" default="0.0">
            <doc>
                phase offset in cycles (0 to 1)
            </doc>
        </arg>
        <doc>
            <text>
                A non-band-limited generator UGen for single sample impulses.
            </text>
            <example name="modulating frequency">
                Impulse.ar(XLine.kr(100, 20000, 10)) * 0.3
            </example>
            <example name="modulating amplitude">
                Impulse.kr(XLine.kr(1, 200, 10)) * SinOsc.ar(440) * 0.3
            </example>
            <example name="modulating phase">
                Impulse.ar(4, Seq(DC.kr(0), MouseX.kr(0, 1))) * 0.3
            </example>
            <see>ugen.LFPulse</see>
            <see>ugen.Dust</see>
            <see>ugen.Blip</see>
        </doc>
    </ugen>
    <ugen name="VarSaw">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="freq" default="440.0">
            <doc>
                frequency in Hertz
            </doc>
        </arg>
        <arg name="iphase" default="0.0">
            <doc>
                initial phase offset in cycle (0 to 1)
            </doc>
        </arg>
        <arg name="width" default="0.5">
            <doc>
                duty cycle from zero to one.
            </doc>
        </arg>
        <doc>
            <text>
                A sawtooth-triangle oscillator UGen with variable duty. A `width` of zero produces a sawtooth
                of falling slope, with an initial phase of zero making it start at +1. A `width` of 0.5 produces
                a triangle wave, starting at -1 then raising to +1, then falling again to -1. A `width` of 1.0
                produces a sawtooth of rising slope, starting -1.

                Increasing the initial wave will increase the
                offset into the waveform. For example, with a phase of 0.5 and a width of 0.5, the result is
                a triangle waveform that starts at +1.

                There is a strange anomaly for the falling sawtooth (zero width): Instead of starting directly
                at +1, the first sample is -1 and only from the second sample at +1 the waveform starts falling.
                In other words, the waveform has a delay of one sample.
            </text>
            <example name="width modulation">
                val freq  = LFPulse.kr(3, 0, 0.3).madd(200, 200)
                val width = LFTri.kr(1.0).madd(0.5, 0.5)
                VarSaw.ar(freq, 0, width) * 0.2
            </example>
            <see>ugen.Saw</see>
            <see>ugen.LFSaw</see>
            <see>ugen.SyncSaw</see>
        </doc>
    </ugen>
    <ugen name="SyncSaw">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="syncFreq" default="440.0">
            <doc>
                synchronizing (master) frequency which is the perceived fundamental
            </doc>
        </arg>
        <arg name="sawFreq" default="440.0">
            <doc>
                sawtooth (slave) frequency. It should typically be greater than `syncFreq`.
            </doc>
        </arg>
        <doc>
            <text>
                A sawtooth oscillator UGen that is hard sync'ed to a fundamental pitch. That is, a sawtooth waveform
                is produced at one frequency, `sawFreq`, whereas a trigger at a another frequency, `syncFreq`, resets
                the phase of the sawtooth to zero.

                This produces an effect similar to moving formants or pulse width modulation. This is not a band
                limited waveform, so it may alias.
            </text>
            <example name="modulate saw frequency">
                SyncSaw.ar(100, Line.kr(100, 800, 12)) * 0.2
            </example>
            <see>ugen.Saw</see>
            <see>ugen.VarSaw</see>
            <see>ugen.LFSaw</see>
        </doc>
    </ugen>
    <ugen name="K2A">
        <rate name="audio" implied="true"/>
        <arg name="in">
            <doc>
                control-rate signal to convert
            </doc>
        </arg>
        <doc>
            <text>
                A converter UGen that takes a control-rate input and produces an audio-rate output by means of
                linear interpolation. The current control input value is always reached in at the beginning of
                the subsequent control block. A special case is the initialization which begins directly at the
                first control input value (therefore, the first control block of the audio-rate output is
                is always constant.)

                For example, if the block size is 64, and the first three input values are -0.5, 0.6, 0.3, then
                the output signal will be 65 samples of value -0.5, followed by a linear ramp of 64 samples
                towards 0.6, followed by a linear ramp of 64 samples to towards 0.3.
            </text>
            <example name="compare control and audio rate">
                val a = K2A.ar(WhiteNoise.kr(0.3))
                val b =        WhiteNoise.ar(0.3)
                val c = LFPulse.ar(1, Seq(0, 0.5))
                c * Seq(a, b)
            </example>
            <see>A2K</see>
            <see>T2A</see>
            <see>DC</see>
        </doc>
    </ugen>
    <ugen name="A2K">
        <rate name="control" implied="true"/>
        <arg name="in">
            <doc>
                audio-rate signal to convert
            </doc>
        </arg>
        <doc>
            <text>
                A converter UGen that takes an audio-rate input and produces a control-rate output by means of
                sampling. The sample is always taken at the beginning of each control-block, while all other
                samples of the audio-rate input within that block are ignored.
            </text>
            <see>K2A</see>
            <see>T2K</see>
        </doc>
    </ugen>
    <ugen name="T2K">
        <rate name="control" implied="true"/>
        <arg name="in" rate="audio">
            <doc>
                audio-rate trigger input
            </doc>
        </arg>
        <doc>
            <text>
                A UGen that converts an audio-rate trigger input into a control-rate trigger output. A trigger
                occurs when a signal changes from less than or equal to zero to greater than zero. The UGen
                behaves strangely in that for a rising slope input signal, it will report the maximum value
                seen within the calculation block, but if the slope extends to the next block, it will output
                that second's block maximum value again instead of waiting for a fall to &lt;= 0.
            </text>
            <example name="down-sample audio-rate dust">
                val trig = T2K.kr(Dust.ar(4))
                Trig.kr(trig, 0.1) * SinOsc.ar(800) * 0.1
            </example>
            <see>ugen.K2A</see>
            <see>ugen.T2K</see>
            <see>ugen.Trig</see>
        </doc>
    </ugen>
    <ugen name="T2A">
        <rate name="audio" implied="true"/>
        <arg name="in">
            <doc>
                control-rate trigger input
            </doc>
        </arg>
        <doc>
            <text>
                A UGen that converts a control-rate trigger input into an audio-rate trigger output. A trigger
                occurs when a signal changes from less than or equal to zero to greater than zero. The output
                will have a single sample spike of the input trigger's amplitude at the beginning of the
                calculation block.
            </text>
            <example name="up-sample control-rate impulses">
                val trig = Impulse.kr(MouseX.kr(1, 100, 1))
                Ringz.ar(T2A.ar(trig), 800, 0.01) * 0.4
            </example>
            <see>ugen.K2A</see>
            <see>ugen.T2K</see>
            <see>ugen.Trig</see>
        </doc>
    </ugen>
    <ugen name="DC">
        <rate name="control"/>
        <rate name="audio"/>
        <!-- NOT: <output variadic="in"/> -->
        <arg name="in" init="true"> <!-- NOT: variadic="true" -->
            <doc>
                constant value to output, fixed at initialisation time.
            </doc>
        </arg>
        <doc>
            <text>
                A UGen that creates a constant signal at a given calculation rate.
                <!-- NOT: If the input is variadic, so will be the UGen's output (no multi-channel
                expansion needed). -->
            </text>
            <see>ugen.LeakDC</see>
        </doc>
    </ugen>
    <!--        <ugen name="Silent">
                <rate name="audio" implied="true"/>
                <output variadic="numChannels"/>
                <arg name="numChannels" type="int" default="1"/>
            </ugen> -->
    <ugen name="Line" side-effect="true" done-flag="true">
        <rate name="audio"/>
        <rate name="control"/>
        <arg name="start" default="0.0" init="true">
            <doc>
                Starting value
            </doc>
        </arg>
        <arg name="end" default="1.0" init="true">
            <doc>
                Ending value
            </doc>
        </arg>
        <arg name="dur" default="1.0" init="true">
            <doc>
                Duration in seconds
            </doc>
        </arg>
        <arg name="doneAction" default="doNothing">
            <doc>
                A done-action that is evaluated when the Line has reached the end value after the
                given duration
            </doc>
        </arg>
        <doc>
            <text>
                A line generator UGen that moves from a start value to the end value in a given duration.
            </text>
            <see>ugen.XLine</see>
            <see>ugen.EnvGen</see>
            <see>ugen.Ramp</see>
        </doc>
    </ugen>
    <ugen name="XLine" side-effect="true" done-flag="true">
        <rate name="audio"/>
        <rate name="control"/>
        <arg name="start" default="1.0" init="true">
            <doc>
                Starting value
            </doc>
        </arg>
        <arg name="end" default="2.0" init="true">
            <doc>
                Ending value
            </doc>
        </arg>
        <arg name="dur" default="1.0" init="true">
            <doc>
                Duration in seconds
            </doc>
        </arg>
        <arg name="doneAction" default="doNothing">
            <doc>
                A done-action that is evaluated when the Line has reached the end value after the
                given duration
            </doc>
        </arg>
        <doc>
            <text>
                An exponential curve generator UGen that moves from a start value to the end value in a given duration.

                At a given point in time `0 &lt;= t &lt;= dur`, the output value is `start * (stop/start).pow(t/dur)`.

                '''Warning''': It must be ensured that the both `start` is not zero and `start` and `end` have the
                same sign (e.g. a `start` of `-1` and an end of `-0.001` are valid),
                otherwise the UGen will output a `NaN`! While in the case of `end` being zero the UGen will also
                output zero, it is recommended to treat this case as pathological as well.
            </text>
        </doc>
    </ugen>

    <ugen name="Wrap">
        <rate name="scalar"/>
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in"/>
        <arg name="lo" default="0.0"/>
        <arg name="hi" default="1.0"/>
    </ugen>
    <ugen name="Fold">
        <rate name="scalar"/>
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in"/>
        <arg name="lo" default="0.0"/>
        <arg name="hi" default="1.0"/>
    </ugen>
    <ugen name="Clip">
        <rate name="scalar"/>
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in"/>
        <arg name="lo" default="0.0"/>
        <arg name="hi" default="1.0"/>
    </ugen>
    <!-- this should exist according to plugin sources...
    <ugen name="Unwrap"/>
    -->
    <ugen name="AmpComp">
        <rate name="scalar"/>
        <rate name="control"/>
        <rate name="audio">
            <arg name="freq" rate="ugen"/>
        </rate>
        <arg name="freq" default="261.626"/>
        <arg name="root" default="261.626"/>
        <arg name="expon" default="0.3333"/>
    </ugen>
    <ugen name="AmpCompA">
        <rate name="scalar"/>
        <rate name="control"/>
        <rate name="audio">
            <arg name="freq" rate="ugen"/>
        </rate>
        <arg name="freq" default="1000.0"/>
        <arg name="root" default="0.0"/>
        <arg name="minAmp" default="0.32"/>
        <arg name="rootAmp" default="1.0"/>
    </ugen>
    <ugen name="InRange">
        <rate name="scalar"/>
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in"/>
        <arg name="lo" default="0.0"/>
        <arg name="hi" default="1.0"/>
    </ugen>
    <ugen name="InRect">
        <rate name="scalar"/>
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="x"/>
        <arg name="y"/>
        <arg name="left" default="0.0"/>
        <arg name="top" default="0.0"/>
        <arg name="right" default="1.0"/>
        <arg name="bottom" default="1.0"/>
    </ugen>
    <ugen name="LinExp"> <!-- TODO: first arg rate has to be rate ? -->
        <rate name="scalar"/>
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to convert
            </doc>
        </arg>
        <arg name="srcLo" default="0.0">
            <doc>
                lower limit of input range
            </doc>
        </arg>
        <arg name="srcHi" default="1.0">
            <doc>
                upper limit of input range
            </doc>
        </arg>
        <arg name="dstLo" default="1.0">
            <doc>
                lower limit of output range
            </doc>
        </arg>
        <arg name="dstHi" default="2.0">
            <doc>
                upper limit of output range
            </doc>
        </arg>
        <doc>
            <text>
                A UGen which maps a linear range to an exponential range.
                The equivalent formula is `(dstHi / dstLo).pow((in - srcLo) / (srcHi - srcLo)) * dstLo`.

                '''Note''': No clipping is performed. If the input signal exceeds the input range, the output will also exceed its range.
            </text>
            <see>ugen.LinExp</see>
            <see>ugen.Clip</see>
        </doc>
    </ugen>
    <!--        <ugen name="LinLin">
                <rate name="scalar"/>
                <rate name="control"/>
                <rate name="audio"/>
                <arg name="in" rate="ugen">
                    <doc>
                        The input signal to convert.
                    </doc>
                </arg>
                <arg name="srcLo" default="0">
                    <doc>
                        The lower limit of input range.
                    </doc>
                </arg>
                <arg name="srcHi" default="1">
                    <doc>
                        The upper limit of input range.
                    </doc>
                </arg>
                <arg name="dstLo" default="0">
                    <doc>
                        The lower limit of output range.
                    </doc>
                </arg>
                <arg name="dstHi" default="1">
                    <doc>
                        The upper limit of output range.
                    </doc>
                </arg>
                <doc>
                    <text>
                        A UGen which maps a linear range to another linear range.
                        The equivalent formula is `(in - srcLo) / (srcHi - srcLo) * (dstHi - dstLo) + dstLo`.

                        '''Note''': No clipping is performed. If the input signal exceeds the input range, the output will also exceed its range.
                    </text>
                    <see>ugen.LinExp</see>
                    <see>ugen.Clip</see>
                </doc>
            </ugen>
    -->
    <ugen name="EnvGen" side-effect="true" done-flag="true">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="gate" default="open" pos="1"/>       <!-- negative values have special meaning, though... -->
        <arg name="levelScale" default="1.0" pos="2"/>  <!-- like init="true" but can be re-triggered... -->
        <arg name="levelBias" default="0.0" pos="3"/>
        <arg name="timeScale" default="1.0" pos="4"/>
        <arg name="doneAction" default="doNothing" pos="5"/>
        <arg name="envelope" variadic="true" pos="0"/>
    </ugen>
    <ugen name="Linen" side-effect="true" done-flag="true">
        <rate name="control"/>
        <!-- NOT SUPPORTED: <rate name="audio"/> -->
        <arg name="gate" default="open"/>
        <arg name="attack" default="0.01"/>
        <arg name="sustain" default="1.0"/>
        <arg name="release" default="1.0"/>
        <arg name="doneAction" default="doNothing"/>
    </ugen>
    <ugen name="IEnvGen">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="index" pos="1"/>  <!-- default="1.0" -->
        <arg name="envelope" variadic="true" pos="0"/>
    </ugen>
</ugens>