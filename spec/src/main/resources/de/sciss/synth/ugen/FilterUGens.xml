<ugens revision="5">
    <!-- all documented, except: APF -->
    <ugen name="Ramp">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                the signal to smooth out
            </doc>
        </arg>
        <arg name="dur" default="0.1">
            <doc>
                the ramp-time (seconds) which is also the interval of the sampling
            </doc>
        </arg>
        <doc>
            <text>
                A UGen which produces a linear lag (time smear) regarding
                and input signal. Other than `Lag` which is a feedback
                filter with exponential decay, `Ramp` applies a linear
                ramp. This is achieved by sampling the input signal
                at regular intervals given by the `lagTime` and starting
                a new line segment after each interval.
            </text>
            <see>ugen.Lag</see>
            <see>ugen.Sweep</see>
        </doc>
    </ugen>
    <ugen name="Lag">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal.
            </doc>
        </arg>
        <arg name="time" default="0.1">
            <doc>
                60 dB lag time in seconds.
            </doc>
        </arg>
        <doc>
            <text>
                An exponential lag UGen.
                This is essentially the same as `OnePole` except that instead of supplying the coefficient directly,
                it is calculated from a 60 dB lag time. This is the time required for the filter to converge to
                within 0.01 % of a value. This is useful for smoothing out control signals.
            </text>
            <see>ugen.OnePole</see>
            <see>ugen.LagUD</see>
            <see>ugen.Lag2</see>
            <see>ugen.Ramp</see>
        </doc>
    </ugen>
    <ugen name="Lag2">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal.
            </doc>
        </arg>
        <arg name="time" default="0.1">
            <doc>
                60 dB lag time in seconds.
            </doc>
        </arg>
        <doc>
            <text>
                A cascaded exponential lag
                UGen. `Lag2.kr(in, time)` is equivalent to `Lag.kr(Lag.kr(in, time), time)`,
                thus resulting in a smoother transition. This saves on CPU as you only have to
                calculate the decay factor once instead of twice.
            </text>
            <see>ugen.Lag</see>
            <see>ugen.Lag2UD</see>
            <see>ugen.Lag3</see>
        </doc>
    </ugen>
    <ugen name="Lag3">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal.
            </doc>
        </arg>
        <arg name="time" default="0.1">
            <doc>
                60 dB lag time in seconds.
            </doc>
        </arg>
        <doc>
            <text>
                A cascaded exponential lag
                UGen. `Lag3.kr(in, time)` is equivalent to `Lag.kr(Lag.kr(Lag.kr(Lag.kr(in, time), time), time)`,
                thus resulting in a smoother transition. This saves on CPU as you only have to
                calculate the decay factor once instead of three times.
            </text>
            <see>ugen.Lag</see>
            <see>ugen.Lag3UD</see>
            <see>ugen.Lag2</see>
        </doc>
    </ugen>
    <ugen name="LagUD">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal.
            </doc>
        </arg>
        <arg name="timeUp" default="0.1">
            <doc>
                60 dB lag time in seconds effective during a rising slope in the input signal
            </doc>
        </arg>
        <arg name="timeDown" default="0.1">
            <doc>
                60 dB lag time in seconds effective during a falling slope in the input signal
            </doc>
        </arg>
        <doc>
            <text>
                An exponential lag UGen with separate inputs for up and down slope.
                This is essentially the same as `Lag` except that you can supply a different 60 dB time
                for when the signal goes up, from when the signal goes down.
            </text>
            <see>ugen.Lag</see>
            <see>ugen.Lag2UD</see>
        </doc>
    </ugen>
    <ugen name="Lag2UD">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal.
            </doc>
        </arg>
        <arg name="timeUp" default="0.1">
            <doc>
                60 dB lag time in seconds effective during a rising slope in the input signal
            </doc>
        </arg>
        <arg name="timeDown" default="0.1">
            <doc>
                60 dB lag time in seconds effective during a falling slope in the input signal
            </doc>
        </arg>
        <doc>
            <text>
                A cascaded exponential lag UGen with separate inputs for up and down
                slope. `Lag2UD.kr(in, up, down)` is equivalent to `LagUD.kr(LagUD.kr(in, up, down), up, down)`,
                thus resulting in a smoother transition. This saves on CPU as you only have to
                calculate the decay factors once instead of twice.
            </text>
            <see>ugen.LagUD</see>
            <see>ugen.Lag2</see>
            <see>ugen.Lag3UD</see>
        </doc>
    </ugen>
    <ugen name="Lag3UD">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal.
            </doc>
        </arg>
        <arg name="timeUp" default="0.1">
            <doc>
                60 dB lag time in seconds effective during a rising slope in the input signal
            </doc>
        </arg>
        <arg name="timeDown" default="0.1">
            <doc>
                60 dB lag time in seconds effective during a falling slope in the input signal
            </doc>
        </arg>
        <doc>
            <text>
                A cascaded exponential lag UGen with separate inputs for up and down
                slope. `Lag3UD.kr(in, up, down)` is equivalent to `LagUD.kr(LagUD.kr(LagUD.kr(in, up, down), up, down), up, down)`,
                thus resulting in a smoother transition. This saves on CPU as you only have to
                calculate the decay factors once instead of three times.
            </text>
            <see>ugen.LagUD</see>
            <see>ugen.Lag3</see>
            <see>ugen.Lag2UD</see>
        </doc>
    </ugen>
    <ugen name="OnePole">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be processed
            </doc>
        </arg>
        <arg name="coeff" default="0.5">
            <doc>
                feedback coefficient. Should be between -1 and +1
            </doc>
        </arg>
        <doc>
            <text>
                A one pole (IIR) filter UGen.
                Implements the formula :
                {{{
                out(i) = ((1 - abs(coef)) * in(i)) + (coef * out(i-1))
                }}}
            </text>
            <see>ugen.OneZero</see>
            <see>ugen.TwoPole</see>
            <see>ugen.Lag</see>
        </doc>
    </ugen>
    <ugen name="OneZero">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be processed
            </doc>
        </arg>
        <arg name="coeff" default="0.5">
            <doc>
                feed forward coefficient. +0.5 makes a two point averaging filter (see also `LPZ1`),
                -0.5 makes a differentiator (see also `HPZ1`),  +1 makes a single sample delay (see also `Delay1`),
                -1 makes an inverted single sample delay.
            </doc>
        </arg>
        <doc>
            <text>
                A one zero (FIR) filter UGen.
                Implements the formula :
                {{{
                out(i) = ((1 - abs(coef)) * in(i)) + (coef * in(i-1))
                }}}
            </text>
            <see>ugen.OnePole</see>
            <see>ugen.TwoZero</see>
            <see>ugen.LPZ1</see>
            <see>ugen.HPZ1</see>
            <see>ugen.Delay1</see>
            <see>ugen.Integrator</see>
        </doc>
    </ugen>
    <ugen name="TwoPole">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be filtered
            </doc>
        </arg>
        <arg name="freq" default="440.0">
            <doc>
                frequency of pole angle, in Hertz
            </doc>
        </arg>
        <arg name="radius" default="0.8">
            <doc>
                radius of pole angle. Should be between 0 and 1
            </doc>
        </arg>
        <doc>
            <text>
                A two pole filter UGen. This provides lower level access to setting of pole location.
                For general purposes `Resonz` is better.
            </text>
            <example name="static frequency">
                TwoPole.ar(WhiteNoise.ar(0.005), 2000, 0.95)
            </example>
            <example name="sweeping frequency">
                TwoPole.ar(WhiteNoise.ar(0.005), XLine.kr(800, 8000, 8), 0.95)
            </example>
            <example name="mouse controlled frequency">
                TwoPole.ar(WhiteNoise.ar(0.005), MouseX.kr(800, 8000, 1), 0.95)
            </example>
            <see>ugen.OnePole</see>
            <see>ugen.TwoZero</see>
            <see>ugen.Resonz</see>
        </doc>
    </ugen>
    <ugen name="TwoZero">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be filtered
            </doc>
        </arg>
        <arg name="freq" default="440.0">
            <doc>
                frequency of zero angle, in Hertz
            </doc>
        </arg>
        <arg name="radius" default="0.8">
            <doc>
                radius of zero
            </doc>
        </arg>
        <doc>
            <text>
                A two zero filter UGen.
            </text>
            <example name="frequency sweep">
                TwoZero.ar(WhiteNoise.ar(0.125), XLine.kr(20, 20000, 8), 1)
            </example>
            <see>ugen.OneZero</see>
            <see>ugen.TwoPole</see>
        </doc>
    </ugen>
    <ugen name="Decay">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be processed
            </doc>
        </arg>
        <arg name="time" default="1.0"/>
        <doc>
            <text>
                An integrator UGen with exponential decay of past values. This is essentially the same
                as `Integrator` except that instead of supplying the coefficient directly, it is calculated
                from a 60 dB decay time. This is the time required for the integrator to lose 99.9 % of its
                value or -60dB.

                Note: This should not be confused with `Lag` which does not overshoot due to integration,
                but asymptotically follows the input signal.
            </text>
            <see>ugen.Integrator</see>
            <see>ugen.Decay2</see>
            <see>ugen.Lag</see>
        </doc>
    </ugen>
    <ugen name="Decay2">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be processed
            </doc>
        </arg>
        <arg name="attack" default="0.01"/>
        <arg name="release" default="1.0"/>
        <doc>
            <text>
                A integrator UGen with controllable attack and release times.
                While `Decay` has a very sharp attack and can produce clicks, `Decay2` rounds off the attack by
                subtracting one Decay from another. It can be seen as equivalent to
                {{{
                Decay.ar(in, release) - Decay.ar(in, attack)
                }}}

                Note: This should not be confused with `LagUD` which does not overshoot due to integration,
                but asymptotically follows the input signal.
            </text>
            <see>ugen.Decay</see>
            <see>ugen.Integrator</see>
            <see>ugen.LagUD</see>
        </doc>
    </ugen>
    <!-- this should exist according to plugin sources...
    <ugen name="Flip"/>
    -->
    <ugen name="Delay1">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in">
            <doc>
                input to be delayed
            </doc>
        </arg>
        <doc>
            <text>
                A UGen that delays the input by 1 audio frame or control period.

                For audio-rate signals the delay is 1 audio frame, and for control-rate signals
                the delay is 1 control period.
            </text>
            <example name="analog to HPZ1">
                val z = PinkNoise.ar
                val x = z - Delay1.ar(z)
                // mouse button to compare dry/wet
                LinXFade2.ar(z, x, MouseButton.kr(-1, 1))
            </example>
            <see>ugen.Delay2</see>
            <see>ugen.DelayN</see>
        </doc>
    </ugen>
    <ugen name="Delay2">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in">
            <doc>
                input to be delayed
            </doc>
        </arg>
        <doc>
            <text>
                A UGen that delays the input by 2 audio frames or control periods.

                For audio-rate signals the delay is 2 audio frames, and for control-rate signals
                the delay is 2 control periods.
            </text>
            <example name="high-frequency comb filter">
                val z = PinkNoise.ar
                val x = z - Delay2.ar(z)
                // mouse button to compare dry/wet
                LinXFade2.ar(z, x, MouseButton.kr(-1, 1))
            </example>
            <see>ugen.Delay1</see>
            <see>ugen.DelayN</see>
        </doc>
    </ugen>
    <ugen name="Integrator">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be processed
            </doc>
        </arg>
        <arg name="coeff" default="1.0">
            <doc>
                the leak coefficient. Should be between -1 and +1
            </doc>
        </arg>
        <doc>
            <text>
                A filter UGen to integrate an input signal with a leak.
                Implements the formula :
                {{{
                out(i) = in(i) + (coef * out(i-1))
                }}}
            </text>
            <see>ugen.OnePole</see>
            <see>ugen.HPZ1</see>
            <see>ugen.LPZ1</see>
        </doc>
    </ugen>
    <ugen name="LeakDC">
        <rate name="control">
            <arg name="coeff" default="0.9"/>
        </rate>
        <rate name="audio">
            <arg name="coeff" default="0.995"/>
        </rate>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be filtered
            </doc>
        </arg>
        <arg name="coeff">
            <doc>
                the leak coefficient determines the filter strength. the value must
                be between zero and one (exclusive) for the filter to remain stable.
                values closer to one produce less bass attenuation.
            </doc>
        </arg>
        <doc>
            <text>
                A filter UGen to remove very low frequency content DC offset.
            </text>
            <example name="show DC with mouse-controlled coefficient">
                val freq = 800
                val in   = LFPulse.ar(freq).madd(0.5, 0.5)
                val coef = MouseX.kr(0.9, 0.999)
                val flt  = LeakDC.ar(in, coef)
                val dc   = RunningSum.ar(flt, SampleRate.ir/freq)
                coef.poll(2)
                dc  .poll(2)
                0
            </example>
            <see>ugen.DC</see>
        </doc>
    </ugen>
    <ugen name="LPZ1">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be filtered
            </doc>
        </arg>
        <doc>
            <text>
                two point average filter UGen.
                Implements the formula :
                {{{
                out(i) = 0.5 * (in(i) + in(i-1))
                }}}
            </text>
            <example name="engage with mouse button">
                val sig = WhiteNoise.ar(0.5)
                val flt = LPZ1.ar(sig)
                LinXFade2.ar(sig, flt, MouseButton.kr(-1, 1))
            </example>
            <see>ugen.OnePole</see>
            <see>ugen.HPZ1</see>
            <see>ugen.LPZ2</see>
            <see>ugen.Integrator</see>
            <see>ugen.Delay1</see>
        </doc>
    </ugen>
    <ugen name="HPZ1">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be filtered
            </doc>
        </arg>
        <doc>
            <text>
                A two point difference filter UGen.
                Implements the formula :
                {{{
                out(i) = 0.5 * (in(i) - in(i-1))
                }}}
            </text>
            <example name="engage with mouse button">
                val sig = PinkNoise.ar
                val flt = HPZ1.ar(sig)
                LinXFade2.ar(sig, flt, MouseButton.kr(-1, 1))
            </example>
            <example name="detect changes">
                val z  = LFNoise0.ar(2)
                val f  = HPZ1.ar(z)
                val ch = f sig_!= 0 // input increased or decreased
                z.poll(ch, "now")
                0
            </example>
            <see>ugen.OneZero</see>
            <see>ugen.LPZ1</see>
            <see>ugen.Delay1</see>
        </doc>
    </ugen>
    <ugen name="LPZ2">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be filtered
            </doc>
        </arg>
        <doc>
            <text>
                three point average filter UGen.
                Implements the formula :
                {{{
                out(i) = 0.25 * (in(i) + 2 * in(i-1) + in(i-2))
                }}}
            </text>
            <example name="engage with mouse button">
                val sig = WhiteNoise.ar(0.5)
                val flt = LPZ2.ar(sig)
                LinXFade2.ar(sig, flt, MouseButton.kr(-1, 1))
            </example>
            <see>ugen.LPZ1</see>
            <see>ugen.HPZ2</see>
            <see>ugen.BPZ2</see>
            <see>ugen.BRZ2</see>
        </doc>
    </ugen>
    <ugen name="HPZ2">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be filtered
            </doc>
        </arg>
        <doc>
            <text>
                three point difference filter UGen.
                Implements the formula :
                {{{
                out(i) = 0.25 * (in(i) - 2 * in(i-1) + in(i-2))
                }}}
            </text>
            <example name="engage with mouse button">
                val sig = WhiteNoise.ar(0.5)
                val flt = HPZ2.ar(sig)
                LinXFade2.ar(sig, flt, MouseButton.kr(-1, 1))
            </example>
            <see>ugen.LPZ1</see>
            <see>ugen.HPZ2</see>
            <see>ugen.BPZ2</see>
            <see>ugen.BRZ2</see>
        </doc>
    </ugen>
    <ugen name="BPZ2">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be filtered
            </doc>
        </arg>
        <doc>
            <text>
                a special fixed band-pass filter UGen.
                Implements the formula :
                {{{
                out(i) = 0.5 * (in(i) - in(i-2))
                }}}
                This filter cuts out frequencies around zero Hertz and Nyquist.
            </text>
            <example name="engage with mouse button">
                val sig = WhiteNoise.ar(0.5)
                val flt = BPZ2.ar(sig)
                LinXFade2.ar(sig, flt, MouseButton.kr(-1, 1))
            </example>
            <see>ugen.HPZ2</see>
            <see>ugen.LPZ2</see>
            <see>ugen.BRZ2</see>
            <see>ugen.BPF</see>
        </doc>
    </ugen>
    <ugen name="BRZ2">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be filtered
            </doc>
        </arg>
        <doc>
            <text>
                a special fixed band-reject filter UGen.
                Implements the formula :
                {{{
                out(i) = 0.5 * (in(i) + in(i-2))
                }}}
                This filter cuts out frequencies around half of the Nyquist frequency.
            </text>
            <example name="engage with mouse button">
                val sig = WhiteNoise.ar(0.5)
                val flt = BRZ2.ar(sig)
                LinXFade2.ar(sig, flt, MouseButton.kr(-1, 1))
            </example>
            <see>ugen.HPZ1</see>
            <see>ugen.HPZ2</see>
            <see>ugen.BRF</see>
        </doc>
    </ugen>
    <ugen name="APF">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen"/>
        <arg name="freq" default="440.0"/>
        <arg name="radius" default="0.8"/>
    </ugen>
    <ugen name="LPF">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be filtered
            </doc>
        </arg>
        <arg name="freq" default="440.0">
            <doc>
                cutoff frequency in Hertz
            </doc>
        </arg>
        <doc>
            <text>
                A second order low pass filter UGen.
            </text>
            <example name="modulated frequency">
                val in   = Saw.ar(200) * 0.5
                val freq = SinOsc.ar(XLine.ar(0.3, 100, 20)).madd(3600, 4000)
                LPF.ar(in, freq)
            </example>
            <example name="mouse controlled frequency">
                val in   = WhiteNoise.ar(0.5)
                val freq = MouseX.kr(200, 10000, 1)
                LPF.ar(in, freq)
            </example>
            <see>ugen.HPF</see>
            <see>ugen.BPF</see>
            <see>ugen.BRF</see>
            <see>ugen.RLPF</see>
            <see>ugen.LPZ1</see>
        </doc>
    </ugen>
    <ugen name="HPF">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be filtered
            </doc>
        </arg>
        <arg name="freq" default="440.0">
            <doc>
                cutoff frequency in Hertz
            </doc>
        </arg>
        <doc>
            <text>
                A second order high pass filter UGen.
            </text>
            <example name="modulated frequency">
                val in   = Saw.ar(200) * 0.5
                val freq = SinOsc.ar(XLine.ar(0.3, 100, 20)).madd(3600, 4000)
                HPF.ar(in, freq)
            </example>
            <example name="mouse controlled frequency">
                val in   = WhiteNoise.ar(0.5)
                val freq = MouseX.kr(200, 10000, 1)
                HPF.ar(in, freq)
            </example>
            <see>ugen.LPF</see>
            <see>ugen.BPF</see>
            <see>ugen.BRF</see>
            <see>ugen.RHPF</see>
            <see>ugen.HPZ1</see>
        </doc>
    </ugen>
    <ugen name="BPF">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be filtered
            </doc>
        </arg>
        <arg name="freq" default="440.0">
            <doc>
                center frequency in Hertz
            </doc>
        </arg>
        <arg name="rq" default="1.0">
            <doc>
                reciprocal of Q. The Q (or quality) is conventionally defined as center-frequency / bandwidth,
                meaning that rq = bandwidth / center-frequency. A higher Q or lower rq produces a steeper filter.
            </doc>
        </arg>
        <doc>
            <text>
                A second order band pass filter UGen.
            </text>
            <example name="modulated frequency">
                val in   = Saw.ar(200) * 0.5
                val freq = SinOsc.ar(XLine.ar(0.3, 100, 20)).madd(3600, 4000)
                BPF.ar(in, freq)
            </example>
            <example name="mouse controlled frequency and Q">
                val in   = WhiteNoise.ar(0.5)
                val freq = MouseX.kr(200, 10000, 1)
                val q    = MouseY.kr(1, 100, 1) // bottom to top
                val flt  = BPF.ar(in, freq, q.reciprocal)
                flt * q.sqrt // compensate for energy loss
            </example>
            <see>ugen.HPF</see>
            <see>ugen.LPF</see>
            <see>ugen.BRF</see>
            <see>ugen.Resonz</see>
            <see>ugen.MidEQ</see>
        </doc>
    </ugen>
    <ugen name="BRF">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be filtered
            </doc>
        </arg>
        <arg name="freq" default="440.0">
            <doc>
                center frequency in Hertz
            </doc>
        </arg>
        <arg name="rq" default="1.0">
            <doc>
                reciprocal of Q. The Q (or quality) is conventionally defined as center-frequency / bandwidth,
                meaning that rq = bandwidth / center-frequency. A higher Q or lower rq produces a steeper filter.
                Too high values for `rq` may blow the filter up!
            </doc>
        </arg>
        <doc>
            <text>
                A second order band reject (notch) filter UGen.
            </text>
            <example name="modulated frequency">
                val in   = Saw.ar(200) * 0.5
                val freq = SinOsc.ar(XLine.ar(0.3, 100, 20)).madd(3600, 4000)
                BRF.ar(in, freq)
            </example>
            <example name="mouse controlled frequency and Q">
                val in   = WhiteNoise.ar(0.5)
                val freq = MouseX.kr(200, 10000, 1)
                val q    = MouseY.kr(0.5, 10, 1) // bottom to top
                BRF.ar(in, freq, q.reciprocal)
            </example>
            <see>ugen.HPF</see>
            <see>ugen.LPF</see>
            <see>ugen.BPF</see>
            <see>ugen.MidEQ</see>
        </doc>
    </ugen>
    <ugen name="RLPF">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be filtered
            </doc>
        </arg>
        <arg name="freq" default="440.0">
            <doc>
                cutoff frequency in Hertz
            </doc>
        </arg>
        <arg name="rq" default="1.0">
            <doc>
                reciprocal of Q. The Q (or quality) is conventionally defined as cutoff-frequency / bandwidth,
                meaning that rq = bandwidth / cutoff-frequency. A higher Q or lower rq produces a steeper filter.
            </doc>
        </arg>
        <doc>
            <text>
                A resonant low pass filter UGen.
            </text>
            <example name="mouse controlled frequency and Q">
                val in   = WhiteNoise.ar(0.5)
                val freq = MouseX.kr(200, 10000, 1)
                val q    = MouseY.kr(1, 100, 1) // bottom to top
                val flt  = RLPF.ar(in, freq, q.reciprocal)
                flt / q.sqrt // compensate for energy loss
            </example>
            <see>ugen.LPF</see>
            <see>ugen.RHPF</see>
            <see>ugen.Resonz</see>
        </doc>
    </ugen>
    <ugen name="RHPF">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be filtered
            </doc>
        </arg>
        <arg name="freq" default="440.0">
            <doc>
                cutoff frequency in Hertz
            </doc>
        </arg>
        <arg name="rq" default="1.0">
            <doc>
                reciprocal of Q. The Q (or quality) is conventionally defined as cutoff-frequency / bandwidth,
                meaning that rq = bandwidth / cutoff-frequency. A higher Q or lower rq produces a steeper filter.
            </doc>
        </arg>
        <doc>
            <text>
                A resonant high pass filter UGen.
            </text>
            <example name="mouse controlled frequency and Q">
                val in   = WhiteNoise.ar(0.5)
                val freq = MouseX.kr(200, 10000, 1)
                val q    = MouseY.kr(1, 100, 1) // bottom to top
                val flt  = RHPF.ar(in, freq, q.reciprocal)
                flt / q.sqrt // compensate for energy loss
            </example>
            <see>ugen.HPF</see>
            <see>ugen.RLPF</see>
            <see>ugen.Resonz</see>
        </doc>
    </ugen>

    <ugen name="Slew">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal
            </doc>
        </arg>
        <arg name="up" default="1.0">
            <doc>
                maximum upward slope.
            </doc>
        </arg>
        <arg name="down" default="1.0">
            <doc>
                maximum downward slope.
            </doc>
        </arg>
        <doc>
            <text>
                A slew rate limiter UGen.
                Limits the slope of an input signal. The slope is expressed in units per second.

                Since the UGen is initialized with the initial value of the input signal, some tricks
                must be applied to set it to an alternative start value. For example:
                {{{
                val in = Select.kr(ToggleFF.kr(1), Seq("start".ir, "target".kr))
                Slew.kr(in)  // begins at "start" and moves towards "target"
                }}}
            </text>
        </doc>
    </ugen>
    <ugen name="Slope">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be measured
            </doc>
        </arg>
        <doc>
            <text>
                A UGen measuring the slope of signal.
                It calculates the rate of change per second of a signal, as given by the following formula:
                {{{
                out(i) = (in(i) - in(i-1)) * sampleRate
                }}}
                It thus equal to `HPZ1.ar(_) * 2 * SampleRate.ir`
            </text>
        </doc>
    </ugen>

    <ugen name="MidEQ">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be filtered
            </doc>
        </arg>
        <arg name="freq" default="440.0">
            <doc>
                center frequency in Hertz
            </doc>
        </arg>
        <arg name="rq" default="1.0">
            <doc>
                reciprocal of Q. The Q (or quality) is conventionally defined as center-frequency / bandwidth,
                meaning that rq = bandwidth / center-frequency. A higher Q or lower rq produces a steeper filter.
                Too high values for `rq` may blow the filter up!
            </doc>
        </arg>
        <arg name="gain" default="0.0">
            <doc>
                The amount of boost (when positive) or attenuation (when negative) applied to
                the frequency band, in decibels.
            </doc>
        </arg>
        <doc>
            <text>
                A single band parametric equalizer UGen. It attenuates or boosts a frequency band.
            </text>
            <example name="mouse controlled frequency and boost">
                val in   = WhiteNoise.ar(0.25)
                val freq = MouseX.kr(200, 10000, 1)
                val gain = MouseY.kr(-12, 12) // bottom to top
                MidEQ.ar(in, freq, rq = 0.5, gain = gain)
            </example>
            <see>ugen.BPF</see>
            <see>ugen.BRF</see>
            <see>ugen.HPF</see>
            <see>ugen.LPF</see>
            <see>ugen.Resonz</see>
        </doc>
    </ugen>
    <ugen name="Median">
        <rate name="control"/>
        <rate name="audio">
            <arg name="in" rate="ugen">
                <doc>
                    input signal to be processed
                </doc>
            </arg>
        </rate>
        <arg name="length" default="3" init="true" pos="1">
            <doc>
                window size. I.e., the number of input samples in which to find the median.
                Must be an odd number from 1 to 31. A value of 1 has no effect.
                ''Warning'': This parameter is only read an initialization time and
                cannot be modulated while the UGen is running.
            </doc>
        </arg>
        <arg name="in" pos="0"/>
        <doc warn-pos="true">
            <text>
                A filter UGen that calculates the median of a running window over its input signal.
                This non-linear filter can be used to reduce impulse noise from a signal.
            </text>
            <example name="engage with mouse button">
                val in  = Saw.ar(500) * 0.1 + Dust2.ar(100) * 0.9 // signal plus noise
                val flt = Median.ar(in, 3)
                LinXFade2.ar(in, flt, MouseButton.kr(-1, 1))
            </example>
            <example name="long filter distorts by chopping off peaks in input">
                Median.ar(SinOsc.ar(1000) * 0.2, 31)
            </example>
            <see>ugen.LPF</see>
            <see>ugen.LeakDC</see>
            <see>ugen.RunningSum</see>
        </doc>
    </ugen>

    <ugen name="Resonz">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be filtered
            </doc>
        </arg>
        <arg name="freq" default="440.0">
            <doc>
                resonant frequency in Hertz
            </doc>
        </arg>
        <arg name="rq" default="1.0">
            <doc>
                reciprocal of Q. The Q (or quality) is conventionally defined as center-frequency / bandwidth,
                meaning that rq = bandwidth / center-frequency. A higher Q or lower rq produces a steeper filter.
            </doc>
        </arg>
        <doc>
            <text>
                A two pole resonant filter UGen. It has zeroes at `z = +1` and `z = -1`.

                Based on K. Steiglitz, "A Note on Constant-Gain Digital Resonators", Computer Music Journal,
                vol 18, no. 4, pp. 8-10, Winter 1994.
            </text>
            <example name="modulated frequency">
                val in   = Saw.ar(200) * 0.5
                val freq = SinOsc.ar(XLine.ar(0.3, 100, 20)).madd(3600, 4000)
                Resonz.ar(in, freq)
            </example>
            <example name="mouse controlled frequency and Q">
                val in   = WhiteNoise.ar(0.5)
                val freq = MouseX.kr(200, 10000, 1)
                val q    = MouseY.kr(1, 100, 1) // bottom to top
                val flt  = Resonz.ar(in, freq, q.reciprocal)
                flt * q.sqrt // compensate for energy loss
            </example>
            <see>ugen.BPF</see>
            <see>ugen.Ringz</see>
            <see>ugen.HPF</see>
            <see>ugen.LPF</see>
            <see>ugen.MidEQ</see>
        </doc>
    </ugen>
    <ugen name="Ringz">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be filtered
            </doc>
        </arg>
        <arg name="freq" default="440.0">
            <doc>
                resonant frequency in Hertz
            </doc>
        </arg>
        <arg name="decay" default="1.0">
            <doc>
                the 60 dB decay time in seconds
            </doc>
        </arg>
        <doc>
            <text>
                A resonant or "ringing" filter UGen. This is the same as `Resonz`, except that instead of a
                Q parameter, the bandwidth is specified as a 60 dB ring decay time.
                One `Ringz` is equivalent to one component of the `Klank` UGen.
            </text>
            <example name="module ring time">
                Ringz.ar(Impulse.ar(6) * 0.3, 2000, XLine.kr(4, 0.04, 8))
            </example>
            <example name="modulated frequency">
                val in   = Saw.ar(200) * 0.02
                val freq = SinOsc.ar(XLine.ar(0.3, 100, 20)).madd(2800, 4800)
                Ringz.ar(in, freq)
            </example>
            <example name="multiple glissandi excited by noise">
                val ex = WhiteNoise.ar(0.001)
                Mix.fill(10) {
                  Ringz.ar(ex,
                    XLine.kr(ExpRand(100, 5000), ExpRand(100, 5000), 20),
                  0.5)
                }
            </example>
            <see>ugen.Resonz</see>
            <see>ugen.Formlet</see>
            <see>ugen.BPF</see>
            <see>ugen.Klank</see>
            <see>ugen.MidEQ</see>
        </doc>
    </ugen>
    <ugen name="Formlet">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be filtered
            </doc>
        </arg>
        <arg name="freq" default="440.0">
            <doc>
                resonant frequency in Hertz
            </doc>
        </arg>
        <arg name="attack" default="1.0">
            <doc>
                the 60 dB attack time in seconds
            </doc>
        </arg>
        <arg name="decay" default="1.0">
            <doc>
                the 60 dB decay time in seconds
            </doc>
        </arg>
        <doc>
            <text>
                A FOF-like resonant filter UGen. Its impulse response is like that of a sine wave with a `Decay2`
                envelope over it. It is possible to control the attack and decay times.

                `Formlet` is equivalent to:
                {{{
                Ringz(in, freq, decay) - Ringz(in, freq, attack)
                }}}

                The great advantage to this filter over FOF (Fonction d'onde formantique) is that there is no limit
                to the number of overlapping grains since the grain is just the impulse response of the filter.
            </text>
            <example name="modulated formant frequency">
                val in = Blip.ar(SinOsc.kr(5,0).madd(20, 300), 1000) * 0.1
                Formlet.ar(in, XLine.kr(1500, 700, 8), 0.005, 0.04)
            </example>
            <example name="mouse control of frequency and decay time">
                val in    = Blip.ar(SinOsc.kr(5,0).madd(20, 300), 1000) * 0.1
                val freq  = MouseY.kr(700, 2000, 1)
                val decay = MouseX.kr(0.01, 0.2, 1)
                Formlet.ar(in, freq, attack = 0.005, decay = decay)
            </example>
            <see>ugen.Ringz</see>
            <see>ugen.Resonz</see>
            <see>ugen.RLPF</see>
            <see>ugen.RHPF</see>
        </doc>
    </ugen>

    <ugen name="FOS">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be filtered
            </doc>
        </arg>
        <arg name="a0" default="0.0"/>
        <arg name="a1" default="0.0"/>
        <arg name="b1" default="0.0"/>
        <doc>
            <text>
                A first order filter section UGen. Filter coefficients are given directly rather
                than calculated for you. The formula is equivalent to:
                {{{
                out(i) = a0 * in(i) + a1 * in(i-1) + b1 * out(i-1)
                }}}
            </text>
            <example name="same as OnePole">
                val x = LFTri.ar(0.4) * 0.99
                FOS.ar(LFSaw.ar(200) * 0.1, 1 - x.abs, 0.0, x)
            </example>
            <example name="same as OneZero">
                val x = LFTri.ar(0.4) * 0.99
                FOS.ar(LFSaw.ar(200) * 0.1, 1 - x.abs, x, 0.0)
            </example>
            <see>ugen.SOS</see>
            <see>ugen.OnePole</see>
            <see>ugen.OneZero</see>
        </doc>
    </ugen>
    <ugen name="SOS">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be filtered
            </doc>
        </arg>
        <arg name="a0" default="0.0"/>
        <arg name="a1" default="0.0"/>
        <arg name="a2" default="0.0"/>
        <arg name="b1" default="0.0"/>
        <arg name="b2" default="0.0"/>
        <doc>
            <text>
                A second order filter section (biquad) UGen. Filter coefficients are given directly rather
                than calculated for you. The formula is equivalent to:
                {{{
                out(i) = a0 * in(i) + a1 * in(i-1) + a2 * in(i-2) + b1 * out(i-1) + b2 * out(i-2)
                }}}
            </text>
            <example name="same as TwoPole">
                val theta = MouseX.kr(0.2*math.Pi, 0.9*math.Pi)
                val rho   = MouseY.kr(0.6, 0.98)
                val b1    = 2.0 * rho * theta.cos
                val b2    = -(rho.squared)
                SOS.ar(WhiteNoise.ar(Seq(0.05, 0.05)), 1.0, 0.0, 0.0, b1, b2)
            </example>
            <example name="used as control signal">
                val theta = MouseX.kr(0.2*math.Pi, math.Pi)
                val rho   = MouseY.kr(0.6, 0.99)
                val b1    = 2.0 * rho * theta.cos
                val b2    = -(rho.squared)
                val vib   = SOS.kr(LFSaw.kr(3.16), 1.0, 0.0, 0.0, b1, b2)
                SinOsc.ar(vib * 200 + 600) * 0.2
            </example>
            <see>ugen.FOS</see>
        </doc>
    </ugen>

    <ugen name="Compander">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in">
            <doc>
                The signal to be compressed / expanded / gated.
            </doc>
        </arg>
        <arg name="ctrl">
            <doc>
                The signal whose amplitude controls the processor. Often the same as in, but one may wish
                to apply equalization or delay to it to change the compressor character (side-chaining), or even feed
                a completely different signal, for instance in a ducking application.
            </doc>
        </arg>
        <arg name="thresh" default="0.5">
            <doc>
                Control signal amplitude threshold, which determines the break point between slopeBelow
                and slopeAbove. Usually 0..1. The control signal amplitude is calculated using RMS.
            </doc>
        </arg>
        <arg name="ratioBelow" default="1.0">
            <doc>
                Slope of the amplitude curve below the threshold. If this slope &gt; 1.0, the amplitude
                will drop off more quickly the softer the control signal gets; when the control signal is close to 0
                amplitude, the output should be exactly zero -- hence, noise gating. Values &lt; 1.0 are possible,
                but it means that a very low-level control signal will cause the input signal to be amplified,
                which would raise the noise floor.
            </doc>
        </arg>
        <arg name="ratioAbove" default="1.0">
            <doc>
                Slope of the amplitude curve above the threshold. Values &lt; 1.0 achieve compression
                (louder signals are attenuated); &gt; 1.0, you get expansion (louder signals are made even louder).
                For 3:1 compression, you would use a value of 1/3 here.
            </doc>
        </arg>
        <arg name="attack" default="0.01">
            <doc>
                The amount of time it takes for the amplitude adjustment to kick in fully. This is
                usually pretty small, not much more than 10 milliseconds (the default value). I often set it as low as
                2 milliseconds (0.002).
            </doc>
        </arg>
        <arg name="release" default="0.1">
            <doc>
                The amount of time for the amplitude adjustment to be released. Usually a bit longer
                than attack; if both times are too short, you can get some (possibly unwanted) artifacts.
            </doc>
        </arg>
        <doc>
            <text>
                A compressor, expander, limiter, gate and ducking UGen. This dynamic processor uses a
                hard-knee characteristic. All of the thresholds and ratios are given as direct
                values, not in decibels!
            </text>
            <see>ugen.Limiter</see>
            <see>ugen.Normalizer</see>
        </doc>
    </ugen>
    <ugen name="Limiter">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in">
            <doc>
                input signal to be limited
            </doc>
        </arg>
        <arg name="level" default="1.0">
            <doc>
                maximum amplitude to which the signal is limited. The limiter will kick in
                when the input signal exceeds `+level` or falls below `-level`.
            </doc>
        </arg>
        <arg name="dur" default="0.01" init="true">
            <doc>
                look-ahead time in seconds
            </doc>
        </arg>
        <doc>
            <text>
                Limits the input amplitude to the given level. Unlike `Compander`, this UGen will never overshoot,
                but it needs to look ahead in the input signal, introducing a delay in its output.
                The delay time is equal to twice the value of the `dur` parameter (the buffer internally used).
            </text>
            <example name="compare dry and wet">
                val in = Decay2.ar(
                  Impulse.ar(8, phase = LFSaw.kr(0.25) * 0.7),
                  attack = 0.001, release = 0.3) * FSinOsc.ar(500)
                val flt = Limiter.ar(in, level = 0.4)
                LinXFade2.ar(in, flt, MouseButton.kr(-1, 1))
            </example>
            <see>ugen.Normalizer</see>
            <see>ugen.Compander</see>
        </doc>
    </ugen>
    <ugen name="Normalizer">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in">
            <doc>
                input signal to be normalized
            </doc>
        </arg>
        <arg name="level" default="1">
            <doc>
                peak output amplitude level to which to normalize the input
            </doc>
        </arg>
        <arg name="dur" default="0.01" init="true">
            <doc>
                look-ahead time in seconds. Shorter times will produce smaller delays and quicker
                transient response times, but may introduce amplitude modulation artifacts.
            </doc>
        </arg>
        <doc>
            <text>
                A UGen that normalizes the input amplitude to the given level.
                Unlike `Compander`, this UGen will not overshoot,
                but it needs to look ahead in the input signal, introducing a delay in its output.
                The delay time is equal to twice the value of the `dur` parameter (the buffer internally used).
            </text>
            <example name="compare dry and wet">
                val z    = Decay2.ar(
                  Impulse.ar(8, phase = LFSaw.kr(0.25) * 0.7),
                  attack = 0.001, release = 0.3) * FSinOsc.ar(500)
                val in  = z * SinOsc.ar(0.05) * 0.5
                val flt = Normalizer.ar(in, dur = 0.15, level = 0.4)
                LinXFade2.ar(in, flt, MouseButton.kr(-1, 1))
            </example>
            <see>ugen.Limiter</see>
            <see>ugen.Compander</see>
        </doc>
    </ugen>

    <ugen name="Amplitude">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be analyzed
            </doc>
        </arg>
        <arg name="attack" default="0.01">
            <doc>
                60 dB convergence time in for following attacks, in seconds
            </doc>
        </arg>
        <arg name="release" default="0.01">
            <doc>
                60 dB convergence time in for following decays, in seconds
            </doc>
        </arg>
        <doc>
            <text>
                An amplitude follower UGen. Tracks and reports the peak amplitude of its input signal.
            </text>
            <example name="use sound-card input to control pulse amplitude">
                // use headphones to prevent feedback!
                Pulse.ar(90, 0.3) * Amplitude.kr(PhysicalIn.ar(0))
            </example>
            <example name="compare with known amplitude">
                val amp = MouseX.kr
                val in  = PinkNoise.ar(amp)
                val ana = Amplitude.kr(amp, attack = 2, release = 2)
                (ana - amp).poll(2, "discrepancy")
                in
            </example>
            <see>ugen.DetectSilence</see>
        </doc>
    </ugen>
    <ugen name="DetectSilence" side-effect="true">   <!-- has done action, but does not set done flag -->
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be measured.
            </doc>
        </arg>
        <arg name="amp" default="0.0001" init="true">
            <doc>
                minimum amplitude threshold which must be exceeded for the input signal
                to be considered non-silent.
            </doc>
        </arg>
        <arg name="dur" default="0.1" init="true">
            <doc>
                The duration in seconds for which the input signal must be continuously smaller than or equal
                to the threshold to be considered silent.
            </doc>
        </arg>
        <arg name="doneAction" default="doNothing">
            <doc>
                an action to be performed when the output changes from zero to one (silence detected).
            </doc>
        </arg>
        <doc>
            <text>
                A UGen which detects whether its input signal falls below a given amplitude for a given amount
                of time (becoming "silent"). A silence is detected if the absolute sample values of the input
                remain less than or equal to the `amp` threshold for a consecutive amount of time given by the
                `dur` argument.

                A value of `1` is output when this condition is met, and a value of `0` is output when the
                condition is not met (i.e. at least one sample occurs in the input whose absolute value is
                greater than `amp`). Besides, when the output changes from zero to one, the `doneAction` is
                executed (unless it is `doNothing`).

                A special case is the initial condition of the UGen: It will begin with an output value of `0`
                (no silence detected), even if the input signal is below the amplitude threshold. It is only
                after the first input sample rising above the threshold that the actual monitoring begins and
                a trigger of `1` or the firing of the done-action may occur.
            </text>
            <see>ugen.Amplitude</see>
        </doc>
    </ugen>

    <ugen name="Hilbert">
        <output name="real"/>
        <output name="imag"/>
        <rate name="audio"/>
        <arg name="in">
            <doc>
                input signal to be processed
            </doc>
        </arg>
        <doc>
            <text>
                A Hilbert transform UGen. This transformation produces two signals from a given input with
                identical frequency content, but with their respective phases shifted to be 90 degrees apart
                (0.5 pi radians).

                The two signals output by `Hilbert` correspond to the real and imaginary part of the complex
                transformed signal. Due to the method used (an IIR filter), distortion occurs in the upper octave
                of the frequency spectrum.

                The transform can be used to implemented single-side-band (SSB) modulation, but a dedicated
                UGen `FreqShift` is already provided for this case.
            </text>
            <example name="a form of envelope tracking">
                val in = SinOsc.ar(440)
                val h  = Hilbert.ar(in)
                val x  = h.real.squared + h.imag.squared
                x.poll(1)  // cos(x)^2 + sin(x)^2 == 1 (ideally)
                0
            </example>
            <see>ugen.FreqShift</see>
        </doc>
    </ugen>
    <ugen name="FreqShift">
        <rate name="audio"/>
        <arg name="in"/>
        <arg name="freq" default="0.0">
            <doc>
                the shift amount in Hertz. Positive values shift upwards, negative values shift downwards.
            </doc>
        </arg>
        <arg name="phase" default="0.0"><!-- XXX TODO - what is this for? -->
            <doc>
                a phase parameter in radians (0 to 2 Pi).
            </doc>
        </arg>
        <doc>
            <text>
                A frequency shifting UGen. It implements single sideband (SSB) amplitude modulation, also known
                as frequency shifting, but not to be confused with pitch shifting. Frequency shifting moves all
                the components of a signal by a fixed amount but does not preserve the original harmonic
                relationships.
            </text>
            <example name="shift a sine frequency from 200 to 700 Hz">
                val freq = Line.ar(0, 500, 5)
                FreqShift.ar(SinOsc.ar(200) * 0.25, freq)
            </example>
            <example name="negative frequency to shift downwards">
                val freq = Line.ar(0, -500, 5)
                FreqShift.ar(SinOsc.ar(700) * 0.25, freq)
            </example>
            <see>ugen.Hilbert</see>
            <see>ugen.PV_MagShift</see>
        </doc>
    </ugen>
    <ugen name="MoogFF">
        <rate name="control"/>
        <rate name="audio"/>
        <arg name="in" rate="ugen"/>
        <arg name="freq" default="200.0">
            <doc>
                cutoff frequency in Hertz
            </doc>
        </arg>
        <arg name="gain" default="2.0">
            <doc>
                filter resonance gain, between 0 and 4
            </doc>
        </arg>
        <arg name="reset" default="closed">    <!-- strangely not a trigger, but a gate -->
            <doc>
                when greater than zero, this will reset the state of the digital filters at the beginning
                of the next control block.
            </doc>
        </arg>
        <doc>
            <text>
                A Moog VCF style UGen. This is a type of resonant low pass filter.

                The design of this filter is described in Federico Fontana, "Preserving the Digital Structure
                of the Moog VCF." In: Proceedings of the ICMC, Copenhagen 2007. Ported to SuperCollider by
                Dan Stowell.
            </text>
            <example name="mouse controlled">
                val in   = WhiteNoise.ar(01.1)
                val freq = MouseY.kr(100, 10000, 1)
                val gain = MouseX.kr(0, 4)
                Limiter.ar(MoogFF.ar(in, freq, gain))
            </example>
        </doc>
    </ugen>

    <ugen name="BLowPass">
        <rate name="audio" implied="true"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be processed.
            </doc>
        </arg>
        <arg name="freq" default="500.0">
            <doc>
                cutoff frequency.
            </doc>
        </arg>
        <arg name="rq" default="1.0">
            <doc>
                the reciprocal of Q, hence bandwidth / cutoffFreq.
            </doc>
        </arg>
        <doc>
            <text>
                A 2nd order (12db per oct roll-off) resonant low pass filter UGen.
                The B equalization suite is based on the Second Order Section (SOS) biquad UGen.

                Note: Biquad coefficient calculations imply certain amount of CPU overhead. These
                plugin UGens contain optimizations such that the coefficients get updated only when
                there has been a change to one of the filter's parameters. This can cause spikes in
                CPU performance and should be considered when using several of these units.
            </text>
        </doc>
    </ugen>
    <ugen name="BHiPass">
        <rate name="audio" implied="true"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be processed.
            </doc>
        </arg>
        <arg name="freq" default="500.0">
            <doc>
                cutoff frequency.
            </doc>
        </arg>
        <arg name="rq" default="1.0">
            <doc>
                the reciprocal of Q, hence bandwidth / cutoffFreq.
            </doc>
        </arg>
        <doc>
            <text>
                A 2nd order (12db per oct roll-off) resonant high pass filter UGen.
                The B equalization suite is based on the Second Order Section (SOS) biquad UGen.

                Note: Biquad coefficient calculations imply certain amount of CPU overhead. These
                plugin UGens contain optimizations such that the coefficients get updated only when
                there has been a change to one of the filter's parameters. This can cause spikes in
                CPU performance and should be considered when using several of these units.
            </text>
        </doc>
    </ugen>
    <ugen name="BBandPass">
        <rate name="audio" implied="true"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be processed.
            </doc>
        </arg>
        <arg name="freq" default="500.0">
            <doc>
                center frequency.
            </doc>
        </arg>
        <arg name="bw" default="1.0">
            <doc>
                the bandwidth '''in octaves''' between -3 dB frequencies
            </doc>
        </arg>
        <doc>
            <text>
                An band pass filter UGen.
                The B equalization suite is based on the Second Order Section (SOS) biquad UGen.

                Note: Biquad coefficient calculations imply certain amount of CPU overhead. These
                plugin UGens contain optimizations such that the coefficients get updated only when
                there has been a change to one of the filter's parameters. This can cause spikes in
                CPU performance and should be considered when using several of these units.
            </text>
        </doc>
    </ugen>
    <ugen name="BBandStop">
        <rate name="audio" implied="true"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be processed.
            </doc>
        </arg>
        <arg name="freq" default="500.0">
            <doc>
                center frequency.
            </doc>
        </arg>
        <arg name="bw" default="1.0">
            <doc>
                the bandwidth '''in octaves''' between -3 dB frequencies
            </doc>
        </arg>
        <doc>
            <text>
                An band stop (reject) filter UGen.
                The B equalization suite is based on the Second Order Section (SOS) biquad UGen.

                Note: Biquad coefficient calculations imply certain amount of CPU overhead. These
                plugin UGens contain optimizations such that the coefficients get updated only when
                there has been a change to one of the filter's parameters. This can cause spikes in
                CPU performance and should be considered when using several of these units.
            </text>
        </doc>
    </ugen>
    <ugen name="BPeakEQ">
        <rate name="audio" implied="true"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be processed.
            </doc>
        </arg>
        <arg name="freq" default="500.0">
            <doc>
                center frequency.
            </doc>
        </arg>
        <arg name="rq" default="1.0">
            <doc>
                the reciprocal of Q, hence bandwidth / cutoffFreq.
            </doc>
        </arg>
        <arg name="gain" default="0.0">
            <doc>
                boost/cut at the center frequency (in decibels).
            </doc>
        </arg>
        <doc>
            <text>
                An parametric equalizer UGen.
                The B equalization suite is based on the Second Order Section (SOS) biquad UGen.

                Note: Biquad coefficient calculations imply certain amount of CPU overhead. These
                plugin UGens contain optimizations such that the coefficients get updated only when
                there has been a change to one of the filter's parameters. This can cause spikes in
                CPU performance and should be considered when using several of these units.
            </text>
        </doc>
    </ugen>
    <ugen name="BAllPass">
        <rate name="audio" implied="true"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be processed.
            </doc>
        </arg>
        <arg name="freq" default="500.0">
            <doc>
                cutoff frequency.
            </doc>
        </arg>
        <arg name="rq" default="1.0">
            <doc>
                the reciprocal of Q, hence bandwidth / cutoffFreq.
            </doc>
        </arg>
        <doc>
            <text>
                An all pass filter UGen.
                The B equalization suite is based on the Second Order Section (SOS) biquad UGen.

                Note: Biquad coefficient calculations imply certain amount of CPU overhead. These
                plugin UGens contain optimizations such that the coefficients get updated only when
                there has been a change to one of the filter's parameters. This can cause spikes in
                CPU performance and should be considered when using several of these units.
            </text>
        </doc>
    </ugen>
    <ugen name="BLowShelf">
        <rate name="audio" implied="true"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be processed.
            </doc>
        </arg>
        <arg name="freq" default="500.0">
            <doc>
                cutoff frequency.
            </doc>
        </arg>
        <arg name="rs" default="1.0">
            <doc>
                the reciprocal of the slope S (Shell boost/cut slope).
                When `S = 1`, the shelf slope is as steep as it can be and remain monotonically increasing
                or decreasing gain with frequency.  The shelf slope, in dB/octave, remains proportional to
                S for all other values for a fixed freq/sample-rate and `gain`.
            </doc>
        </arg>
        <arg name="gain" default="0.0">
            <doc>
                boost/cut at the cutoff frequency (in decibels).
            </doc>
        </arg>
        <doc>
            <text>
                A low shelf equalizer UGen.
                The B equalization suite is based on the Second Order Section (SOS) biquad UGen.

                Note: Biquad coefficient calculations imply certain amount of CPU overhead. These
                plugin UGens contain optimizations such that the coefficients get updated only when
                there has been a change to one of the filter's parameters. This can cause spikes in
                CPU performance and should be considered when using several of these units.
            </text>
        </doc>
    </ugen>
    <ugen name="BHiShelf">
        <rate name="audio" implied="true"/>
        <arg name="in" rate="ugen">
            <doc>
                input signal to be processed.
            </doc>
        </arg>
        <arg name="freq" default="500.0">
            <doc>
                cutoff frequency.
            </doc>
        </arg>
        <arg name="rs" default="1.0">
            <doc>
                the reciprocal of the slope S (Shell boost/cut slope).
                When `S = 1`, the shelf slope is as steep as it can be and remain monotonically increasing
                or decreasing gain with frequency.  The shelf slope, in dB/octave, remains proportional to
                S for all other values for a fixed freq/sample-rate and `gain`.
            </doc>
        </arg>
        <arg name="gain" default="0.0">
            <doc>
                boost/cut at the cutoff frequency (in decibels).
            </doc>
        </arg>
        <doc>
            <text>
                A high shelf equalizer UGen.
                The B equalization suite is based on the Second Order Section (SOS) biquad UGen.

                Note: Biquad coefficient calculations imply certain amount of CPU overhead. These
                plugin UGens contain optimizations such that the coefficients get updated only when
                there has been a change to one of the filter's parameters. This can cause spikes in
                CPU performance and should be considered when using several of these units.
            </text>
        </doc>
    </ugen>
</ugens>