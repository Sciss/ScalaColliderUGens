<ugens revision="5">
    <!-- all documented -->
    <ugen name="ControlRate">
        <rate name="scalar" implied="true"/>    <!-- method="" -->
        <doc>
            <text>
                A UGen that reports the server's current control rate. This is equivalent to the reciprocal
                of `ControlDur`
            </text>
            <example name="print the control rate">
                ControlRate.ir.poll(0)
            </example>
            <example name="play a sine tone at control rate">
                SinOsc.ar(ControlRate.ir) * 0.1
            </example>
            <see>ugen.ControlDur</see>
            <see>ugen.SampleRate</see>
        </doc>
    </ugen>
    <ugen name="SampleRate">
        <rate name="scalar" implied="true"/>    <!-- method="" -->
        <doc>
            <text>
                A UGen that reports the server's current (audio) sample rate. This is equivalent to the reciprocal
                of `SampleDur`
            </text>
            <example name="print the sample rate">
                SampleRate.ir.poll(0)
            </example>
            <example name="use a fraction as oscillator frequency">
                val div    = MouseX.kr(512, 2, 1, 0).roundTo(1)
                val change = HPZ1.kr(div).abs
                val freq   = SampleRate.ir / div
                freq.poll(change, label = "freq")
                SinOsc.ar(freq) * 0.1
            </example>
            <see>ugen.SampleDur</see>
            <see>ugen.ControlRate</see>
            <see>ugen.RadiansPerSample</see>
        </doc>
    </ugen>
    <ugen name="SampleDur">
        <rate name="scalar" implied="true"/>     <!-- method="" -->
        <doc>
            <text>
                A UGen that reports the server's current (audio) sample period in seconds.
                This is equivalent to the reciprocal of `SampleRate`
            </text>
            <example name="print the sample period">
                SampleDur.ir.poll(0)
            </example>
            <see>ugen.SampleRate</see>
            <see>ugen.ControlDur</see>
        </doc>
    </ugen>
    <ugen name="ControlDur">
        <rate name="scalar" implied="true"/>     <!-- method="" -->
        <doc>
            <text>
                A UGen that reports the server's current control period in seconds.
                This is equivalent to the reciprocal of `ControlRate`
            </text>
            <example name="print the control period">
                ControlDur.ir.poll(0)
            </example>
            <see>ugen.ControlRate</see>
            <see>ugen.SampleDur</see>
        </doc>
    </ugen>
    <ugen name="SubsampleOffset">
        <rate name="scalar" implied="true"/>     <!-- method="" -->
        <doc>
            <text>
                A UGen that reports the fractional sample offset of the current Synth from its requested
                scheduled start.

                When a synth is created from a time stamped osc-bundle, it starts
                calculation at the next possible block (normally 64 samples). Using an
                `OffsetOut` UGen, one can delay the audio so that it matches sample
                accurately.

                For some synthesis methods, one even needs subsample accuracy. `SubsampleOffset`
                provides the information where, within the current sample, the synth was
                scheduled. It can be used to offset envelopes or resample the audio
                output.
            </text>
            <!-- TODO: example -->
            <see>ugen.ControlRate</see>
            <see>ugen.SampleDur</see>
            <see>ugen.OffsetOut</see>
        </doc>
    </ugen>
    <ugen name="RadiansPerSample">
        <rate name="scalar" implied="true"/>     <!-- method="" -->
        <doc>
            <text>
                A UGen that delivers the conversion factor from frequency in Hertz to radians (normalized frequency).
                The relation is `RadiansPerSample * sr = 2pi`, thus multiplying the UGen with a frequency between
                zero and nyquist (sr/2) yields the normalized frequency between zero and pi.
            </text>
            <example name="print the UGen value">
                RadiansPerSample.ir.poll(0)
            </example>
            <see>ugen.SampleRate</see>
        </doc>
    </ugen>
    <ugen name="NumInputBuses">
        <rate name="scalar" implied="true"/>     <!-- method="" -->
        <doc>
            <text>Number of input buses.</text>
            <example name="print the UGen value">
                NumInputBuses.ir.poll(0)
            </example>
            <see>ugen.NumAudioBuses</see>
            <see>ugen.NumControlBuses</see>
            <see>ugen.NumBuffers</see>
            <see>ugen.NumOutputBuses</see>
            <see>ugen.NumRunningSynths</see>
        </doc>
    </ugen>
    <ugen name="NumOutputBuses">
        <rate name="scalar" implied="true"/>     <!-- method="" -->
        <doc>
            <text>Number of output buses.</text>
            <example name="print the UGen value">
                NumOutputBuses.ir.poll(0)
            </example>
            <see>ugen.NumAudioBuses</see>
            <see>ugen.NumControlBuses</see>
            <see>ugen.NumBuffers</see>
            <see>ugen.NumInputBuses</see>
            <see>ugen.NumRunningSynths</see>
        </doc>
    </ugen>
    <ugen name="NumAudioBuses">
        <rate name="scalar" implied="true"/>     <!-- method="" -->
        <doc>
            <text>Number of audio buses.</text>
            <example name="print the UGen value">
                NumAudioBuses.ir.poll(0)
            </example>
            <see>ugen.NumControlBuses</see>
            <see>ugen.NumBuffers</see>
            <see>ugen.NumInputBuses</see>
            <see>ugen.NumOutputBuses</see>
            <see>ugen.NumRunningSynths</see>
        </doc>
    </ugen>
    <ugen name="NumControlBuses">
        <rate name="scalar" implied="true"/>     <!-- method="" -->
        <doc>
            <text>Number of control buses.</text>
            <example name="print the UGen value">
                NumControlBuses.ir.poll(0)
            </example>
            <see>ugen.NumAudioBuses</see>
            <see>ugen.NumBuffers</see>
            <see>ugen.NumInputBuses</see>
            <see>ugen.NumOutputBuses</see>
            <see>ugen.NumRunningSynths</see>
        </doc>
    </ugen>
    <ugen name="NumBuffers">
        <rate name="scalar" implied="true"/>     <!-- method="" -->
        <doc>
            <text>Maximum number of audio buffers.</text>
            <example name="print the UGen value">
                NumBuffers.ir.poll(0)
            </example>
            <see>ugen.NumAudioBuses</see>
            <see>ugen.NumControlBuses</see>
            <see>ugen.NumInputBuses</see>
            <see>ugen.NumOutputBuses</see>
            <see>ugen.NumRunningSynths</see>
        </doc>
    </ugen>
    <ugen name="NumRunningSynths">
        <rate name="scalar" implied="true"/>     <!-- method="" -->
        <doc>
            <text>Number of currently running synths.</text>
            <example name="print the UGen value">
                NumRunningSynths.ir.poll(0)
            </example>
            <see>ugen.NumAudioBuses</see>
            <see>ugen.NumControlBuses</see>
            <see>ugen.NumBuffers</see>
            <see>ugen.NumInputBuses</see>
            <see>ugen.NumOutputBuses</see>
        </doc>
    </ugen>

    <ugen name="BufSampleRate">
        <rate name="scalar"/>
        <doc>
            <text>
                Returns the buffer's current sample rate.
            </text>
            <!-- TODO: example -->
        </doc>
        <rate name="control"/>
        <doc>
            <text>
                Returns the buffer's current sample rate.
            </text>
        </doc>
        <arg name="buf" type="buf">
            <doc>
                Buffer id.
            </doc>
        </arg>
    </ugen>
    <ugen name="BufRateScale">
        <rate name="control"/>
        <rate name="scalar"/>
        <doc>
            <text>
                Returns a ratio by which the playback of the buffer at the provided index is to be scaled relative to
                the current sample rate of the server.
                {{{
                buffer sample rate / server sample rate
                }}}
            </text>
            <!-- TODO: example -->
        </doc>
        <arg name="buf" type="buf">
            <doc>
                Buffer id.
            </doc>
        </arg>
    </ugen>
    <ugen name="BufSamples">
        <rate name="control"/>
        <rate name="scalar"/>
        <doc>
            <text>
                Returns the current number of allocated samples in the Buffer at the provided index.
                A sample is not the same as a frame (compare with [[ugen.BufFrames]] ); a frame includes
                the samples in each channel of the buffer. Only for a mono buffer are samples the same as frames.
                {{{
                samples = frames * numChannels
                }}}
            </text>
            <!-- TODO: example -->
        </doc>
        <arg name="buf" type="buf">
            <doc>
                Buffer id.
            </doc>
        </arg>
    </ugen>
    <ugen name="BufFrames">
        <rate name="control"/>
        <rate name="scalar"/>
        <doc>
            <text>
                Returns the number of allocated frames of the buffer at the provided index.
            </text>
            <!-- TODO: example -->
        </doc>
        <arg name="buf" type="buf">
            <doc>
                Buffer id.
            </doc>
        </arg>
    </ugen>
    <ugen name="BufChannels">
        <rate name="control"/>
        <rate name="scalar"/>
        <doc>
            <text>
                Returns the current number of channels of the buffer at the provided index.
            </text>
            <!-- TODO: example -->
        </doc>
        <arg name="buf" type="buf">
            <doc>
                Buffer id.
            </doc>
        </arg>
    </ugen>
    <ugen name="BufDur">
        <rate name="control"/>
        <rate name="scalar"/>
        <doc>
            <text>
                Returns the current duration of the buffer at the provided index.
            </text>
            <!-- TODO: example -->
        </doc>
        <arg name="buf" type="buf">
            <doc>
                Buffer id.
            </doc>
        </arg>
    </ugen>

    <ugen name="PlayBuf" reads-buf="true" side-effect="true" done-flag="true">
        <rate name="control"/>
        <rate name="audio"/>
        <output variadic="numChannels"/>
        <arg name="numChannels" type="int">
            <doc>
                the number of channels that the buffer will be. Since
                this is a constant, a change in number of channels of the underlying bus must
                be reflected by creating different SynthDefs. If a buffer identifier is used of a buffer
                that has a different numChannels then specified in the PlayBuf, it will fail silently.
            </doc>
        </arg>
        <arg name="buf" type="buf">
            <doc>
                the identifier of the buffer to use
            </doc>
        </arg>
        <arg name="speed" default="1.0">
            <doc>
                1 advances the play head by the server's sample rate each second.
                So 2 means doubling speed (and pitch), and 0.5 means half speed (and half pitch).
                Negative numbers can be used for backwards playback. If the underlying buffer
                represents a sound at a different sample rate, the rate should be
                multiplied by `BufRateScale.kr(bufID)` to obtain the correct speed.
            </doc>
        </arg>
        <arg name="trig" default="high">
            <doc>
                a trigger which causes a jump to the given `offset`. A trigger occurs when a
                signal changes from non-positive to positive (e.g. &lt;= 0 to &gt; 0).
            </doc>
        </arg>
        <arg name="offset" default="0.0">
            <doc>
                sample frame to start playback. This is read when a trigger occurs. It may be fractional.
            </doc>
        </arg>
        <arg name="loop" default="true">
            <doc>
                1 to loop after the play head reaches the buffer end, 0 to not loop. This can be modulated.
            </doc>
        </arg>
        <arg name="doneAction" default="doNothing">
            <doc>
                what to do when the play head reaches the buffer end. This is only effective when `loop` is zero.
            </doc>
        </arg>
        <doc>
            <text>
                A UGen to play back samples from a buffer in memory.

                `PlayBuf` provides a kind of high-level interface to sample-playback, whereas `BufRd`
                represents a kind of lower-level access. While `BufRd` has a random-access-pointer
                in the form of a phase input, `PlayBuf` advances the phase automatically based on
                a given playback speed. `PlayBuf` uses cubic interpolation.
            </text>
            <!-- TODO: example -->
            <see>ugen.BufRd</see>
            <see>ugen.DiskIn</see>
            <see>ugen.RecordBuf</see>
            <see>DoneAction</see>
            <see>ugen.Done</see>
            <see>ugen.BufRateScale</see>
            <see>ugen.BufFrames</see>
        </doc>
    </ugen>
    <ugen name="RecordBuf" writes-buf="true" side-effect="true" done-flag="true">
        <rate name="audio"/>
        <rate name="control"/>
        <doc>
            <text>
                Records input into a Buffer.
                If recLevel is 1.0 and preLevel is 0.0 then the new input overwrites the old data.
                If they are both 1.0 then the new data is added to the existing data.
                (Any other settings are also valid.)
            </text>
            <example name="record and replay" type="full">
                // a four second mono buffer
                val b = Buffer.alloc(s, s.sampleRate.toInt * 4)

                // record for four seconds
                play {
                  val sig = Formant.ar(XLine.kr(400, 1000, 4), 2000, 800) * 0.125
                  RecordBuf.ar(sig, b.id, doneAction = freeSelf, loop = 0)
                }

                // play it back
                play {
                  PlayBuf.ar(1, b.id, doneAction = freeSelf, loop = 0)
                }
            </example>
            <see>ugen.BufWr</see>
            <see>ugen.DiskOut</see>
            <see>ugen.PlayBuf</see>
            <see>DoneAction</see>
            <see>ugen.Done</see>
            <see>ugen.BufRateScale</see>
            <see>ugen.BufFrames</see>
        </doc>
        <arg name="buf" type="buf" pos="1">
            <doc>
                the identifier of the buffer to use
            </doc>
        </arg>
        <arg name="offset" default="0" pos="2">
            <doc>
                sample frame to begin writing from. This is read when a trigger occurs.
            </doc>
        </arg>
        <arg name="recLevel" default="1.0" pos="3">
            <doc>
                value to multiply by input before mixing with existing data.
            </doc>
        </arg>
        <arg name="preLevel" default="0.0" pos="4">
            <doc>
                value by which the previous buffer contents is multiplied when recording. If this value is zero,
                the buffer contents is completely overwritten. If this value is one, the new signal is added
                to the previous content.
            </doc>
        </arg>
        <arg name="run" default="open" pos="5">
            <doc>
                if zero the recording pauses, otherwise it resumes. The value of run is only read at control-rate!
                When the recording is paused, the "write-head" remains in its current position and does not advance.
            </doc>
        </arg>
        <arg name="loop" default="true" pos="6">
            <doc>
                1 to loop after the write head reaches the buffer end, 0 to not loop. This can be modulated.
            </doc>
        </arg>
        <arg name="trig" default="high" pos="7">
            <doc>
                a trigger which causes a jump to the given `offset`. A trigger occurs when a
                signal changes from non-positive to positive (e.g. &lt;= 0 to &gt; 0).
            </doc>
        </arg>
        <arg name="doneAction" default="doNothing" pos="8">
            <doc>
                what to do when the write head reaches the buffer end. This is only effective when `loop` is zero.
            </doc>
        </arg>
        <arg name="in" variadic="true" pos="0">
            <doc>
                the signal to record
            </doc>
        </arg>
    </ugen>
    <ugen name="BufRd" reads-buf="true" done-flag="true">
        <rate name="scalar"/>
        <rate name="control"/>
        <rate name="audio">
            <arg name="index" rate="ugen"/>
        </rate>
        <output variadic="numChannels"/>
        <arg name="numChannels" type="int">
            <doc>
                number of channels that the buffer will be.
                Since this is an integer constant, a change in the number of channels must
                be reflected by creating different SynthDefs.
            </doc>
        </arg>
        <arg name="buf" type="buf">
            <doc>
                the identifier of the buffer to use
            </doc>
        </arg>
        <arg name="index" default="0.0">
            <doc>
                audio rate frame-index into the buffer. Can be fractional.
            </doc>
        </arg>
        <arg name="loop" default="true">
            <doc>
                1 to enable looping, 0 to disable looping. this can be modulated.
            </doc>
        </arg>
        <arg name="interp" default="2">
            <doc>
                1 for no interpolation, 2 for linear, and 4 for cubic interpolation
            </doc>
        </arg>
        <doc>
            <text>
                A UGen which reads the content of a buffer, using an index pointer.

                Warning: if the supplied `bufID` refers to a buffer whose number of channels
                differs from `numChannels`, the UGen will fail silently.

                An alternative to `BufRd` is `PlayBuf`. While `PlayBuf` plays
                through the buffer by itself, `BufRd` only moves its read point by the index input
                and therefore has no pitch input. `PlayBuf` uses cubic interpolation, while
                `BufRd` has variable interpolation. `PlayBuf` can determine the end of the buffer
                and issue a done-action.
            </text>
            <example name="Write and read" type="full">
                val b = Buffer.alloc(s, numFrames = 32768, numChannels = 1)

                // write into the buffer with a BufWr
                val y = play {
                  val in = SinOsc.ar(LFNoise1.kr(2).madd(300, 400)) * 0.1
                  val rate = "rate" kr 1
                  BufWr.ar(in, b.id, Phasor.ar(0, BufRateScale.kr(b.id) * rate, 0, BufFrames.kr(b.id)))
                  0.0 // quiet
                }

                // read it with a BufRd
                val x = play {
                  val rate = "rate" kr 1
                  BufRd.ar(1, b.id, Phasor.ar(0, BufRateScale.kr(b.id) * rate, 0, BufFrames.kr(b.id)))
                }

                y.set("rate" -> 0.5) // notice the clicks when the play head overtakes the write head!
                x.set("rate" -> 0.5)
                y.set("rate" -> 1.0)
            </example>
            <see>ugen.PlayBuf</see>
            <see>ugen.BufWr</see>
            <see>ugen.Phasor</see>
            <see>ugen.BufFrames</see>
            <see>ugen.BufRateScale</see>
        </doc>
    </ugen>
    <ugen name="BufWr" writes-buf="true" done-flag="true">
        <rate name="scalar"/>
        <rate name="control"/>
        <rate name="audio">
            <arg name="index" rate="ugen"/>
        </rate>
        <arg name="buf" type="buf" pos="1">
            <doc>
                the identifier of the buffer to use
            </doc>
        </arg>
        <arg name="index" default="0.0" pos="2">
            <doc>
                audio rate frame-index into the buffer.
            </doc>
        </arg>
        <arg name="loop" default="true" pos="3">
            <doc>
                1 to enable looping, 0 to disable looping. this can be modulated.
            </doc>
        </arg>
        <arg name="in" variadic="true" pos="0">
            <doc>
                input signal to record
            </doc>
        </arg>
        <doc>
            <text>
                A UGen that writes a signal to a buffer, using an index pointer.

                Warning: if the supplied `bufID` refers to a buffer whose number of channels
                differs from those of the input signal, the UGen will fail silently.

                An alternative to `BufWr` is `RecordBuf`. While `RecordBuf` advances
                the index into the buffer by itself, `BufWr` only moves its write point by the index input,
                making it possible to adjust the writing speed or to access the buffer in a non-linear way.
                `RecordBuf` can determine the end of the buffer and issue a done-action.
            </text>
            <example name="record and playback" type="full">
                // a two second mono buffer
                val b = Buffer.alloc(s, numFrames = s.sampleRate.toInt * 2)

                val y = play {
                  val sig  = SinOsc.ar(LFNoise1.kr(2).madd(300, 400)) * 0.1
                  val rate = "rate" kr 1
                  BufWr.ar(in = sig, buf = b.id, index =
                    Phasor.ar(speed = BufRateScale.kr(b.id) * rate, lo = 0, hi = BufFrames.kr(b.id)))
                  0.0 // quiet
                }

                // read it with a BufRd
                val x = play {
                  val rate = "rate" kr 1
                  BufRd.ar(1, buf = b.id, index =
                    Phasor.ar(speed = BufRateScale.kr(b.id) * rate, lo = 0, hi = BufFrames.kr(b.id)))
                }

                x.set("rate" -> 5)
                y.set("rate" -> 3)
                x.set("rate" -> 2)
            </example>
            <see>ugen.RecordBuf</see>
            <see>ugen.BufRd</see>
            <see>ugen.Phasor</see>
            <see>ugen.BufFrames</see>
            <see>ugen.BufRateScale</see>
        </doc>
    </ugen>
    <ugen name="Pitch">
        <rate name="control"/>
        <output name="freq"/>
        <output name="hasFreq"/>
        <arg name="in">
            <doc>
                The signal to be analyzed.
            </doc>
        </arg>
        <arg name="initFreq" default="440.0" init="true">
            <doc>
                The initial value of the `freq` output, until the first valid pitch is found.
            </doc>
        </arg>
        <arg name="minFreq" default="60.0" init="true">
            <doc>
                The minimum frequency in Hertz to be considered for reporting.
            </doc>
        </arg>
        <arg name="maxFreq" default="4000.0" init="true">
            <doc>
                The maximum frequency in Hertz to be considered for reporting.
            </doc>
        </arg>
        <arg name="execFreq" default="100.0" init="true">
            <doc>
                The frequency at which the pitch is estimated. This will be
                automatically clipped to be between `minFreq` and `maxFreq`.
            </doc>
        </arg>
        <arg name="binsPerOct" default="16" init="true">
            <doc>
                A value which guides the search for the peak frequency in the first
                coarse step. Its setting does *not* affect the final pitch resolution;
                setting it larger will cause the coarse search to take longer, and setting
                it smaller will cause the fine search to take longer.
            </doc>
        </arg>
        <arg name="median" default="1" init="true">
            <doc>
                This specifies the length of a median filter applied to the frequency output
                estimation. With the default value of `1` the filter is defeated. Median filtering
                can help eliminating single spikes and jitter. This will however add latency to
                the output.
            </doc>
        </arg>
        <arg name="ampThresh" default="0.01" init="true">
            <doc>
                The minimum amplitude threshold above which the pitch follower
                operates. An input signal below this threshold is not analyzed.
            </doc>
        </arg>
        <arg name="peakThresh" default="0.5" init="true">
            <doc>
                This is a threshold used to find the first peak in the autocorrelation signal which
                gives the reported frequency. It is a factor of the energy of the signal
                (autocorrelation coefficient at zero). Set this value higher (e.g. to `1`) to
                eliminate false frequencies corresponding to overtones.
            </doc>
        </arg>
        <arg name="downSample" default="1" init="true">
            <doc>
                An integer factor by which the input signal is down sampled to reduce CPU overhead.
                This will also reduce the pitch resolution. The default value of `1` means that
                the input signal is not down sampled.
            </doc>
        </arg>
        <!-- this should be a switch, but the implementation uses > 0.f -->
        <!-- nevertheless, we'll present it as switch in the interface, that should be ok -->
        <arg name="clarity" default="false" init="true">
            <doc>
                If the `clarity` argument is greater than zero (it is zero by default) then the `hasFreq`
                output is given additional detail. Rather than simply being 1 when a pitch is detected,
                it is a "clarity" measure in the range between zero and one. (Technically, it's the height
                of the autocorrelation peak normalised by the height of the zero-lag peak.) It therefore
                gives a kind of measure of "purity" of the pitched signal.
            </doc>
        </arg>
        <doc>
            <text>
                An autocorrelation based pitch following UGen. It is more accurate than `ZeroCrossing`, but
                more also more CPU costly. For most purposes the default settings can be used and only `in`
                needs to be supplied.

                The UGen has two outputs: The first output is the frequency estimate in Hertz, the second
                output is a toggle `hasFreq`, which tells whether a pitch was found (1) or not (0). If
                the `clarify` argument is used, `hasFreq` has more fine grained information.

                The pitch follower executes periodically at the rate specified by `execFreq` in cps.
                First it detects whether the input peak to peak amplitude is above the `ampThresh`.
                If it is not then no pitch estimation is performed, the `hasFreq` output is set to zero
                and the `freq` output is held at its previous value. Otherwise, the autocorrelation is
                calculated, and the first peak after the peak around the lag of zero that is
                above `peakThresh` times the amplitude of the peak at lag zero is reported.
            </text>
            <example name="pitch-follower resynthesizing with saw tooth">
                // be careful and use headphones!
                val in      = Mix(PhysicalIn.ar(0, 2))
                val amp     = Amplitude.kr(in, 0.05, 0.05)
                val p       = Pitch.kr(in, ampThresh = 0.02, median = 7)
                val saw     = Mix(VarSaw.ar(p.freq * Seq(0.5, 1, 2), 0, LFNoise1.kr(0.3,0.1,0.1)) * amp)
                Mix.fold(saw, 6) { res =>
                  AllpassN.ar(res, 0.040, Rand(0, 0.040), Rand(0, 0.040), 2)
                }
            </example>
        </doc>
    </ugen>

    <ugen name="BufDelayN" reads-buf="true" writes-buf="true">
        <rate name="control"/>
        <rate name="audio">
            <arg name="in" rate="ugen"/>
        </rate>
        <arg name="buf" type="buf">
            <doc>
                Buffer id.
            </doc>
        </arg>
        <arg name="in">
            <doc>
                The input signal.
            </doc>
        </arg>
        <arg name="delayTime" default="0.2">
            <doc>
                Delay time in seconds.
            </doc>
        </arg>
        <doc>
            <text>
                Simple delay line with no interpolation which uses a buffer for its internal memory.

                __Warning__: For reasons of efficiency, the effective buffer size is the allocated size
                rounded down to the next power of two. For example, if 44100 samples are allocated, the maximum
                delay would be 32768 samples. Also note that the buffer must be monophonic.
            </text>
            <example name="Random white-noise decay" type="full">
                // allocate buffer
                val b = Buffer.alloc(s, (0.2 * s.sampleRate).toInt.nextPowerOfTwo, 1)

                // Dust randomly triggers Decay to create an exponential
                // decay envelope for the WhiteNoise input source.
                // We apply a slight filter to the delayed signal
                // so it is easier to distinguish
                play {
                  val z = Decay.ar(Dust.ar(1) * 0.5, 0.3) * WhiteNoise.ar
                  LPF.ar(BufDelayN.ar(b.id, z, 0.2), 8000) + z  // input is mixed with delay
                }

                b.free()  // do this after the synth has ended
            </example>
            <see>ugen.BufDelayL</see>
            <see>ugen.BufDelayC</see>
        </doc>
    </ugen>
    <ugen name="BufDelayL" reads-buf="true" writes-buf="true">
        <rate name="control"/>
        <rate name="audio">
            <arg name="in" rate="ugen"/>
        </rate>
        <arg name="buf" type="buf">
            <doc>
                Buffer id.
            </doc>
        </arg>
        <arg name="in">
            <doc>
                The input signal.
            </doc>
        </arg>
        <arg name="delayTime" default="0.2">
            <doc>
                Delay time in seconds.
            </doc>
        </arg>
        <doc>
            <text>
                Simple delay line with linear interpolation which uses a buffer for its internal memory.

                __Warning__: For reasons of efficiency, the effective buffer size is the allocated size
                rounded down to the next power of two. For example, if 44100 samples are allocated, the maximum
                delay would be 32768 samples. Also note that the buffer must be monophonic.
            </text>
            <!-- TODO: example -->
            <see>ugen.BufDelayN</see>
            <see>ugen.BufDelayC</see>
        </doc>
    </ugen>
    <ugen name="BufDelayC" reads-buf="true" writes-buf="true">
        <rate name="control"/>
        <rate name="audio">
            <arg name="in" rate="ugen"/>
        </rate>
        <arg name="buf" type="buf">
            <doc>
                Buffer id.
            </doc>
        </arg>
        <arg name="in">
            <doc>
                The input signal.
            </doc>
        </arg>
        <arg name="delayTime" default="0.2">
            <doc>
                Delay time in seconds.
            </doc>
        </arg>
        <doc>
            <text>
                Simple delay line with cubic interpolation which uses a buffer for its internal memory.

                __Warning__: For reasons of efficiency, the effective buffer size is the allocated size
                rounded down to the next power of two. For example, if 44100 samples are allocated, the maximum
                delay would be 32768 samples. Also note that the buffer must be monophonic.
            </text>
            <!-- TODO: example -->
            <see>ugen.BufDelayN</see>
            <see>ugen.BufDelayL</see>
        </doc>
    </ugen>
    <ugen name="BufCombN" reads-buf="true" writes-buf="true">
        <rate name="audio">
            <arg name="in" rate="ugen"/>
        </rate>
        <arg name="buf" type="buf">
            <doc>
                Buffer id.
            </doc>
        </arg>
        <arg name="in">
            <doc>
                The input signal.
            </doc>
        </arg>
        <arg name="delayTime" default="0.2">
            <doc>
                Delay time in seconds.
            </doc>
        </arg>
        <arg name="decayTime" default="1.0">
            <doc>
                Time for the echoes to decay by 60 decibels. If this time is negative then the feedback
                coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.
            </doc>
        </arg>
        <doc>
            <text>
                Comb delay line with no interpolation which uses a buffer for its internal memory.

                __Warning__: For reasons of efficiency, the effective buffer size is the allocated size
                rounded down to the next power of two. For example, if 44100 samples are allocated, the maximum
                delay would be 32768 samples. Also note that the buffer must be monophonic.
            </text>
            <example name="Compare interpolation" type="full">
                // These examples compare the variants, so that you can hear the difference in interpolation

                // allocate buffer
                val b = Buffer.alloc(s, (0.01 * s.sampleRate).toInt.nextPowerOfTwo)

                // Comb used as a resonator. The resonant fundamental is equal to
                // reciprocal of the delay time.
                play { BufCombN.ar(b.id, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), 0.2) }

                play { BufCombL.ar(b.id, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), 0.2) }

                play { BufCombC.ar(b.id, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), 0.2) }

                // with negative feedback
                play { BufCombN.ar(b.id, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), -0.2) }

                play { BufCombL.ar(b.id, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), -0.2) }

                play { BufCombC.ar(b.id, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), -0.2) }

                b.free()   // do this after the synths have ended
            </example>
            <example name="Used as an echo" type="full">
                val b = Buffer.alloc(s, (0.2 * s.sampleRate).toInt.nextPowerOfTwo)

                play { BufCombN.ar(b.id, Decay.ar(Dust.ar(1) * 0.5, 0.2) * WhiteNoise.ar, 0.2, 3) }

                b.free()   // do this after the synth has ended
            </example>
            <see>ugen.BufCombL</see>
            <see>ugen.BufCombC</see>
        </doc>
    </ugen>
    <ugen name="BufCombL" reads-buf="true" writes-buf="true">
        <rate name="audio">
            <arg name="in" rate="ugen"/>
        </rate>
        <arg name="buf" type="buf">
            <doc>
                Buffer id.
            </doc>
        </arg>
        <arg name="in">
            <doc>
                The input signal.
            </doc>
        </arg>
        <arg name="delayTime" default="0.2">
            <doc>
                Delay time in seconds.
            </doc>
        </arg>
        <arg name="decayTime" default="1.0">
            <doc>
                Time for the echoes to decay by 60 decibels. If this time is negative then the feedback
                coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.

                __Warning__: For reasons of efficiency, the effective buffer size is the allocated size
                rounded down to the next power of two. For example, if 44100 samples are allocated, the maximum
                delay would be 32768 samples. Also note that the buffer must be monophonic.
            </doc>
        </arg>
        <doc>
            <text>
                Comb delay line with linear interpolation which uses a buffer for its internal memory.
            </text>
            <example name="Compare interpolation" type="full">
                // These examples compare the variants, so that you can hear the difference in interpolation

                // allocate buffer
                val b = Buffer.alloc(s, (0.01 * s.sampleRate).toInt.nextPowerOfTwo)

                // Comb used as a resonator. The resonant fundamental is equal to
                // reciprocal of the delay time.
                play { BufCombN.ar(b.id, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), 0.2) }

                play { BufCombL.ar(b.id, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), 0.2) }

                play { BufCombC.ar(b.id, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), 0.2) }

                // with negative feedback
                play { BufCombN.ar(b.id, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), -0.2) }

                play { BufCombL.ar(b.id, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), -0.2) }

                play { BufCombC.ar(b.id, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), -0.2) }

                b.free()   // do this after the synths have ended
            </example>
            <see>ugen.BufCombN</see>
            <see>ugen.BufCombC</see>
        </doc>
    </ugen>
    <ugen name="BufCombC" reads-buf="true" writes-buf="true">
        <rate name="audio">
            <arg name="in" rate="ugen"/>
        </rate>
        <arg name="buf" type="buf">
            <doc>
                Buffer id.
            </doc>
        </arg>
        <arg name="in">
            <doc>
                The input signal.
            </doc>
        </arg>
        <arg name="delayTime" default="0.2">
            <doc>
                Delay time in seconds.
            </doc>
        </arg>
        <arg name="decayTime" default="1.0">
            <doc>
                Time for the echoes to decay by 60 decibels. If this time is negative then the feedback
                coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.

                __Warning__: For reasons of efficiency, the effective buffer size is the allocated size
                rounded down to the next power of two. For example, if 44100 samples are allocated, the maximum
                delay would be 32768 samples. Also note that the buffer must be monophonic.
            </doc>
        </arg>
        <doc>
            <text>
                Comb delay line with cubic interpolation which uses a buffer for its internal memory.
            </text>
            <example name="Compare interpolation" type="full">
                // These examples compare the variants, so that you can hear the difference in interpolation

                // allocate buffer
                val b = Buffer.alloc(s, (0.01 * s.sampleRate).toInt.nextPowerOfTwo)

                // Comb used as a resonator. The resonant fundamental is equal to
                // reciprocal of the delay time.
                play { BufCombN.ar(b.id, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), 0.2) }

                play { BufCombL.ar(b.id, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), 0.2) }

                play { BufCombC.ar(b.id, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), 0.2) }

                // with negative feedback
                play { BufCombN.ar(b.id, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), -0.2) }

                play { BufCombL.ar(b.id, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), -0.2) }

                play { BufCombC.ar(b.id, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), -0.2) }

                b.free()   // do this after the synths have ended
            </example>
            <see>ugen.BufCombN</see>
            <see>ugen.BufCombL</see>
        </doc>
    </ugen>
    <ugen name="BufAllpassN" reads-buf="true" writes-buf="true">
        <rate name="audio">
            <arg name="in" rate="ugen"/>
        </rate>
        <arg name="buf" type="buf">
            <doc>
                Buffer id.
            </doc>
        </arg>
        <arg name="in">
            <doc>
                The input signal.
            </doc>
        </arg>
        <arg name="delayTime" default="0.2">
            <doc>
                Delay time in seconds.
            </doc>
        </arg>
        <arg name="decayTime" default="1.0">
            <doc>
                Time for the echoes to decay by 60 decibels. If this time is negative then the feedback
                coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.
            </doc>
        </arg>
        <doc>
            <text>
                All pass delay line with no interpolation which uses a buffer for its internal memory.

                __Warning__: For reasons of efficiency, the effective buffer size is the allocated size
                rounded down to the next power of two. For example, if 44100 samples are allocated, the maximum
                delay would be 32768 samples. Also note that the buffer must be monophonic.
            </text>
            <example name="Compare interpolation types" type="full">
                // allocate buffer
                val b = Buffer.alloc(s, (0.2 * s.sampleRate).toInt.nextPowerOfTwo)

                // Since the allpass delay has no audible effect as a resonator on
                // steady state sound ...
                play { BufAllpassC.ar(b.id, WhiteNoise.ar(0.1), XLine.kr(0.0001, 0.01, 20), 0.2) }

                // ...these examples add the input to the effected sound and compare variants so that you can hear
                // the effect of the phase comb:
                play {
                  val z = WhiteNoise.ar(0.2)
                  z + BufAllpassN.ar(b.id, z, XLine.kr(0.0001, 0.01, 20), 0.2)
                }

                play {
                  val z = WhiteNoise.ar(0.2)
                  z + BufAllpassL.ar(b.id, z, XLine.kr(0.0001, 0.01, 20), 0.2)
                }

                play {
                  val z = WhiteNoise.ar(0.2)
                  z + BufAllpassC.ar(b.id, z, XLine.kr(0.0001, 0.01, 20), 0.2)
                }

                b.free()  // after synths have been stopped
            </example>
            <example name="Used as echo" type="full">
                val b = Buffer.alloc(s, (0.2 * s.sampleRate).toInt.nextPowerOfTwo)

                // doesn't really sound different than Comb,
                // but it outputs the input signal immediately (inverted) and the echoes
                // are lower in amplitude.
                play { BufAllpassN.ar(b.id, Decay.ar(Dust.ar(1) * 0.5, 0.2) * WhiteNoise.ar, 0.2, 3) }

                b.free()
            </example>
            <see>ugen.BufAllpassL</see>
            <see>ugen.BufAllpassC</see>
        </doc>
    </ugen>
    <ugen name="BufAllpassL" reads-buf="true" writes-buf="true">
        <rate name="audio">
            <arg name="in" rate="ugen"/>
        </rate>
        <arg name="buf" type="buf">
            <doc>
                Buffer id.
            </doc>
        </arg>
        <arg name="in">
            <doc>
                The input signal.
            </doc>
        </arg>
        <arg name="delayTime" default="0.2">
            <doc>
                Delay time in seconds.
            </doc>
        </arg>
        <arg name="decayTime" default="1.0">
            <doc>
                Time for the echoes to decay by 60 decibels. If this time is negative then the feedback
                coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.
            </doc>
        </arg>
        <doc>
            <text>
                All pass delay line with linear interpolation which uses a buffer for its internal memory.

                __Warning__: For reasons of efficiency, the effective buffer size is the allocated size
                rounded down to the next power of two. For example, if 44100 samples are allocated, the maximum
                delay would be 32768 samples. Also note that the buffer must be monophonic.
            </text>
            <example name="Compare interpolation types" type="full">
                // allocate buffer
                val b = Buffer.alloc(s, (0.2 * s.sampleRate).toInt.nextPowerOfTwo)

                // Since the allpass delay has no audible effect as a resonator on
                // steady state sound ...
                play { BufAllpassC.ar(b.id, WhiteNoise.ar(0.1), XLine.kr(0.0001, 0.01, 20), 0.2) }

                // ...these examples add the input to the effected sound and compare variants so that you can hear
                // the effect of the phase comb:
                play {
                  val z = WhiteNoise.ar(0.2)
                  z + BufAllpassN.ar(b.id, z, XLine.kr(0.0001, 0.01, 20), 0.2)
                }

                play {
                  val z = WhiteNoise.ar(0.2)
                  z + BufAllpassL.ar(b.id, z, XLine.kr(0.0001, 0.01, 20), 0.2)
                }

                play {
                  val z = WhiteNoise.ar(0.2)
                  z + BufAllpassC.ar(b.id, z, XLine.kr(0.0001, 0.01, 20), 0.2)
                }

                b.free()  // after synths have been stopped
            </example>
            <see>ugen.BufAllpassN</see>
            <see>ugen.BufAllpassC</see>
        </doc>
    </ugen>
    <ugen name="BufAllpassC" reads-buf="true" writes-buf="true">
        <rate name="audio">
            <arg name="in" rate="ugen"/>
        </rate>
        <arg name="buf" type="buf">
            <doc>
                Buffer id.
            </doc>
        </arg>
        <arg name="in">
            <doc>
                The input signal.
            </doc>
        </arg>
        <arg name="delayTime" default="0.2">
            <doc>
                Delay time in seconds.
            </doc>
        </arg>
        <arg name="decayTime" default="1.0">
            <doc>
                Time for the echoes to decay by 60 decibels. If this time is negative then the feedback
                coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.
            </doc>
        </arg>
        <doc>
            <text>
                All pass delay line with cubic interpolation which uses a buffer for its internal memory.

                __Warning__: For reasons of efficiency, the effective buffer size is the allocated size
                rounded down to the next power of two. For example, if 44100 samples are allocated, the maximum
                delay would be 32768 samples. Also note that the buffer must be monophonic.
            </text>
            <example name="Compare interpolation types" type="full">
                // allocate buffer
                val b = Buffer.alloc(s, (0.2 * s.sampleRate).toInt.nextPowerOfTwo)

                // Since the allpass delay has no audible effect as a resonator on
                // steady state sound ...
                play { BufAllpassC.ar(b.id, WhiteNoise.ar(0.1), XLine.kr(0.0001, 0.01, 20), 0.2) }

                // ...these examples add the input to the effected sound and compare variants so that you can hear
                // the effect of the phase comb:
                play {
                  val z = WhiteNoise.ar(0.2)
                  z + BufAllpassN.ar(b.id, z, XLine.kr(0.0001, 0.01, 20), 0.2)
                }

                play {
                  val z = WhiteNoise.ar(0.2)
                  z + BufAllpassL.ar(b.id, z, XLine.kr(0.0001, 0.01, 20), 0.2)
                }

                play {
                  val z = WhiteNoise.ar(0.2)
                  z + BufAllpassC.ar(b.id, z, XLine.kr(0.0001, 0.01, 20), 0.2)
                }

                b.free()  // after synths have been stopped
            </example>
            <see>ugen.BufAllpassN</see>
            <see>ugen.BufAllpassL</see>
        </doc>
    </ugen>
    <ugen name="DelayN">
        <rate name="control"/>
        <rate name="audio">
            <arg name="in" rate="ugen"/>
        </rate>
        <arg name="in">
            <doc>
                The input signal.
            </doc>
        </arg>
        <arg name="maxDelayTime" default="0.2" init="true">
            <doc>
                The maximum delay time in seconds. used to initialize the delay buffer size.
            </doc>
        </arg>
        <arg name="delayTime" default="0.2">
            <doc>
                Delay time in seconds.
            </doc>
        </arg>
        <doc>
            <text>
                Simple delay line with no interpolation.
            </text>
            <example name="Delayed random pulses">
                // Dust randomly triggers Decay to create an exponential
                // decay envelope for the WhiteNoise input source
                val z = Decay.ar(Dust.ar(2) * 0.5, 0.3) * WhiteNoise.ar
                DelayN.ar(z, 0.2, 0.2) + z  // input is mixed with delay via the add input
            </example>
            <example name="Recursive application">
                val z = Decay2.ar(Dust.ar(1) * 0.5, 0.01, 0.1) * Saw.ar(Seq(100, 101)) * 0.5
                (z /: (0 until 5)) { (zi, i) =>
                  DelayN.ar(RLPF.ar(zi, Rand(100, 3000), 0.03), 1, 1.0 / (2 &lt;&lt; i)) + zi * 0.5
                }
            </example>
            <see>ugen.DelayL</see>
            <see>ugen.DelayC</see>
        </doc>
    </ugen>
    <ugen name="DelayL">
        <rate name="control"/>
        <rate name="audio">
            <arg name="in" rate="ugen"/>
        </rate>
        <arg name="in">
            <doc>
                The input signal.
            </doc>
        </arg>
        <arg name="maxDelayTime" default="0.2" init="true">
            <doc>
                The maximum delay time in seconds. used to initialize the delay buffer size.
            </doc>
        </arg>
        <arg name="delayTime" default="0.2">
            <doc>
                Delay time in seconds.
            </doc>
        </arg>
        <doc>
            <text>
                Simple delay line with linear interpolation.
            </text>
            <!-- TODO: example -->
            <see>ugen.DelayN</see>
            <see>ugen.DelayC</see>
        </doc>
    </ugen>
    <ugen name="DelayC">
        <rate name="control"/>
        <rate name="audio">
            <arg name="in" rate="ugen"/>
        </rate>
        <arg name="in">
            <doc>
                The input signal.
            </doc>
        </arg>
        <arg name="maxDelayTime" default="0.2" init="true">
            <doc>
                The maximum delay time in seconds. used to initialize the delay buffer size.
            </doc>
        </arg>
        <arg name="delayTime" default="0.2">
            <doc>
                Delay time in seconds.
            </doc>
        </arg>
        <doc>
            <text>
                Simple delay line with cubic interpolation.
            </text>
            <!-- TODO: example -->
            <see>ugen.DelayN</see>
            <see>ugen.DelayL</see>
        </doc>
    </ugen>
    <ugen name="CombN">
        <rate name="control"/>
        <rate name="audio">
            <arg name="in" rate="ugen"/>
        </rate>
        <arg name="in">
            <doc>
                The input signal.
            </doc>
        </arg>
        <arg name="maxDelayTime" default="0.2" init="true">
            <doc>
                The maximum delay time in seconds. used to initialize the delay buffer size.
            </doc>
        </arg>
        <arg name="delayTime" default="0.2">
            <doc>
                Delay time in seconds.
            </doc>
        </arg>
        <arg name="decayTime" default="1.0">
            <doc>
                Time for the echoes to decay by 60 decibels. If this time is negative then the feedback
                coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.
            </doc>
        </arg>
        <doc>
            <text>
                Comb delay line with no interpolation.
            </text>
            <see>ugen.CombL</see>
            <see>ugen.CombC</see>
        </doc>
    </ugen>
    <ugen name="CombL">
        <rate name="control"/>
        <rate name="audio">
            <arg name="in" rate="ugen"/>
        </rate>
        <arg name="in">
            <doc>
                The input signal.
            </doc>
        </arg>
        <arg name="maxDelayTime" default="0.2" init="true">
            <doc>
                The maximum delay time in seconds. used to initialize the delay buffer size.
            </doc>
        </arg>
        <arg name="delayTime" default="0.2">
            <doc>
                Delay time in seconds.
            </doc>
        </arg>
        <arg name="decayTime" default="1.0">
            <doc>
                Time for the echoes to decay by 60 decibels. If this time is negative then the feedback
                coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.
            </doc>
        </arg>
        <doc>
            <text>
                Comb delay line with linear interpolation.
            </text>
            <see>ugen.CombN</see>
            <see>ugen.CombC</see>
        </doc>
    </ugen>
    <ugen name="CombC">
        <rate name="control"/>
        <rate name="audio">
            <arg name="in" rate="ugen"/>
        </rate>
        <arg name="in">
            <doc>
                The input signal.
            </doc>
        </arg>
        <arg name="maxDelayTime" default="0.2" init="true">
            <doc>
                The maximum delay time in seconds. used to initialize the delay buffer size.
            </doc>
        </arg>
        <arg name="delayTime" default="0.2">
            <doc>
                Delay time in seconds.
            </doc>
        </arg>
        <arg name="decayTime" default="1.0">
            <doc>
                Time for the echoes to decay by 60 decibels. If this time is negative then the feedback
                coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.
            </doc>
        </arg>
        <doc>
            <text>
                Comb delay line with cubic interpolation.
            </text>
            <see>ugen.CombN</see>
            <see>ugen.CombL</see>
        </doc>
    </ugen>
    <ugen name="AllpassN">
        <rate name="control"/>
        <rate name="audio">
            <arg name="in" rate="ugen"/>
        </rate>
        <arg name="in">
            <doc>
                The input signal.
            </doc>
        </arg>
        <arg name="maxDelayTime" default="0.2" init="true">
            <doc>
                The maximum delay time in seconds. used to initialize the delay buffer size.
            </doc>
        </arg>
        <arg name="delayTime" default="0.2">
            <doc>
                Delay time in seconds.
            </doc>
        </arg>
        <arg name="decayTime" default="1.0">
            <doc>
                Time for the echoes to decay by 60 decibels. If this time is negative then the feedback
                coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.
            </doc>
        </arg>
        <doc>
            <text>
                All pass delay line with no interpolation.
            </text>
            <see>ugen.AllpassL</see>
            <see>ugen.AllpassC</see>
        </doc>
    </ugen>
    <ugen name="AllpassL">
        <rate name="control"/>
        <rate name="audio">
            <arg name="in" rate="ugen"/>
        </rate>
        <arg name="in">
            <doc>
                The input signal.
            </doc>
        </arg>
        <arg name="maxDelayTime" default="0.2" init="true">
            <doc>
                The maximum delay time in seconds. used to initialize the delay buffer size.
            </doc>
        </arg>
        <arg name="delayTime" default="0.2">
            <doc>
                Delay time in seconds.
            </doc>
        </arg>
        <arg name="decayTime" default="1.0">
            <doc>
                Time for the echoes to decay by 60 decibels. If this time is negative then the feedback
                coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.
            </doc>
        </arg>
        <doc>
            <text>
                All pass delay line with linear interpolation.
            </text>
            <see>ugen.AllpassN</see>
            <see>ugen.AllpassC</see>
        </doc>
    </ugen>
    <ugen name="AllpassC">
        <rate name="control"/>
        <rate name="audio">
            <arg name="in" rate="ugen"/>
        </rate>
        <arg name="in">
            <doc>
                The input signal.
            </doc>
        </arg>
        <arg name="maxDelayTime" default="0.2" init="true">
            <doc>
                The maximum delay time in seconds. used to initialize the delay buffer size.
            </doc>
        </arg>
        <arg name="delayTime" default="0.2">
            <doc>
                Delay time in seconds.
            </doc>
        </arg>
        <arg name="decayTime" default="1.0">
            <doc>
                Time for the echoes to decay by 60 decibels. If this time is negative then the feedback
                coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.
            </doc>
        </arg>
        <doc>
            <text>
                All pass delay line with cubic interpolation.
            </text>
            <see>ugen.AllpassN</see>
            <see>ugen.AllpassL</see>
        </doc>
    </ugen>
    <ugen name="PitchShift">
        <rate name="audio" implied="true"/>
        <arg name="in">
            <doc>
                The input signal.
            </doc>
        </arg>
        <arg name="winSize" default="0.2" init="true">
            <doc>
                The size of the grain window in seconds.
            </doc>
        </arg>
        <arg name="pitchRatio" default="1.0">
            <doc>
                The ratio of the pitch shift. Must be from 0 to 4.
            </doc>
        </arg>
        <arg name="pitchDispersion" default="0.0">
            <doc>
                The maximum random deviation of the pitch from the pitchRatio.
            </doc>
        </arg>
        <arg name="timeDispersion" default="0.0">
            <doc>
                A random offset of from zero to timeDispersion seconds is added to the delay of each grain.
                Use of some dispersion can alleviate a hard comb filter effect due to uniform grain placement.
                It can also be an effect in itself. timeDispersion can be no larger than windowSize.
            </doc>
        </arg>
        <doc>
            <text>
                A time domain granular pitch shifter. Grains have a triangular amplitude
                envelope and an overlap of 4:1.
            </text>
        </doc>
    </ugen>
    <!-- this should exist according to plugin sources...
    <ugen name="GrainTap"/>
    -->
    <ugen name="TGrains" reads-buf="true">  <!-- accepts demand rate -->
        <rate name="audio" implied="true"/>
        <output variadic="numChannels"/>
        <arg name="numChannels" type="int">
            <doc>
                Number of output channels.
            </doc>
        </arg>
        <arg name="trig" type="trig">
            <doc>
                At each trigger, the following arguments are sampled and used as the arguments of a new grain.
                A trigger occurs when a signal changes from non-positive to positive value.
                If the trigger is audio rate then the grains will start with sample accuracy.
            </doc>
        </arg>
        <arg name="buf" type="buf">
            <doc>
                The buffer index. It must be a one channel (mono) buffer.
            </doc>
        </arg>
        <arg name="speed" default="1.0">
            <doc>
                1.0 is normal, 2.0 is one octave up, 0.5 is one octave down -1.0 is backwards normal rate etc.
            </doc>
        </arg>
        <arg name="centerPos" default="0.0">
            <doc>
                The position in the buffer in seconds at which the grain envelope will reach maximum amplitude.
            </doc>
        </arg>
        <arg name="dur" default="0.1">
            <doc>
                Duration of the grain in seconds.
            </doc>
        </arg>
        <arg name="pan" default="0.0">
            <doc>
                A value from -1 to 1. Determines where to pan the output in the same manner as [[ugen.PanAz]].
            </doc>
        </arg>
        <arg name="amp" default="0.1">
            <doc>
                Amplitude of the grain.
            </doc>
        </arg>
        <arg name="interp" default="4">
            <doc>
                1, 2, or 4. Determines whether the grain uses (1) no interpolation, (2) linear interpolation,
                or (4) cubic interpolation.
            </doc>
        </arg>
        <doc>
            <text>
                Triggers generate grains from a buffer. Each grain has a Hanning envelope
                {{{
                (sin2(x) for x from 0 to pi)
                }}}
                and is panned between two channels of multiple outputs.

                '''Warning''': Due to a bug (SC 3.6.6), this UGen does not work with `LocalBuf` but requires
                a regular buffer.
            </text>
            <see>ugen.GrainBuf</see>
        </doc>
    </ugen>
    <ugen name="ScopeOut" writes-buf="true">
        <no-outputs/>   <!-- XXX zero outputs? -->
        <rate name="audio"/>
        <rate name="control"/>
        <arg name="buf" type="buf"/>
        <arg name="in" variadic="true"/>
    </ugen>
    <ugen name="ScopeOut2" writes-buf="true">
        <no-outputs/>   <!-- XXX zero outputs? -->
        <rate name="audio"/>
        <rate name="control"/>
        <arg name="buf" type="buf" pos="0"/>
        <arg name="maxFrames" default="4096" init="true" pos="2"/>
        <arg name="frames" pos="3"/>
        <arg name="in" variadic="true" pos="1"/>
    </ugen>
    <ugen name="Pluck">
        <rate name="audio" implied="true"/>
        <arg name="in">
            <doc>
                An excitation signal.
            </doc>
        </arg>
        <arg name="trig" default="high">
            <doc>
                Upon a negative to positive transition, the excitation signal will be fed into the delay line.
            </doc>
        </arg>
        <arg name="maxDelayTime" default="0.2" init="true">
            <doc>
                Maximum delay time in seconds (initializes the internal delay buffer).
            </doc>
        </arg>
        <arg name="delayTime" default="0.2">
            <doc>
                Delay time in seconds.
            </doc>
        </arg>
        <arg name="decayTime" default="1.0">
            <doc>
                Time for the echoes to decay by 60 decibels. Negative times emphasize odd partials.
            </doc>
        </arg>
        <arg name="coeff" default="0.5">
            <doc>
                the coefficient of the internal OnePole filter. Values should be between -1 and +1
                (larger values will be unstable... so be careful!).
            </doc>
        </arg>
        <doc>
            <text>
                A Karplus-Strong UGen.
            </text>
        </doc>
    </ugen>
    <ugen name="DelTapWr" writes-buf="true">
        <rate name="audio"/>
        <rate name="control"/>
        <arg name="buf" type="buf">
            <doc>
                The buffer to write signal into. Max delay time is based on buffer size.

                `DelTapWr` outputs its current sample value for use in the `phase`
                argument of `DelTapRd`.
            </doc>
        </arg>
        <arg name="in">
            <doc>
                The input signal.
            </doc>
        </arg>
        <doc>
            <text>
                Write to a buffer for a `DelTapRd` UGen
            </text>
            <see>ugen.DelTapRd</see>
        </doc>
    </ugen>
    <ugen name="DelTapRd" reads-buf="true">
        <rate name="audio"/>
        <rate name="control"/>
        <arg name="buf" type="buf">
            <doc>
                Buffer where DelTapWr has written signal. Max delay time is based on buffer size.
            </doc>
        </arg>
        <arg name="phase">
            <doc>
                the current phase of the DelTapWr UGen. This is the output of DelTapWr.
            </doc>
        </arg>
        <arg name="delayTime">
            <doc>
                Delay time in seconds.
            </doc>
        </arg>
        <arg name="interp" default="1">
            <doc>
                The kind of interpolation to be used. 1 is none, 2 is linear, 4 is cubic..
            </doc>
        </arg>
        <doc>
            <text>
                Tap a delay line from a `DelTapWr` UGen.
            </text>
            <see>ugen.DelTapWr</see>
        </doc>
    </ugen>

    <!-- <ugen name="MaxLocalBufs"/> -->
    <!-- <ugen name="LocalBuf"/> -->

    <!-- XXX TODO:
    <ugen name="SetBuf" writes-buf="true">
        NOTE: the multi arg is preceded by its size
        <rate name="scalar" implied="true"/>
        <arg name="buf">
            <doc>
                the buffer to write the values into
            </doc>
        </arg>
        <arg name="offset" default="0" pos="1">
            <doc>
                frame offset into the buffer
            </doc>
        </arg>
        <arg name="values" variadic="true" pos="0">
            <doc>
                values to write into the buffer
            </doc>
        </arg>
        <doc>
            <text>
                A scalar (init-time) UGen that overwrites contents of a buffer with given values.
            </text>
            <see>ugen.LocalBuf</see>
            <see>ugen.ClearBuf</see>
        </doc>
    </ugen>
    -->

    <ugen name="ClearBuf" writes-buf="true">
        <rate name="scalar" implied="true"/>
        <arg name="buf">
            <doc>
                the buffer to clear
            </doc>
        </arg>
        <doc>
            <text>
                A scalar (init-time) UGen that fills the contents of a buffer with zeroes.
            </text>
            <see>ugen.LocalBuf</see>
            <see>ugen.SetBuf</see>
        </doc>
    </ugen>
</ugens>