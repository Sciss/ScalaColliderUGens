WhiteNoise etc. --> mce
special input values: Poll, EnvGen, Klang, ...
output accessors for multi-output ugens, e.g. for Pitch
( default values: work around bug for float-literals )
doc comments
individuation

////////// 03-Jan

for one argument ugens:

   def expand = {
      val _bus = bus.expand
      val _sz_bus = _bus.size
      IIdxSeq.tabulate(_sz_bus_)(i => OutUGen(rate, _bus(i.%(_sz_bus)))
   }

should be simplified to

   def expand = {
      val _bus = bus.expand
      IIdxSeq.tabulate(_bus.size)(i => OutUGen(rate, _bus(i))
   }

this is by the way a bit faster than bus.expand.map( x => OutUGen( rate, x ))

///////

case class Done etc.: add "with ControlRated"
case class DiskIn etc.: extends Expands[] instead of GE[]

val _exp = max( ... ) --> maxInt
; optimierung: bei zwei argumenten einfach math.max nehmen

/////////////////

[OK] <arg rate="ugen"/>
[OK] <rate><arg name=... default=.../></rate>
[OK] <rate><arg name=... rate=.../></rate>
[OK] <doc warnpos="true"/>
[OK] <ugen random="true"/>
[OK] <rate method="apply"/>
[OK] <rate methodalias="apply"/>
<outputs num="in"/> // DC (currently commented out)
[OK] <ugen readsfft="true"/>
<arg ... expandbin="*"/>

///////// missing ugens?
DelayUGens : GrainTap
Filter: Flip
LFUGens: Unwrap
Osc: FoldIndex

/////

Combination MultiOut + HasDoneFlag (PlayBuf) : 
MultiOutUGen[ R <: Rate ]( ... ) extends UGen with GE[R, UGenIn[ R ]]{
--> benoetigen GE[R, UGenIn[ R ] with HasDoneFlag ]

/////

DemandUGens

//////

bufgen : env ??

/////////////// Noise / expandBin solution:

object WhiteNoise {
   def kr: WhiteNoise[control,scalar,control] = kr( )
   def kr[S <: Rate, T <: Rate](mul: GE[S, UGenIn[S]] = 1.0f)( implicit rateOrder: RateOrder[ control, S, T ]) = apply[control, S, T](rateOrder.out, mul)(rateOrder)
   def ar: WhiteNoise[audio,scalar,audio] = ar( )
   def ar[S <: Rate, T <: Rate](mul: GE[S, UGenIn[S]] = 1.0f)( implicit rateOrder: RateOrder[ audio, S, T ]) = apply[audio, S, T](rateOrder.out, mul)(rateOrder)
}
case class WhiteNoise[R <: Rate, S <: Rate, T <: Rate](rate: T, mul: GE[S, UGenIn[S]])(implicit rateOrder: RateOrder[ R, S, T ])
extends GE[T, UGenIn[T]] with UsesRandSeed {
   def expand = {
      val _mul: IIdxSeq[UGenIn[S]] = mul.expand
      IIdxSeq.tabulate(_mul.size)(i => BinaryOpUGen[T]( rateOrder.out, BinaryOp.Times, WhiteNoiseUGen(rateOrder.in1), _mul(i)))
   }
}
case class WhiteNoiseUGen[R <: Rate](rate: R) extends SingleOutUGen[R](IIdxSeq.empty) with UsesRandSeed

/////////////// EnvGen relaxation:

object EnvGen {
   def kr(envelope: Expands[MultiGE], gate: AnyGE = 1.0f, levelScale: AnyGE = 1.0f, levelBias: AnyGE = 0.0f, timeScale: AnyGE = 1.0f, doneAction: AnyGE = doNothing) = apply[control](control, envelope, gate, levelScale, levelBias, timeScale, doneAction)
   def ar(envelope: Expands[MultiGE], gate: AnyGE = 1.0f, levelScale: AnyGE = 1.0f, levelBias: AnyGE = 0.0f, timeScale: AnyGE = 1.0f, doneAction: AnyGE = doNothing) = apply[audio](audio, envelope, gate, levelScale, levelBias, timeScale, doneAction)
}
case class EnvGen[R <: Rate](rate: R, envelope: Expands[MultiGE], gate: AnyGE, levelScale: AnyGE, levelBias: AnyGE, timeScale: AnyGE, doneAction: AnyGE) extends GE[R, EnvGenUGen[R]] {
   def expand = {
      val _gate: IIdxSeq[AnyUGenIn] = gate.expand
      val _levelScale: IIdxSeq[AnyUGenIn] = levelScale.expand
      val _levelBias: IIdxSeq[AnyUGenIn] = levelBias.expand
      val _timeScale: IIdxSeq[AnyUGenIn] = timeScale.expand
      val _doneAction: IIdxSeq[AnyUGenIn] = doneAction.expand
      val _envelope: IIdxSeq[MultiGE] = envelope.expand
      val _sz_gate = _gate.size
      val _sz_levelScale = _levelScale.size
      val _sz_levelBias = _levelBias.size
      val _sz_timeScale = _timeScale.size
      val _sz_doneAction = _doneAction.size
      val _sz_envelope = _envelope.size
      val _exp_ = maxInt(_sz_gate, _sz_levelScale, _sz_levelBias, _sz_timeScale, _sz_doneAction, _sz_envelope)
      IIdxSeq.tabulate(_exp_)(i => EnvGenUGen(rate, _envelope(i.%(_sz_envelope)).expand, _gate(i.%(_sz_gate)), _levelScale(i.%(_sz_levelScale)), _levelBias(i.%(_sz_levelBias)), _timeScale(i.%(_sz_timeScale)), _doneAction(i.%(_sz_doneAction))))
   }
}
case class EnvGenUGen[R <: Rate](rate: R, envelope: IIdxSeq[AnyUGenIn], gate: AnyUGenIn, levelScale: AnyUGenIn, levelBias: AnyUGenIn, timeScale: AnyUGenIn, doneAction: AnyUGenIn) extends SingleOutUGen[R](IIdxSeq[AnyUGenIn](gate, levelScale, levelBias, timeScale, doneAction).++(envelope))
