<ugens> <!-- list as of 02-sep-10 -->
    <file name="ChaosUGens">
        <ugen name="CuspN">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="a" default="1"/>
            <arg name="b" default="1.9"/>
            <arg name="xi" default="0"/>
        </ugen>
        <ugen name="CuspL">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="a" default="1"/>
            <arg name="b" default="1.9"/>
            <arg name="xi" default="0"/>
        </ugen>
        <ugen name="FBSineN">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="im" default="1"/>
            <arg name="fb" default="0.1"/>
            <arg name="a" default="1.1"/>
            <arg name="c" default="0.5"/>
            <arg name="xi" default="0.1"/>
            <arg name="yi" default="0.1"/>
        </ugen>
        <ugen name="FBSineL">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="im" default="1"/>
            <arg name="fb" default="0.1"/>
            <arg name="a" default="1.1"/>
            <arg name="c" default="0.5"/>
            <arg name="xi" default="0.1"/>
            <arg name="yi" default="0.1"/>
        </ugen>
        <ugen name="FBSineC">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="im" default="1"/>
            <arg name="fb" default="0.1"/>
            <arg name="a" default="1.1"/>
            <arg name="c" default="0.5"/>
            <arg name="xi" default="0.1"/>
            <arg name="yi" default="0.1"/>
        </ugen>
        <ugen name="GbmanN">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="xi" default="1.2"/>
            <arg name="yi" default="2.1"/>
        </ugen>
        <ugen name="GbmanL">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="xi" default="1.2"/>
            <arg name="yi" default="2.1"/>
        </ugen>
        <ugen name="HenonN">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="a" default="1.4"/>
            <arg name="b" default="0.3"/>
            <arg name="x0" default="0"/>
            <arg name="x1" default="0"/>
        </ugen>
        <ugen name="HenonL">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="a" default="1.4"/>
            <arg name="b" default="0.3"/>
            <arg name="x0" default="0"/>
            <arg name="x1" default="0"/>
        </ugen>
        <ugen name="HenonC">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="a" default="1.4"/>
            <arg name="b" default="0.3"/>
            <arg name="x0" default="0"/>
            <arg name="x1" default="0"/>
        </ugen>
        <ugen name="LatoocarfianN">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="a" default="1"/>
            <arg name="b" default="3"/>
            <arg name="c" default="0.5"/>
            <arg name="d" default="0.5"/>
            <arg name="xi" default="0.5"/>
            <arg name="yi" default="0.5"/>
        </ugen>
        <ugen name="LatoocarfianL">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="a" default="1"/>
            <arg name="b" default="3"/>
            <arg name="c" default="0.5"/>
            <arg name="d" default="0.5"/>
            <arg name="xi" default="0.5"/>
            <arg name="yi" default="0.5"/>
        </ugen>
        <ugen name="LatoocarfianC">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="a" default="1"/>
            <arg name="b" default="3"/>
            <arg name="c" default="0.5"/>
            <arg name="d" default="0.5"/>
            <arg name="xi" default="0.5"/>
            <arg name="yi" default="0.5"/>
        </ugen>
        <ugen name="LinCongN">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="a" default="1.1"/>
            <arg name="c" default="0.13"/>
            <arg name="m" default="1.0"/>
            <arg name="xi" default="0"/>
        </ugen>
        <ugen name="LinCongL">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="a" default="1.1"/>
            <arg name="c" default="0.13"/>
            <arg name="m" default="1.0"/>
            <arg name="xi" default="0"/>
        </ugen>
        <ugen name="LinCongC">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="a" default="1.1"/>
            <arg name="c" default="0.13"/>
            <arg name="m" default="1.0"/>
            <arg name="xi" default="0"/>
        </ugen>
        <ugen name="LorenzL">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="s" default="10"/>
            <arg name="r" default="28"/>
            <arg name="b" default="2.667"/>
            <arg name="h" default="0.05"/>
            <arg name="xi" default="0.1"/>
            <arg name="yi" default="0"/>
            <arg name="zi" default="0"/>
        </ugen>
        <ugen name="QuadN">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="a" default="1"/>
            <arg name="b" default="-1"/>
            <arg name="c" default="-0.75"/>
            <arg name="xi" default="0"/>
        </ugen>
        <ugen name="QuadL">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="a" default="1"/>
            <arg name="b" default="-1"/>
            <arg name="c" default="-0.75"/>
            <arg name="xi" default="0"/>
        </ugen>
        <ugen name="QuadC">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="a" default="1"/>
            <arg name="b" default="-1"/>
            <arg name="c" default="-0.75"/>
            <arg name="xi" default="0"/>
        </ugen>
        <ugen name="StandardN">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="k" default="1.0"/>
            <arg name="xi" default="0.5"/>
            <arg name="yi" default="0"/>
        </ugen>
        <ugen name="StandardL">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="k" default="1.0"/>
            <arg name="xi" default="0.5"/>
            <arg name="yi" default="0"/>
        </ugen>
    </file>

    <file name="DelayUGens">
        <ugen name="ControlRate">
            <rate name="scalar" implied="true"/>
            <doc>
                <text>
                    A UGen that reports the server's current control rate. This is equivalent to the reciprocal
                    of `ControlDur`
                </text>
                <see>ugen.ControlDur</see>
                <see>ugen.SampleRate</see>
            </doc>
        </ugen>
        <ugen name="SampleRate">
            <rate name="scalar" implied="true"/>
            <doc>
                <text>
                    A UGen that reports the server's current (audio) sample rate. This is equivalent to the reciprocal
                    of `SampleDur`
                </text>
                <see>ugen.SampleDur</see>
                <see>ugen.ControlRate</see>
                <see>ugen.RadiansPerSample</see>
            </doc>
        </ugen>
        <ugen name="SampleDur">
            <rate name="scalar" implied="true"/>
            <doc>
                <text>
                    A UGen that reports the server's current (audio) sample period in seconds. This is equivalent to the reciprocal
                    of `SampleRate`
                </text>
                <see>ugen.SampleRate</see>
                <see>ugen.ControlDur</see>
            </doc>
        </ugen>
        <ugen name="ControlDur">
            <rate name="scalar" implied="true"/>
            <doc>
                <text>
                    A UGen that reports the server's current control period in seconds. This is equivalent to the reciprocal
                    of `ControlRate`
                </text>
                <see>ugen.ControlRate</see>
                <see>ugen.SampleDur</see>
            </doc>
        </ugen>
        <ugen name="SubsampleOffset">
            <rate name="scalar" implied="true"/>
            <doc>
                <text>
                    A UGen that reports the fractional sample offset of the current Synth from its requested scheduled start.

                    When a synth is created from a time stamped osc-bundle, it starts
                    calculation at the next possible block (normally 64 samples). Using an
                    `OffsetOut` UGen, one can delay the audio so that it matches sample
                    accurately.

                    For some synthesis methods, one even needs subsample accuracy. `SubsampleOffset`
                    provides the information where, within the current sample, the synth was
                    scheduled. It can be used to offset envelopes or resample the audio
                    output.
                </text>
                <see>ugen.ControlRate</see>
                <see>ugen.SampleDur</see>
            </doc>
        </ugen>
        <ugen name="RadiansPerSample">
            <rate name="scalar" implied="true"/>
            <doc>
                <text>
                    A UGen that delivers the conversion factor from frequency in Hertz to radians (normalized frequency).
                    The relation is `RadiansPerSample * sr = 2pi`, thus multiplying the UGen with a frequency between
                    zero and nyquist (sr/2) yields the normalized frequency between zero and pi.
                </text>
                <see>ugen.SampleRate</see>
            </doc>
        </ugen>
        <ugen name="NumInputBuses">
            <rate name="scalar" implied="true"/>
        </ugen>
        <ugen name="NumOutputBuses">
            <rate name="scalar" implied="true"/>
        </ugen>
        <ugen name="NumAudioBuses">
            <rate name="scalar" implied="true"/>
        </ugen>
        <ugen name="NumControlBuses">
            <rate name="scalar" implied="true"/>
        </ugen>
        <ugen name="NumBuffers">
            <rate name="scalar" implied="true"/>
        </ugen>
        <ugen name="NumRunningSynths">
            <rate name="scalar" implied="true"/>
        </ugen>

        <ugen name="BufSampleRate">
            <rate name="scalar"/>
            <rate name="control"/>
            <arg name="buf"/>
        </ugen>
        <ugen name="BufRateScale">
            <rate name="scalar"/>
            <rate name="control"/>
            <arg name="buf"/>
        </ugen>
        <ugen name="BufSamples">
            <rate name="scalar"/>
            <rate name="control"/>
            <arg name="buf"/>
        </ugen>
        <ugen name="BufFrames">
            <rate name="scalar"/>
            <rate name="control"/>
            <arg name="buf"/>
        </ugen>
        <ugen name="BufChannels">
            <rate name="scalar"/>
            <rate name="control"/>
            <arg name="buf"/>
        </ugen>
        <ugen name="BufDur">
            <rate name="scalar"/>
            <rate name="control"/>
            <arg name="buf"/>
        </ugen>

        <ugen name="PlayBuf" readsbuf="true" sideeffect="true" doneflag="true">
            <rate name="control"/>
            <rate name="audio"/>
            <outputs num="numChannels"/>
            <arg name="numChannels" type="Int">
                <doc>
                    the number of channels that the buffer will be. Since
                    this is a constant, a change in number of channels of the underlying bus must
                    be reflected by creating different SynthDefs. If a buffer identifier is used of a buffer
                    that has a different numChannels then specified in the PlayBuf, it will fail silently.
                </doc>
            </arg>
            <arg name="buf">
                <doc>
                    the identifier of the buffer to use
                </doc>
            </arg>
            <arg name="speed" default="1">
                <doc>
                    1.0 advances the play head by the server's sample rate each second,
                    so 2.0 means doubling speed (and pitch), and 0.5 means half speed (and half pitch).
                    Negative numbers can be used for backwards playback. If the underlying buffer
                    represents a sound at a different sample rate, the rate should be
                    multiplied by `BufRateScale.kr( bufID )` to obtain the correct speed.
                </doc>
            </arg>
            <arg name="trig" default="1">
                <doc>
                    a trigger which causes a jump to the given startPos. A trigger occurs when a
                    signal changes from non-positive to positive (e.g. &lt;= 0 to &gt; 0).
                </doc>
            </arg>
            <arg name="startPos" default="0">
                <doc>
                    sample frame to start playback. This is read when a trigger occurs.
                </doc>
            </arg>
            <arg name="loop" default="1">
                <doc>
                    1 to loop after the play head reaches the buffer end, 0 to not loop. this can be modulated.
                </doc>
            </arg>
            <arg name="doneAction" default="doNothing">
                <doc>
                    what to do when the play head reaches the buffer end.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen to play back samples from a buffer in memory.

                    `PlayBuf` provides a kind of high-level interface to sample-playback, whereas `BufRd`
                    represents a kind of lower-level access. While `BufRd` has a random-access-pointer
                    in the form of a phase input, `PlayBuf` advances the phase automatically based on
                    a given playback speed. `PlayBuf` uses cubic interpolation.
                </text>
                <see>ugen.BufRd</see>
                <see>ugen.DiskIn</see>
                <see>ugen.RecordBuf</see>
                <see>DoneAction</see>
                <see>ugen.Done</see>
                <see>ugen.BufRateScale</see>
                <see>ugen.BufFrames</see>
            </doc>
        </ugen>
        <!-- <ugen name="SimpleLoopBuf">
        </ugen> -->
        <ugen name="RecordBuf" writesbuf="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="buf" pos="1"/>
            <arg name="offset" default="0" pos="2"/>
            <arg name="recLevel" default="1" pos="3"/>
            <arg name="preLevel" default="0" pos="4"/>
            <arg name="run" default="1" pos="5"/>
            <arg name="loop" default="1" pos="6"/>
            <arg name="trig" default="1" pos="7"/>
            <arg name="doneAction" default="doNothing" pos="8"/>
            <arg name="in" multi="true" pos="0"/>
        </ugen>
        <ugen name="BufRd" readsbuf="true">
            <rate name="control"/>
            <rate name="audio"/>
            <outputs num="numChannels"/>
            <arg name="numChannels" type="Int">
                <doc>
                    number of channels that the buffer will be.
                    Since this is an integer constant, a change in the number of channels must
                    be reflected by creating different SynthDefs.
                </doc>
            </arg>
            <arg name="buf">
                <doc>
                    the identifier of the buffer to use
                </doc>
            </arg>
            <arg name="phase" default="0">
                <doc>
                    audio rate frame-index into the buffer.
                </doc>
            </arg>
            <arg name="loop" default="1">
                <doc>
                    1 to enable looping, 0 to disable looping. this can be modulated.
                </doc>
            </arg>
            <arg name="interp" default="2">
                <doc>
                    1 for no interpolation, 2 for linear, and 4 for cubic interpolation
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen which reads the content of a buffer, using an index pointer.

                    Warning: if the supplied `bufID` refers to a buffer whose number of channels
                    differs from `numChannels`, the UGen will fail silently.

                    An alternative to `BufRd` is `PlayBuf`. While `PlayBuf` plays
                    through the buffer by itself, `BufRd` only moves its read point by the phase input
                    and therefore has no pitch input. `PlayBuf` uses cubic interplation, while
                    `BufRd` has variable interpolation. `PlayBuf` can determine the end of the buffer
                    and issue a done-action.
                </text>
                <see>ugen.PlayBuf</see>
                <see>ugen.BufWr</see>
                <see>ugen.Phasor</see>
                <see>ugen.BufFrames</see>
                <see>ugen.BufRateScale</see>
            </doc>
        </ugen>
        <ugen name="BufWr" writesbuf="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="buf" pos="1"/>
            <arg name="phase" default="0" pos="2"/>
            <arg name="loop" default="1" pos="3"/>
            <arg name="in" multi="true" pos="0"/>
        </ugen>
        <ugen name="Pitch">
            <rate name="control"/>
            <outputs num="2"/>
            <arg name="in"/>
            <arg name="initFreq" default="440"/>
            <arg name="minFreq" default="60"/>
            <arg name="maxFreq" default="4000"/>
            <arg name="execFreq" default="100"/>
            <arg name="binsPerOct" default="16"/>
            <arg name="median" default="1"/>
            <arg name="ampThresh" default="0.01"/>
            <arg name="peakThresh" default="0.5"/>
            <arg name="downSample" default="1"/>
        </ugen>

        <ugen name="BufDelayN" readsbuf="true" writesbuf="true">
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in"/>
            <arg name="delayTime" default="0.2"/>
        </ugen>
        <ugen name="BufDelayL" readsbuf="true" writesbuf="true">
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in"/>
            <arg name="delayTime" default="0.2"/>
        </ugen>
        <ugen name="BufDelayC" readsbuf="true" writesbuf="true">
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in"/>
            <arg name="delayTime" default="0.2"/>
        </ugen>
        <ugen name="BufCombN" readsbuf="true" writesbuf="true">
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
        </ugen>
        <ugen name="BufCombL" readsbuf="true" writesbuf="true">
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
        </ugen>
        <ugen name="BufCombC" readsbuf="true" writesbuf="true">
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
        </ugen>
        <ugen name="BufAllpassN" readsbuf="true" writesbuf="true">
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
        </ugen>
        <ugen name="BufAllpassL" readsbuf="true" writesbuf="true">
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
        </ugen>
        <ugen name="BufAllpassC" readsbuf="true" writesbuf="true">
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
        </ugen>

        <ugen name="DelayN">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="maxDelayTime" default="0.2"/>
            <arg name="delayTime" default="0.2"/>
        </ugen>
        <ugen name="DelayL">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="maxDelayTime" default="0.2"/>
            <arg name="delayTime" default="0.2"/>
        </ugen>
        <ugen name="DelayC">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="maxDelayTime" default="0.2"/>
            <arg name="delayTime" default="0.2"/>
        </ugen>
        <ugen name="CombN">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="in"/>
            <arg name="maxDelayTime" default="0.2"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
        </ugen>
        <ugen name="CombL">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="in"/>
            <arg name="maxDelayTime" default="0.2"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
        </ugen>
        <ugen name="CombC">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="in"/>
            <arg name="maxDelayTime" default="0.2"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
        </ugen>
        <ugen name="AllpassN">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="maxDelayTime" default="0.2"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
        </ugen>
        <ugen name="AllpassL">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="maxDelayTime" default="0.2"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
        </ugen>
        <ugen name="AllpassC">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="maxDelayTime" default="0.2"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
        </ugen>

        <ugen name="PitchShift">
            <rate name="audio" implied="true"/>
            <arg name="in"/>
            <arg name="winSize" default="0.2"/>
            <arg name="pitchRatio" default="1"/>
            <arg name="pitchDispersion" default="0"/>
            <arg name="timeDispersion" default="0"/>
        </ugen>
        <!-- this should exist according to plugin sources...
        <ugen name="GrainTap"/>
        -->
        <ugen name="TGrains" readsbuf="true">
            <rate name="audio" implied="true"/>
            <outputs num="numChannels"/>
            <arg name="numChannels" type="Int"/>
            <arg name="trig"/>
            <arg name="buf"/>
            <arg name="speed" default="1"/>
            <arg name="centerPos" default="0"/>
            <arg name="dur" default="0.1"/>
            <arg name="pan" default="0"/>
            <arg name="amp" default="0.1"/>
            <arg name="interp" default="4"/>
        </ugen>
        <ugen name="ScopeOut" writesbuf="true"> <!-- XXX zero outputs? -->
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="buf"/>
            <arg name="in" multi="true"/>
        </ugen>
        <ugen name="Pluck">
            <rate name="audio" implied="true"/>
            <arg name="in"/>
            <arg name="trig" default="1"/>
            <arg name="maxDelayTime" default="0.2"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
            <arg name="coef" default="0.5"/>
        </ugen>

        <ugen name="DelTapWr" writesbuf="true">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="buf"/>
            <arg name="in"/>
        </ugen>
        <ugen name="DelTapRd" readsbuf="true">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="buf"/>
            <arg name="phase"/>
            <arg name="delayTime"/>
            <arg name="interp" default="1"/>
        </ugen>

        <!-- XXX TODO
        <ugen name="LocalBuf">
        </ugen>
        <ugen name="MaxLocalBufs">
        </ugen>
        <ugen name="SetBuf">
        </ugen>
        <ugen name="ClearBuf">
        </ugen> -->
    </file>

    <file name="DiskIOUGens">
        <!-- // side-effect: advancing sf offset -->
        <ugen name="DiskIn" readsbuf="true" sideeffect="true">
            <rate name="audio" implied="true"/>
            <outputs num="numChannels"/>
            <arg name="numChannels" type="Int">
                <doc>
                    the amount of channels the file and the buffer will have. This is an Int and hence
                    must be pre-determined. Different SynthDefs must be created for different numbers of channels.
                </doc>
            </arg>
            <arg name="buf">
                <doc>
                    the id of the buffer with the correct number of channels and frames
                </doc>
            </arg>
            <arg name="loop" default="0">
                <doc>
                    whether the file should loop when its end is reached
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen to stream in a signal from an audio file. Continuously plays a longer audio file
                    from disk. This requires a buffer to be preloaded with one buffer size of sound. If loop is
                    set to 1, the file will loop.

                    '''Note''': The buffer size must be a multiple of (2 * the server's block size). See
                    `Buffer#cue` for details.
                </text>
                <see>Buffer#cue</see>
                <see>ugen.VDiskIn</see>
                <see>ugen.PlayBuf</see>
            </doc>
        </ugen>

        <ugen name="DiskOut" writesbuf="true">
            <rate name="audio" implied="true"/>
            <arg name="buf">
                <doc>
                    the buffer used internally by the UGen. this number of frames in the buffer must
                    be a power of two (this is currently not checked!). The buffer must have been initialized
                    with a `write` command whose `leaveOpen` argument is true. Note that the number of channels of
                    the buffer and of the input signal must be the same, otherwise `DiskOut` will fail silently
                    (and not write anything to the file).
                </doc>
            </arg>
            <arg name="in" multi="true" rate="ugen">
                <doc>
                    the signal to be recorded
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen which writes a signal to a soundfile on disk. To achieve this efficiently, a buffer is
                    needs to be provides which is used to buffer the incoming signal.

                    '''Note''': It might be that the buffer size must be a multiple of (2 * the server's block size).
                    We haven't currently verified this, but to be safe, you should make sure this property is met.

                    The signal output by the UGen represents the number of frames written.
                </text>
                <see>Buffer#write</see>
                <see>ugen.DiskIn</see>
                <see>ugen.RecordBuf</see>
            </doc>
        </ugen>

        <!-- // side-effect: advancing sf offset -->
        <ugen name="VDiskIn" readsbuf="true" sideeffect="true">
            <!-- note: argument 'rate' renamed to 'speed' -->
            <rate name="audio" implied="true"/>
            <outputs num="numChannels"/>
            <arg name="numChannels" type="Int">
                <doc>
                    the amount of channels the file and the buffer will have. This is an Int and hence
                    must be pre-determined. Different SynthDefs must be created for different numbers of channels
                </doc>
            </arg>
            <arg name="buf">
                <doc>
                    the id of the buffer with the correct number of channels and frames
                </doc>
            </arg>
            <arg name="speed" default="1">
                <doc>
                    controls the speed of playback. Values below 4 are probably fine, but the higher the value,
                    the more disk activity there is, and the more likelihood there will be a problem.
                    The following must be true: `rate &lt; bufFrames / (2 * blockSize)`, e.g with typical default
                    values, this will be `32768 / (2 * 64) = 256`.
                </doc>
            </arg>
            <arg name="loop" default="0">
                <doc>
                    whether the file should loop when its end is reached
                </doc>
            </arg>
            <arg name="sendID" default="0">
                <doc>
                    If a value other than zero is used, the UGen sends an OSC message with this id and the
                    file position each time it reloads the buffer: `OSCMessage( "/diskin", nodeID, sendID, frame )`
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen to stream in a signal from an audio file with variable playback speed.
                    Continuously plays a longer audio file
                    from disk. This requires a buffer to be preloaded with one buffer size of sound. If loop is
                    set to 1, the file will loop.

                    '''Note''': The buffer size must be a multiple of (2 * the server's block size). See
                    `Buffer#cue` for details.

                    If the speed is too high, the UGen will not execute, posting a warning.
                </text>
            </doc>
            <see>Buffer#cue</see>
            <see>ugen.DiskIn</see>
            <see>ugen.DiskOut</see>
            <see>ugen.PlayBuf</see>
        </ugen>
    </file>

    <file name="DynNoiseUGens">
        <ugen name="LFDNoise0" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="500">
                <doc>
                    rate at which to generate random values.
                </doc>
            </arg>
            <doc>
                <text>
                    A dynamic step noise UGen. Like `LFNoise0`, it generates abruptly changing random values
                    between `-1` and `+1` at a rate given by the `freq` argument, with two differences:
                    There is no time quantization, and it there is fast recovery from low freq values.

                    In contrast, `LFNoise0`, `LFNoise1`, and `LFNoise2` quantize to the nearest integer division
                    of the samplerate, and they poll the freq argument only when scheduled, and thus seem
                    to hang when freqs get very low.

                    If very high or very low freqs are not needed, or fixed freqs are used,
                    `LFNoise0` is more efficient.
                </text>
                <see>ugen.LFNoise0</see>
                <see>ugen.LFDNoise1</see>
                <see>ugen.LFDNoise2</see>
                <see>ugen.TRand</see>
            </doc>
        </ugen>
        <ugen name="LFDNoise1" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="500">
                <doc>
                    rate at which to generate random values.
                </doc>
            </arg>
            <doc>
                <text>
                    A dynamic ramp noise UGen. Like `LFNoise1`, it generates linearly interpolated random values
                    between `-1` and `+1` at a rate given by the `freq` argument, with two differences:
                    There is no time quantization, and it there is fast recovery from low freq values.

                    In contrast, `LFNoise0`, `LFNoise1`, and `LFNoise2` quantize to the nearest integer division
                    of the samplerate, and they poll the freq argument only when scheduled, and thus seem
                    to hang when freqs get very low.

                    If very high or very low freqs are not needed, or fixed freqs are used,
                    `LFNoise1` is more efficient.
                </text>
                <see>ugen.LFNoise1</see>
                <see>ugen.LFDNoise0</see>
                <see>ugen.LFDNoise2</see>
                <see>ugen.Ramp</see>
            </doc>
        </ugen>
        <ugen name="LFDNoise3" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="500">
                <doc>
                    rate at which to generate random values.
                </doc>
            </arg>
        </ugen>
        <ugen name="LFDClipNoise" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="500">
                <doc>
                    rate at which to generate random values.
                </doc>
            </arg>
        </ugen>
    </file>

    <file name="FFT_UGens">
        <ugen name="FFT" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="buf"/>
            <arg name="in"/>
            <arg name="hop" default="0.5"/>
            <arg name="winType" default="0"/>
            <arg name="active" default="1"/>
            <arg name="winSize" default="0"/>
        </ugen>
        <ugen name="IFFT" readsfft="true">
            <rate name="control"/>
            <rate name="audio" methodalias="apply"/>
            <arg name="chain"/>
            <arg name="winType" default="0"/>
            <arg name="winSize" default="0"/>
        </ugen>
        <ugen name="FFTTrigger" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="buf">
                <doc>
                    the identifier of the buffer to use
                </doc>
            </arg>
            <arg name="hop" default="0.5">
                <doc>
                    the hop size for timing triggers
                </doc>
            </arg>
            <arg name="polar" default="0">
                <doc>
                    whether the complex buffer content is given in cartesian coordinates (0) or
                    in polar coordinates (1)
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that takes a buffer and prepares it to be used in FFT chains,
                    without doing an actual FFT on a signal. This is useful if you want to provide
                    a buffer whose content had already been transformed into the Fourier domain.
                </text>
            </doc>
        </ugen>

        <ugen name="PV_MagAbove" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <arg name="thresh" default="0">
                <doc>
                    magnitude threshold.
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that passes only those bins whose magnitudes are above a given threshold.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_MagBelow" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <arg name="thresh" default="0">
                <doc>
                    magnitude threshold.
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that passes only those bins whose magnitudes are below a given threshold.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_MagClip" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <arg name="thresh" default="0">
                <doc>
                    magnitude threshold. Each bin's magnitude is limited to
                    be not greater than this threshold.
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that limits (clips) the magnitude of the bins to a given threshold.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_MagMul" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chainA">
                <doc>
                    the first FFT'ed buffer (this gets replaced by
                    the output signal)
                </doc>
            </arg>
            <arg name="chainB">
                <doc>
                    the second FFT'ed buffer
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that multiplies the magnitudes of two inputs and keeps the
                    phases of the first input.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_MagDiv" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chainA">
                <doc>
                    the first FFT'ed buffer (this gets replaced by
                    the output signal)
                </doc>
            </arg>
            <arg name="chainB">
                <doc>
                    the second FFT'ed buffer
                </doc>
            </arg>
            <arg name="zeroes" default="0.0001">
                <doc>
                    the noise floor to assume when detecting zero bins in
                    chainB that would cause a division by zero and hence blow up. The ugen
                    will use divide by this magnitude instead when zeroes are detected,
                    resulting in a maximum boost of `zeroes.reciprocal`.
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that divides magnitudes of two inputs and keeps the
                    phases of the first input.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_MagSquared" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that squares the magnitudes and re-normalizes to previous peak.
                    This makes weak bins weaker.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_MagNoise" readsfft="true" writesfft="true" random="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that multiplies the magnitudes by random noise.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_Copy" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chainA">
                <doc>
                    the first FFT'ed buffer (this gets replaced by
                    the output signal)
                </doc>
            </arg>
            <arg name="chainB">
                <doc>
                    the second FFT'ed buffer
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that copies the spectral frames from chainA
                    to chainB. This allows for parallel processing of spectral data without the
                    need for multiple FFT UGens, and to copy out data at that point in the chain
                    for other purposes. chainA and chainB must be the same size. The output
                    will carry further chainA, so you chan insert the ugen at the appropriate
                    place in the signal chain.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_CopyPhase" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chainA">
                <doc>
                    the first FFT'ed buffer (this gets replaced by
                    the output signal)
                </doc>
            </arg>
            <arg name="chainB">
                <doc>
                    the second FFT'ed buffer
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that combines the magnitudes of first input and phases of the second input.
                    phases of the first input.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_PhaseShift" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <arg name="shift">
                <doc>
                    phase shift in radians
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that shifts the phase of each bins by a given amount.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_PhaseShift90" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that shift the phase of all bins by 90 degrees.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_PhaseShift270" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that shift the phase of all bins by 270 (or -90) degrees.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_Min" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chainA">
                <doc>
                    the first FFT'ed buffer (this gets replaced by
                    the output signal)
                </doc>
            </arg>
            <arg name="chainB">
                <doc>
                    the second FFT'ed buffer
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that outputs the bins with the minimum magnitude
                    of the two inputs.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_Max" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chainA">
                <doc>
                    the first FFT'ed buffer (this gets replaced by
                    the output signal)
                </doc>
            </arg>
            <arg name="chainB">
                <doc>
                    the second FFT'ed buffer
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that outputs the bins with the maximum magnitude
                    of the two inputs.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_Mul" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chainA">
                <doc>
                    the first FFT'ed buffer (this gets replaced by
                    the output signal)
                </doc>
            </arg>
            <arg name="chainB">
                <doc>
                    the second FFT'ed buffer
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that performs a complex multiplication of the
                    two inputs. The formula
                    is `(Re(A) * Re(B) - Im(A) * Im(B)) + i(Im(A) * Re(B) + Re(A) * Im(B))`.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_Div" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chainA">
                <doc>
                    the first FFT'ed buffer (this gets replaced by
                    the output signal)
                </doc>
            </arg>
            <arg name="chainB">
                <doc>
                    the second FFT'ed buffer
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that performs a complex division of the
                    two inputs. Be careful that `chainB`, the divisor, does not
                    contain zeroes as they would obviously blow up the division.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_Add" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chainA">
                <doc>
                    the first FFT'ed buffer (this gets replaced by
                    the output signal)
                </doc>
            </arg>
            <arg name="chainB">
                <doc>
                    the second FFT'ed buffer
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that performs a complex addition of the
                    two inputs. The formula
                    is `(Re(A) + Re(B)) + i(Im(A) + Im(B))`.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_RectComb" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <arg name="numTeeth" default="1">
                <doc>
                    the number of periods in the rectangle wave, where
                    zero would mean the input signal is not affected, one means that
                    there is exactly one period of the wave across the spectrum,
                    hence one pass-band and one stop-band.
                </doc>
            </arg>
            <arg name="phase" default="0">
                <doc>
                    the phase offset of the rectangle wave, where
                    1.0 is one full period. This is like the offset into the wavetable
                    holding the rectangle, so a value of 0.25 means we start 25%
                    into the basic waveform, and after 0.75 periods the next
                    full period (high slope) begins.
                </doc>
            </arg>
            <arg name="width" default="0.5">
                <doc>
                    the pulse width between 0.0 (infinitely small
                    high slope, so all bins filtered out) to 0.5 (half period is
                    high slope, half period is low slope) to 1.0 (maximally
                    wide high slope, no bins filtered out).
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that makes a series of gaps in a spectrum.
                    This is done by multiplying the spectrum with a kind of
                    rectangle wave that goes from zero to nyquist. The high slope
                    of the rectangle lets the input bins pass (quasi pass-band),
                    the low slope filteres them out (quasi stop-band).
                </text>
                <see>ugen.PV_RectComb2</see>
            </doc>
        </ugen>
        <ugen name="PV_RectComb2" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chainA">
                <doc>
                    the first FFT'ed buffer (this gets replaced by the output signal)
                </doc>
            </arg>
            <arg name="chainB">
                <doc>
                    the second FFT'ed buffer
                </doc>
            </arg>
            <arg name="numTeeth" default="1">
                <doc>
                    the number of periods in the rectangle wave, where
                    zero would mean the first input signal is fully passed through, one means that
                    there is exactly one period of the wave across the spectrum,
                    hence one pass-band (first signal passed through) and one stop-band
                    (second signal passed through).
                </doc>
            </arg>
            <arg name="phase" default="0">
                <doc>
                    the phase offset of the rectangle wave, where
                    1.0 is one full period. This is like the offset into the wavetable
                    holding the rectangle, so a value of 0.25 means we start 25%
                    into the basic waveform, and after 0.75 periods the next
                    full period (high slope) begins.
                </doc>
            </arg>
            <arg name="width" default="0.5">
                <doc>
                    the pulse width between 0.0 (infinitely small
                    high slope, so all bins are copied from the second input) to 0.5
                    (half period is high slope -- copied from first input --, half period is
                    low slope -- copied from second input) to 1.0 (maximally
                    wide high slope, so all bins passed from the first input).
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that switches between two input spectra
                    according to a rectangle wave.
                    This is basically identical to `PV_RectComb`, however during the
                    low slopes of the rectangle wavewave, instead of clearing out the bins,
                    it copies over the corresponding bins of the second fft input buffer.
                </text>
                <see>ugen.PV_RectComb</see>
            </doc>
        </ugen>
        <ugen name="PV_BrickWall" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <arg name="wipe">
                <doc>
                    can range between -1 and +1.
                    if wipe == 0 then there is no effect.
                    if  wipe &gt; 0 then it acts like a high pass filter, clearing bins from the bottom up.
                    if  wipe &lt; 0 then it acts like a low pass filter, clearing bins from the top down.
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that clears bins above or below a cutoff point.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_BinWipe" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chainA">
                <doc>
                    the first FFT'ed buffer (this gets replaced by the output signal)
                </doc>
            </arg>
            <arg name="chainB">
                <doc>
                    the second FFT'ed buffer
                </doc>
            </arg>
            <arg name="wipe">
                <doc>
                    can range between -1 and +1.
                    if wipe == 0 then the output is the same as inA.
                    if  wipe &gt; 0 then it begins replacing with bins from inB from the bottom up.
                    if  wipe &lt; 0 then it begins replacing with bins from inB from the top down.
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that combine low and high bins from two inputs.
                    It does so by copiying low bins from one input and the high bins of the other,
                    thus realizes a kind of "wipe" between the two input signals.
                </text>
                <see>ugen.PV_RandWipe</see>
            </doc>
        </ugen>
        <ugen name="PV_LocalMax" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <arg name="thresh" default="0">
                <doc>
                    magnitude threshold used for general filtering, prior to
                    the local-maximum-filtering
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that passes only those bins whose magnitudes constitute local maxima.
                    Additionally, the given threshold is also used to filter out bins whose magnitude
                    lies below this threshold.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_Conj" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that converts the bins into their
                    complex conjugate counterparts. The complex conjugate
                    is equal to the input, but with reversed sign of the imaginary part.
                </text>
            </doc>
        </ugen>

        <ugen name="PV_BinScramble" readsfft="true" writesfft="true" random="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <arg name="wipe" default="0.5">
                <doc>
                    the amount of bins scrambled, from 0 (none) to 1 (all bins scrambled).
                </doc>
            </arg>
            <arg name="width" default="0.2">
                <doc>
                    a value from zero to one, indicating the maximum randomized distance of a bin from its
                    original location in the spectrum.
                </doc>
            </arg>
            <arg name="trig" default="1">
                <doc>
                    causes a new random bin re-ordering to be made. a trigger
                    occurs when passing from non-positive to positive value.
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that randomizes the order of the bins.
                    The trigger will select a new random ordering.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_MagSmear" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <arg name="bins" default="1">
                <doc>
                    number of bins to average on each side of bin. As this number rises, so will CPU usage.
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that averages each bin's magnitude with its neighbors.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_MagShift" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <arg name="stretch" default="1">
                <doc>
                    the factor to multiply each bin position with
                </doc>
            </arg>
            <arg name="shift" default="0">
                <doc>
                    the translation of the spectrum, in number of bins
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that stretches and shifts the magnitudes of the spectrum.
                    This is live `PV_BinShift` but instead of scaling and shifting the whole complex
                    bins (magnitude and phase), this only operates on the magnitudes and leaves
                    the phases in their original bins.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_BinShift" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <arg name="stretch" default="1">
                <doc>
                    the factor to multiply each bin position with, where 0.5 kind of
                    transposes the signal down by an octave, and 2 transposes it up by an octave.
                </doc>
            </arg>
            <arg name="shift" default="0">
                <doc>
                    the translation of the spectrum, in number of bins. Since the
                    FFT produces a linear frequency axis, the will produce harmonic distortion.
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that stretches and shifts the spectrum.
                    It takes each bin, first stretches (scales) its position (bin number)
                    with a given factor, and then adds a shift to it.
                </text>
            </doc>
        </ugen>

        <ugen name="PV_RandWipe" readsfft="true" writesfft="true" random="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chainA">
                <doc>
                    the first FFT'ed buffer (this gets replaced by the output signal)
                </doc>
            </arg>
            <arg name="chainB">
                <doc>
                    the second FFT'ed buffer
                </doc>
            </arg>
            <arg name="wipe">
                <doc>
                    the crossfader position from 0.0 (all bins are
                    taken from `chainA`) to 1.0 (all bins are taken from `chainB`).
                    For instance, if wipe is 0.5, half of the bins are taken from
                    either input. The decision whether a bin is taken from A or B
                    is random, however remains constant between two triggers.
                </doc>
            </arg>
            <arg name="trig">
                <doc>
                    a signal the triggers the re-newed process of
                    determining for each bin whether it will be taken from input
                    A or B. A trigger occurs when passing from non-positive to
                    positive value.
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that crossfades between two input spectra
                    by taking bins randomly from them according to a given probability.
                </text>
                <see>ugen.PV_BinWipe</see>
            </doc>
        </ugen>
        <ugen name="PV_Diffuser" readsfft="true" writesfft="true" random="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <arg name="trig" default="1">
                <doc>
                    to trigger a new selection of random phases. A trigger occurs when
                    passing from non-positive to positive value.
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that adds a different constant random phase shift to each bin.
                    The trigger will select a new set of random phases.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_RandComb" readsfft="true" writesfft="true" random="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <arg name="wipe" default="0.5">
                <doc>
                    the probability (from 0 to 1) of bins being wiped out,
                    hence 0 means no bins are wiped out, 1 means all bins are wiped out
                    (output will be silence).
                </doc>
            </arg>
            <arg name="trig" default="1">
                <doc>
                    causes a new random bin selection to be made. a trigger
                    occurs when passing from non-positive to positive value.
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that randomly clears out bins of the signal.
                    Which bins are wiped out is subject to a random choice (only the amount is
                    specified) that remains constant between triggers.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_MagFreeze" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <arg name="freeze" default="1">
                <doc>
                    whether the current levels are frozen (&gt; 0) or not (0).
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that freezes the magnitudes at current levels.
                    Freezing happens when the freeze input has a value of &gt; 0.
                </text>
            </doc>
        </ugen>

        <ugen name="PartConv" readsbuf="true">
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="fftSize"/>
            <arg name="buf"/>
        </ugen>
    </file>

    <file name="FFT2_UGens">
        <ugen name="Convolution" readsbuf="true">
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="kernel"/>
            <arg name="frameSize"/>
            <doc>
                <see>ugen.Convolution2L</see>
                <see>ugen.Convolution3</see>
                <see>ugen.Convolution2</see>
                <see>ugen.StereoConvolution2L</see>
            </doc>
        </ugen>
        <ugen name="Convolution2" readsbuf="true">
            <rate name="audio"/>
            <arg name="in">
                <doc>
                    the realtime input to be convolved
                </doc>
            </arg>
            <arg name="kernel">
                <doc>
                    buffer identifier for the fixed kernel, which may be modulated in combination with the trigger
                </doc>
            </arg>
            <arg name="trig" default="1">
                <doc>
                    updates the kernel on a change from non-positive to positive (&lt;= 0 to &gt;0)
                </doc>
            </arg>
            <arg name="frameSize">
                <doc>
                    size of the kernel. this must be a power of two. the FFT calculated internally
                    by the UGen has a size of twice this value. The maximum allowed frameSize
                    is 65536(?).
                </doc>
            </arg>
            <doc>
                <text>
                    A frequency-domain convolution UGen using a fixed kernel which can be updated
                    by a trigger signal. The delay caused by the convolution when the kernel is a dirac impulse
                    is equal to `frameSize - (controlBlockSize + 1)` (measured august 2010), so for a frameSize
                    of 2048 and a controlBlockSize of 64, this is 1983 sample frames.
                </text>
                <see>ugen.Convolution2L</see>
                <see>ugen.Convolution3</see>
                <see>ugen.Convolution</see>
                <see>ugen.StereoConvolution2L</see>
            </doc>
        </ugen>
        <ugen name="Convolution2L" readsbuf="true">
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="kernel"/>
            <arg name="trig" default="1"/>
            <arg name="frameSize"/>
            <arg name="fadePeriods" default="1"/>
            <doc>
                <see>ugen.Convolution2</see>
                <see>ugen.Convolution3</see>
                <see>ugen.Convolution</see>
                <see>ugen.StereoConvolution2L</see>
            </doc>
        </ugen>
        <ugen name="StereoConvolution2L" readsbuf="true">
            <rate name="audio"/>
            <outputs num="2"/>
            <arg name="in">
                <doc>
                    the realtime input to be convolved
                </doc>
            </arg>
            <arg name="kernelL">
                <doc>
                    buffer identifier for the left channel's fixed kernel, which may be modulated in combination
                    with the trigger
                </doc>
            </arg>
            <arg name="kernelR">
                <doc>
                    buffer identifier for the right channel's fixed kernel, which may be modulated in combination
                    with the trigger
                </doc>
            </arg>
            <arg name="trig" default="1">
                <doc>
                    updates the kernel on a change from non-positive to positive (&lt;= 0 to &gt;0), and starts a new
                    crossfade from the previous kernel to the new one over the given amount of periods.
                </doc>
            </arg>
            <arg name="frameSize">
                <doc>
                    size of each kernel. this must be a power of two. the FFT calculated internally
                    by the UGen has a size of twice this value. The maximum allowed frameSize
                    is 65536(?).
                </doc>
            </arg>
            <arg name="fadePeriods" default="1">
                <doc>
                    The number of periods over which a crossfade is performed. This must be an integer
                </doc>
            </arg>
            <doc>
                <text>
                    A frequency domain stereo convolution UGen, capable of performing linear crossfades between kernel updates.
                    When receiving a trigger, there is a linear crossfade between the old kernel the new buffer contents.
                    It operates similar to Convolution2L, however uses two buffers and outputs a stereo signal, resulting
                    in better CPU usage than two discrete instances of Convolution2L as this way one FFT transformation per period
                    is saved.
                </text>
                <see>ugen.Convolution2</see>
                <see>ugen.Convolution3</see>
                <see>ugen.Convolution</see>
                <see>ugen.Convolution2L</see>
            </doc>
        </ugen>
        <ugen name="Convolution3" readsbuf="true">
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="kernel"/>
            <arg name="trig" default="1"/>
            <arg name="frameSize"/>
            <doc>
                <text>
                    A UGen for triggered convolution in the time domain.
                </text>
            </doc>
        </ugen>

        <ugen name="PV_ConformalMap" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain"/>
            <arg name="real" default="0"/>
            <arg name="imag" default="0"/>
        </ugen>

        <ugen name="PV_JensenAndersen" readsfft="true">
            <rate name="audio"/>
            <arg name="chain"/>
            <arg name="propSC" default="0.25"/>
            <arg name="propHFE" default="0.25"/>
            <arg name="propHFC" default="0.25"/>
            <arg name="propSF" default="0.25"/>
            <arg name="thresh" default="1.0"/>
            <arg name="waitTime" default="0.04"/>
        </ugen>
        <ugen name="PV_HainsworthFoote" readsfft="true">
            <rate name="audio"/>
            <arg name="chain"/>
            <arg name="propH" default="0.0"/>
            <arg name="propF" default="0.0"/>
            <arg name="thresh" default="1.0"/>
            <arg name="waitTime" default="0.04"/>
        </ugen>

        <ugen name="RunningSum">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    the input signal to sum up
                </doc>
            </arg>
            <arg name="winSize" default="440">
                <doc>
                    the length of the sliding window over the input signal.
                    these are the number of audio sample-frames for audio-rate calculation,
                    or the number of blocks for control-rate calculation summed up.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen calculating the running sum of an input signal over a given number of samples.
                </text>
            </doc>
        </ugen>
    </file>

    <file name="FilterUGens">
        <ugen name="Ramp">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    the signal to smooth out
                </doc>
            </arg>
            <arg name="dur" default="0.1">
                <doc>
                    the ramp-time (seconds) which is also the interval of the sampling
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen which produces a linear lag (time smear) regarding
                    and input signal. Other than `Lag` which is a feedback
                    filter with exponential decay, `Ramp` applies a linear
                    ramp. This is achieved by sampling the input signal
                    at regular intervals given by the `lagTime` and starting
                    a new line segment after each interval.
                </text>
                <see>ugen.Lag</see>
                <see>ugen.Sweep</see>
            </doc>
        </ugen>
        <ugen name="Lag">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal.
                </doc>
            </arg>
            <arg name="time" default="0.1">
                <doc>
                    60 dB lag time in seconds.
                </doc>
            </arg>
            <doc>
                <text>
                    An exponential lag UGen.
                    This is essentially the same as `OnePole` except that instead of supplying the coefficient directly,
                    it is calculated from a 60 dB lag time. This is the time required for the filter to converge to
                    within 0.01 % of a value. This is useful for smoothing out control signals.
                </text>
                <see>ugen.OnePole</see>
                <see>ugen.LagUD</see>
                <see>ugen.Lag2</see>
                <see>ugen.Ramp</see>
            </doc>
        </ugen>
        <ugen name="Lag2">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal.
                </doc>
            </arg>
            <arg name="time" default="0.1">
                <doc>
                    60 dB lag time in seconds.
                </doc>
            </arg>
            <doc>
                <text>
                    A cascaded exponential lag
                    UGen. `Lag2.kr(in, time)` is equivalent to `Lag.kr(Lag.kr(in, time), time)`,
                    thus resulting in a smoother transition. This saves on CPU as you only have to
                    calculate the decay factor once instead of twice.
                </text>
                <see>ugen.Lag</see>
                <see>ugen.Lag2UD</see>
                <see>ugen.Lag3</see>
            </doc>
        </ugen>
        <ugen name="Lag3">
             <rate name="control"/>
             <rate name="audio"/>
             <arg name="in" rate="ugen">
                 <doc>
                     input signal.
                 </doc>
             </arg>
             <arg name="time" default="0.1">
                 <doc>
                     60 dB lag time in seconds.
                 </doc>
             </arg>
             <doc>
                 <text>
                     A cascaded exponential lag
                    UGen. `Lag3.kr(in, time)` is equivalent to `Lag.kr(Lag.kr(Lag.kr(Lag.kr(in, time), time), time)`,
                    thus resulting in a smoother transition. This saves on CPU as you only have to
                    calculate the decay factor once instead of three times.
                 </text>
                 <see>ugen.Lag</see>
                 <see>ugen.Lag3UD</see>
                 <see>ugen.Lag2</see>
             </doc>
         </ugen>
        <ugen name="LagUD">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal.
                </doc>
            </arg>
            <arg name="timeUp" default="0.1">
                <doc>
                    60 dB lag time in seconds effective during a rising slope in the input signal
                </doc>
            </arg>
            <arg name="timeDown" default="0.1">
                <doc>
                    60 dB lag time in seconds effective during a falling slope in the input signal
                </doc>
            </arg>
            <doc>
                <text>
                    An exponential lag UGen with separate inputs for up and down slope.
                    This is essentially the same as `Lag` except that you can supply a different 60 dB time
                    for when the signal goes up, from when the signal goes down.
                </text>
                <see>ugen.Lag</see>
                <see>ugen.Lag2UD</see>
            </doc>
        </ugen>
        <ugen name="Lag2UD">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal.
                </doc>
            </arg>
            <arg name="timeUp" default="0.1">
                <doc>
                    60 dB lag time in seconds effective during a rising slope in the input signal
                </doc>
            </arg>
            <arg name="timeDown" default="0.1">
                <doc>
                    60 dB lag time in seconds effective during a falling slope in the input signal
                </doc>
            </arg>
            <doc>
                <text>
                    A cascaded exponential lag UGen with separate inputs for up and down
                    slope. `Lag2UD.kr(in, up, down)` is equivalent to `LagUD.kr(LagUD.kr(in, up, down), up, down)`,
                    thus resulting in a smoother transition. This saves on CPU as you only have to
                    calculate the decay factors once instead of twice.
                </text>
                <see>ugen.LagUD</see>
                <see>ugen.Lag2</see>
                <see>ugen.Lag3UD</see>
            </doc>
        </ugen>
        <ugen name="Lag3UD">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal.
                </doc>
            </arg>
            <arg name="timeUp" default="0.1">
                <doc>
                    60 dB lag time in seconds effective during a rising slope in the input signal
                </doc>
            </arg>
            <arg name="timeDown" default="0.1">
                <doc>
                    60 dB lag time in seconds effective during a falling slope in the input signal
                </doc>
            </arg>
            <doc>
                <text>
                    A cascaded exponential lag UGen with separate inputs for up and down
                    slope. `Lag3UD.kr(in, up, down)` is equivalent to `LagUD.kr(LagUD.kr(LagUD.kr(in, up, down), up, down), up, down)`,
                    thus resulting in a smoother transition. This saves on CPU as you only have to
                    calculate the decay factors once instead of three times.
                </text>
                <see>ugen.LagUD</see>
                <see>ugen.Lag3</see>
                <see>ugen.Lag2UD</see>
            </doc>
        </ugen>
        <ugen name="OnePole">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal to be processed
                </doc>
            </arg>
            <arg name="coeff" default="0.5">
                <doc>
                    feedback coefficient. Should be between -1 and +1
                </doc>
            </arg>
            <doc>
                <text>
                    A one pole (IIR) filter UGen.
                    Implements the formula :
                    {{{
                    out(i) = ((1 - abs(coef)) * in(i)) + (coef * out(i-1))
                    }}}
                </text>
                <see>ugen.OneZero</see>
                <see>ugen.Lag</see>
            </doc>
        </ugen>
        <ugen name="OneZero">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal to be processed
                </doc>
            </arg>
            <arg name="coeff" default="0.5">
                <doc>
                    feed forward coefficient. +0.5 makes a two point averaging filter (see also `LPZ1`),
                    -0.5 makes a differentiator (see also `HPZ1`),  +1 makes a single sample delay (see also `Delay1`),
                    -1 makes an inverted single sample delay.
                </doc>
            </arg>
            <doc>
                <text>
                    A one zero (FIR) filter UGen.
                    Implements the formula :
                    {{{
                    out(i) = ((1 - abs(coef)) * in(i)) + (coef * in(i-1))
                    }}}
                </text>
                <see>ugen.OnePole</see>
                <see>ugen.LPZ1</see>
                <see>ugen.HPZ1</see>
                <see>ugen.Delay1</see>
                <see>ugen.Integrator</see>
            </doc>
        </ugen>
        <ugen name="TwoPole">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal to be processed
                </doc>
            </arg>
            <arg name="freq" default="440"/>
            <arg name="radius" default="0.8"/>
        </ugen>
        <ugen name="TwoZero">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal to be processed
                </doc>
            </arg>
            <arg name="freq" default="440"/>
            <arg name="radius" default="0.8"/>
        </ugen>
        <ugen name="Decay">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal to be processed
                </doc>
            </arg>
            <arg name="time" default="1"/>
        </ugen>
        <ugen name="Decay2">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal to be processed
                </doc>
            </arg>
            <arg name="attack" default="0.01"/>
            <arg name="release" default="1"/>
        </ugen>
        <!-- this should exist according to plugin sources...
        <ugen name="Flip"/>
        -->
        <ugen name="Delay1">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
        </ugen>
        <ugen name="Delay2">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
        </ugen>
        <ugen name="Integrator">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal to be processed
                </doc>
            </arg>
            <arg name="coeff" default="1">
                <doc>
                    the leak coefficient. Should be between -1 and +1
                </doc>
            </arg>
            <doc>
                <text>
                    A filter UGen to integrate an input signal with a leak.
                    Implements the formula :
                    {{{
                    out(i) = in(i) + (coef * out(i-1))
                    }}}
                </text>
                <see>ugen.OnePole</see>
                <see>ugen.HPZ1</see>
                <see>ugen.LPZ1</see>
            </doc>
        </ugen>
        <ugen name="LeakDC">
            <rate name="control">
                <arg name="coeff" default="0.9"/>
            </rate>
            <rate name="audio">
                <arg name="coeff" default="0.995"/>
            </rate>
            <arg name="in" rate="ugen"/>
            <arg name="coeff"/>
        </ugen>
        <ugen name="LPZ1">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal to be processed
                </doc>
            </arg>
            <doc>
                <text>
                    two point average filter UGen.
                    Implements the formula :
                    {{{
                    out(i) = 0.5 * (in(i) + in(i-1))
                    }}}
                </text>
                <see>ugen.OnePole</see>
                <see>ugen.HPZ1</see>
                <see>ugen.Integrator</see>
            </doc>
        </ugen>
        <ugen name="HPZ1">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal to be processed
                </doc>
            </arg>
            <doc>
                <text>
                    A two point difference filter UGen.
                    Implements the formula :
                    {{{
                    out(i) = 0.5 * (in(i) - in(i-1))
                    }}}
                </text>
                <see>ugen.OneZero</see>
                <see>ugen.LPZ1</see>
            </doc>
        </ugen>
        <ugen name="LPZ2">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
        </ugen>
        <ugen name="HPZ2">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
        </ugen>
        <ugen name="BPZ2">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
        </ugen>
        <ugen name="BRZ2">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
        </ugen>
        <ugen name="APF">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="freq" default="440"/>
            <arg name="radius" default="0.8"/>
        </ugen>
        <ugen name="LPF">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="freq" default="440"/>
        </ugen>
        <ugen name="HPF">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="freq" default="440"/>
        </ugen>
        <ugen name="BPF">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="freq" default="440"/>
            <arg name="rq" default="1"/>
        </ugen>
        <ugen name="BRF">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="freq" default="440"/>
            <arg name="rq" default="1"/>
        </ugen>
        <ugen name="RLPF">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="freq" default="440"/>
            <arg name="rq" default="1"/>
        </ugen>
        <ugen name="RHPF">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="freq" default="440"/>
            <arg name="rq" default="1"/>
        </ugen>

        <ugen name="Slew">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal
                </doc>
            </arg>
            <arg name="up" default="1">
                <doc>
                    maximum upward slope.
                </doc>
            </arg>
            <arg name="down" default="1">
                <doc>
                    maximum downward slope.
                </doc>
            </arg>
            <doc>
                <text>
                    A slew rate limiter UGen.
                    Limits the slope of an input signal. The slope is expressed in units per second.
                </text>
            </doc>
        </ugen>
        <ugen name="Slope">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal to be measured
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen measuring the slope of signal.
                    It calculates the rate of change per second of a signal, as given by the following formula:
                    {{{
                    out(i) = (in(i) - in(i-1)) * sampleRate
                    }}}
                    It thus equal to `HPZ1.ar(_) * 2 * SampleRate.ir`
                </text>
            </doc>
        </ugen>

        <ugen name="MidEQ">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="freq" default="440"/>
            <arg name="rq" default="1"/>
            <arg name="gain" default="0"/>
        </ugen>
        <ugen name="Median">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen" pos="0"/>
            <arg name="length" default="3" pos="1"/>
            <doc warnpos="true"/>
        </ugen>

        <ugen name="Resonz">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="freq" default="440"/>
            <arg name="rq" default="1"/>
        </ugen>
        <ugen name="Ringz">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="freq" default="440"/>
            <arg name="attack" default="1"/>
            <arg name="decay" default="1"/>
        </ugen>
        <ugen name="Formlet">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="freq" default="440"/>
            <arg name="attack" default="1"/>
            <arg name="decay" default="1"/>
        </ugen>

        <ugen name="FOS">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="a0" default="0"/>
            <arg name="a1" default="0"/>
            <arg name="b1" default="0"/>
        </ugen>
        <ugen name="SOS">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="a0" default="0"/>
            <arg name="a1" default="0"/>
            <arg name="a2" default="0"/>
            <arg name="b1" default="0"/>
            <arg name="b2" default="0"/>
        </ugen>

        <ugen name="Compander">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in">
                <doc>
                    The signal to be compressed / expanded / gated.
                </doc>
            </arg>
            <arg name="ctrl">
                <doc>
                    The signal whose amplitude controls the processor. Often the same as in, but one may wish
                    to apply equalization or delay to it to change the compressor character (side-chaining), or even feed
                    a completely different signal, for instance in a ducking application.
                </doc>
            </arg>
            <arg name="thresh" default="0.5">
                <doc>
                    Control signal amplitude threshold, which determines the break point between slopeBelow
                    and slopeAbove. Usually 0..1. The control signal amplitude is calculated using RMS.
                </doc>
            </arg>
            <arg name="ratioBelow" default="1">
                <doc>
                    Slope of the amplitude curve below the threshold. If this slope &gt; 1.0, the amplitude
                    will drop off more quickly the softer the control signal gets; when the control signal is close to 0
                    amplitude, the output should be exactly zero -- hence, noise gating. Values &lt; 1.0 are possible,
                    but it means that a very low-level control signal will cause the input signal to be amplified,
                    which would raise the noise floor.
                </doc>
            </arg>
            <arg name="ratioAbove" default="1">
                <doc>
                    Slope of the amplitude curve above the threshold. Values &lt; 1.0 achieve compression
                    (louder signals are attenuated); &gt; 1.0, you get expansion (louder signals are made even louder).
                    For 3:1 compression, you would use a value of 1/3 here.
                </doc>
            </arg>
            <arg name="attack" default="0.01">
                <doc>
                    The amount of time it takes for the amplitude adjustment to kick in fully. This is
                    usually pretty small, not much more than 10 milliseconds (the default value). I often set it as low as
                    2 milliseconds (0.002).
                </doc>
            </arg>
            <arg name="release" default="0.1">
                <doc>
                    The amount of time for the amplitude adjustment to be released. Usually a bit longer
                    than attack; if both times are too short, you can get some (possibly unwanted) artifacts.
                </doc>
            </arg>
            <doc>
                <text>
                    A compressor, expander, limiter, gate and ducking UGen. This dynamic processor uses a
                    hard-knee characteristic. All of the thresholds and ratios are given as direct
                    values, not in decibels!
                </text>
                <see>ugen.Limiter</see>
                <see>ugen.Normalizer</see>
            </doc>
        </ugen>
        <ugen name="Limiter">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="level" default="1"/>
            <arg name="dur" default="0.01"/>
        </ugen>
        <ugen name="Normalizer">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="level" default="1"/>
            <arg name="dur" default="0.01"/>
        </ugen>

        <ugen name="Amplitude">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="attack" default="0.01"/>
            <arg name="release" default="0.01"/>
        </ugen>
        <ugen name="DetectSilence" sideeffect="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="amp" default="0.0001"/>
            <arg name="dur" default="0.1"/>
            <arg name="doneAction" default="doNothing"/>
        </ugen>

        <ugen name="Hilbert">
            <outputs num="2"/>
            <rate name="audio"/>
            <arg name="in"/>
        </ugen>
        <ugen name="FreqShift">
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="freq" default="0"/>
            <arg name="phase" default="0"/>
        </ugen>
        <ugen name="MoogFF">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="freq" default="200"/>
            <arg name="gain" default="2"/>
            <arg name="reset" default="0"/>
        </ugen>

        <ugen name="BLowPass">
            <rate name="audio" implied="true"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal to be processed.
                </doc>
            </arg>
            <arg name="freq" default="440">
                <doc>
                    cutoff frequency.
                </doc>
            </arg>
            <arg name="rq" default="1">
                <doc>
                    the reciprocal of Q, hence bandwidth / cutoffFreq.
                </doc>
            </arg>
            <doc>
                <text>
                    A 2nd order (12db per oct rolloff) resonant low pass filter UGen.
                    The B equalization suite is based on the Second Order Section (SOS) biquad UGen.

                    Note: Biquad coefficient calculations imply certain amount of CPU overhead. These
                    plugin UGens contain optimizations such that the coefficients get updated only when
                    there has been a change to one of the filter's parameters. This can cause spikes in
                    CPU performance and should be considered when using several of these units.
                </text>
            </doc>
        </ugen>
        <ugen name="BHiPass">
            <rate name="audio" implied="true"/>
            <arg name="in" rate="ugen">
                <doc>
                     input signal to be processed.
                 </doc>
            </arg>
            <arg name="freq" default="440">
                <doc>
                    cutoff frequency.
                </doc>
            </arg>
            <arg name="rq" default="1">
                <doc>
                    the reciprocal of Q, hence bandwidth / cutoffFreq.
                </doc>
            </arg>
            <doc>
                <text>
                    A 2nd order (12db per oct rolloff) resonant high pass filter UGen.
                    The B equalization suite is based on the Second Order Section (SOS) biquad UGen.

                    Note: Biquad coefficient calculations imply certain amount of CPU overhead. These
                    plugin UGens contain optimizations such that the coefficients get updated only when
                    there has been a change to one of the filter's parameters. This can cause spikes in
                    CPU performance and should be considered when using several of these units.
                </text>
            </doc>
        </ugen>
        <ugen name="BBandPass">
            <rate name="audio" implied="true"/>
            <arg name="in" rate="ugen">
                <doc>
                     input signal to be processed.
                 </doc>
            </arg>
            <arg name="freq" default="440">
                <doc>
                    center frequency.
                </doc>
            </arg>
            <arg name="bw" default="1">
                <doc>
                    the bandwidth '''in octaves''' between -3 dB frequencies
                </doc>
            </arg>
            <doc>
                <text>
                    An band pass filter UGen.
                    The B equalization suite is based on the Second Order Section (SOS) biquad UGen.

                    Note: Biquad coefficient calculations imply certain amount of CPU overhead. These
                    plugin UGens contain optimizations such that the coefficients get updated only when
                    there has been a change to one of the filter's parameters. This can cause spikes in
                    CPU performance and should be considered when using several of these units.
                </text>
            </doc>
        </ugen>
        <ugen name="BBandStop">
            <rate name="audio" implied="true"/>
            <arg name="in" rate="ugen">
                <doc>
                     input signal to be processed.
                 </doc>
            </arg>
            <arg name="freq" default="440">
                <doc>
                    center frequency.
                </doc>
            </arg>
            <arg name="bw" default="1">
                <doc>
                    the bandwidth '''in octaves''' between -3 dB frequencies
                </doc>
            </arg>
            <doc>
                <text>
                    An band stop (reject) filter UGen.
                    The B equalization suite is based on the Second Order Section (SOS) biquad UGen.

                    Note: Biquad coefficient calculations imply certain amount of CPU overhead. These
                    plugin UGens contain optimizations such that the coefficients get updated only when
                    there has been a change to one of the filter's parameters. This can cause spikes in
                    CPU performance and should be considered when using several of these units.
                </text>
            </doc>
        </ugen>
        <ugen name="BPeakEQ">
            <rate name="audio" implied="true"/>
            <arg name="in" rate="ugen">
                <doc>
                     input signal to be processed.
                 </doc>
            </arg>
            <arg name="freq" default="440">
                <doc>
                    center frequency.
                </doc>
            </arg>
            <arg name="rq" default="1">
                <doc>
                    the reciprocal of Q, hence bandwidth / cutoffFreq.
                </doc>
            </arg>
            <arg name="gain" default="0">
                <doc>
                    boost/cut at the center frequency (in decibels).
                </doc>
            </arg>
            <doc>
                <text>
                    An parametric equalizer UGen.
                    The B equalization suite is based on the Second Order Section (SOS) biquad UGen.

                    Note: Biquad coefficient calculations imply certain amount of CPU overhead. These
                    plugin UGens contain optimizations such that the coefficients get updated only when
                    there has been a change to one of the filter's parameters. This can cause spikes in
                    CPU performance and should be considered when using several of these units.
                </text>
            </doc>
        </ugen>
        <ugen name="BAllPass">
            <rate name="audio" implied="true"/>
            <arg name="in" rate="ugen">
                <doc>
                     input signal to be processed.
                 </doc>
            </arg>
            <arg name="freq" default="440">
                <doc>
                    cutoff frequency.
                </doc>
            </arg>
            <arg name="rq" default="1">
                <doc>
                    the reciprocal of Q, hence bandwidth / cutoffFreq.
                </doc>
            </arg>
            <doc>
                <text>
                    An all pass filter UGen.
                    The B equalization suite is based on the Second Order Section (SOS) biquad UGen.

                    Note: Biquad coefficient calculations imply certain amount of CPU overhead. These
                    plugin UGens contain optimizations such that the coefficients get updated only when
                    there has been a change to one of the filter's parameters. This can cause spikes in
                    CPU performance and should be considered when using several of these units.
                </text>
            </doc>
        </ugen>
        <ugen name="BLowShelf">
            <rate name="audio" implied="true"/>
            <arg name="in" rate="ugen">
                <doc>
                     input signal to be processed.
                 </doc>
            </arg>
            <arg name="freq" default="440">
                <doc>
                    cutoff frequency.
                </doc>
            </arg>
            <arg name="rs" default="1">
                <doc>
                    the reciprocal of the slope S (Shell boost/cut slope).
                    When `S = 1`, the shelf slope is as steep as it can be and remain monotonically increasing
                    or decreasing gain with frequency.  The shelf slope, in dB/octave, remains proportional to
                    S for all other values for a fixed freq/sample-rate and `gain`.
                </doc>
            </arg>
            <arg name="gain" default="0">
                <doc>
                    boost/cut at the cutoff frequency (in decibels).
                </doc>
            </arg>
            <doc>
                <text>
                    A low shelf equalizer UGen.
                    The B equalization suite is based on the Second Order Section (SOS) biquad UGen.

                    Note: Biquad coefficient calculations imply certain amount of CPU overhead. These
                    plugin UGens contain optimizations such that the coefficients get updated only when
                    there has been a change to one of the filter's parameters. This can cause spikes in
                    CPU performance and should be considered when using several of these units.
                </text>
            </doc>
        </ugen>
        <ugen name="BHiShelf">
            <rate name="audio" implied="true"/>
            <arg name="in" rate="ugen">
                <doc>
                     input signal to be processed.
                 </doc>
            </arg>
            <arg name="freq" default="440">
                <doc>
                    cutoff frequency.
                </doc>
            </arg>
            <arg name="rs" default="1">
                <doc>
                    the reciprocal of the slope S (Shell boost/cut slope).
                    When `S = 1`, the shelf slope is as steep as it can be and remain monotonically increasing
                    or decreasing gain with frequency.  The shelf slope, in dB/octave, remains proportional to
                    S for all other values for a fixed freq/sample-rate and `gain`.
                </doc>
            </arg>
            <arg name="gain" default="0">
                <doc>
                    boost/cut at the cutoff frequency (in decibels).
                </doc>
            </arg>
            <doc>
                <text>
                    A high shelf equalizer UGen.
                    The B equalization suite is based on the Second Order Section (SOS) biquad UGen.

                    Note: Biquad coefficient calculations imply certain amount of CPU overhead. These
                    plugin UGens contain optimizations such that the coefficients get updated only when
                    there has been a change to one of the filter's parameters. This can cause spikes in
                    CPU performance and should be considered when using several of these units.
                </text>
            </doc>
        </ugen>
    </file>

    <file name="GendynUGens">
        <ugen name="Gendy1" random="true">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="ampDist" default="1"/>
            <arg name="durDist" default="1"/>
            <arg name="adParam" default="1"/>
            <arg name="ddParam" default="1"/>
            <arg name="minFreq" default="440"/>
            <arg name="maxFreq" default="660"/>
            <arg name="ampScale" default="0.5"/>
            <arg name="durScale" default="0.5"/>
            <arg name="initCPs" default="12"/>
            <arg name="kNum" default="12"/>
        </ugen>
        <ugen name="Gendy2" random="true">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="ampDist" default="1"/>
            <arg name="durDist" default="1"/>
            <arg name="adParam" default="1"/>
            <arg name="ddParam" default="1"/>
            <arg name="minFreq" default="440"/>
            <arg name="maxFreq" default="660"/>
            <arg name="ampScale" default="0.5"/>
            <arg name="durScale" default="0.5"/>
            <arg name="initCPs" default="12"/>
            <arg name="kNum" default="12"/>
            <arg name="a" default="1.17"/>
            <arg name="c" default="0.31"/>
        </ugen>
        <ugen name="Gendy3" random="true">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="ampDist" default="1"/>
            <arg name="durDist" default="1"/>
            <arg name="adParam" default="1"/>
            <arg name="ddParam" default="1"/>
            <arg name="freq" default="440"/>
            <arg name="ampScale" default="0.5"/>
            <arg name="durScale" default="0.5"/>
            <arg name="initCPs" default="12"/>
            <arg name="kNum" default="12"/>
        </ugen>
    </file>

    <file name="GrainUGens">
        <ugen name="GrainIn" readsbuf="true">
            <rate name="audio" implied="true"/>
            <outputs num="numChannels"/>
            <arg name="numChannels" type="Int" default="1" pos="1"/>
            <arg name="trig" default="0" pos="2"/>
            <arg name="dur" default="1" pos="3"/>
            <arg name="in" pos="0"/>
            <arg name="pan" default="0" pos="4"/>
            <arg name="envBuf" default="-1" pos="5"/>
            <arg name="maxGrains" default="512" pos="6"/>
            <doc warnpos="true"/>
        </ugen>
        <ugen name="GrainSin" readsbuf="true">
            <rate name="audio" implied="true"/>
            <outputs num="numChannels"/>
            <arg name="numChannels" type="Int" default="1"/>
            <arg name="trig" default="0"/>
            <arg name="dur" default="1"/>
            <arg name="freq" default="440"/>
            <arg name="pan" default="0"/>
            <arg name="envBuf" default="-1"/>
            <arg name="maxGrains" default="512"/>
        </ugen>
        <ugen name="GrainFM" readsbuf="true">
            <rate name="audio" implied="true"/>
            <outputs num="numChannels"/>
            <arg name="numChannels" type="Int" default="1"/>
            <arg name="trig" default="0"/>
            <arg name="dur" default="1"/>
            <arg name="carFreq" default="440"/>
            <arg name="modFreq" default="200"/>
            <arg name="index" default="1"/>
            <arg name="pan" default="0"/>
            <arg name="envBuf" default="-1"/>
            <arg name="maxGrains" default="512"/>
        </ugen>
        <ugen name="GrainBuf" readsbuf="true">
            <rate name="audio" implied="true"/>
            <outputs num="numChannels"/>
            <arg name="numChannels" type="Int" default="1" pos="1"/>
            <arg name="trig" default="0" pos="2"/>
            <arg name="dur" default="1" pos="3"/>
            <arg name="buf" pos="0"/>
            <arg name="speed" default="1" pos="4"/>
            <arg name="pos" default="0" pos="5"/>
            <arg name="pan" default="0" pos="6"/>
            <arg name="envBuf" default="-1" pos="7"/>
            <arg name="maxGrains" default="512" pos="8"/>
            <doc warnpos="true"/>
        </ugen>
        <ugen name="Warp1" readsbuf="true">
            <rate name="audio" implied="true"/>
            <outputs num="numChannels"/>
            <arg name="numChannels" type="Int"/>
            <arg name="buf"/>
            <arg name="pos" default="0"/>
            <arg name="speed" default="1"/>
            <arg name="winSize" default="0.2"/>
            <arg name="envBuf" default="-1"/>
            <arg name="overlaps" default="8"/>
            <arg name="winRand" default="0"/>
            <arg name="interp" default="1"/>
        </ugen>
    </file>

    <file name="IOUGens">
        <ugen name="OffsetOut" writesbus="true">
            <outputs num="0"/>
            <rate name="audio" implied="true"/>
            <arg name="bus"/>
            <arg name="in" multi="true" rate="ugen"/>
        </ugen>
        <ugen name="LocalIn">
            <outputs num="numChannels"/>
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="numChannels" type="Int" default="1"/>
        </ugen>
        <ugen name="XOut" writesbus="true">
            <outputs num="0"/>
            <rate name="audio">
                <arg name="in" rate="ugen"/>
            </rate>
            <rate name="control"/>
            <arg name="bus" pos="0"/>
            <arg name="xfade" pos="2"/>
            <arg name="in" multi="true" pos="1"/>
            <doc warnpos="true"/>
        </ugen>

        <!-- TODO: these could well be here, and only the ProxyFactories are manually coded...
        <ugen name="LagControl"/>
        <ugen name="AudioControl"/>
        <ugen name="Control"/>
        <ugen name="TrigControl"/>
        -->

        <ugen name="ReplaceOut" writesbus="true">
            <outputs num="0"/>
            <rate name="audio" implied="true"/>
            <arg name="bus"/>
            <arg name="in" multi="true" rate="ugen"/>
        </ugen>
        <ugen name="Out" writesbus="true">
            <outputs num="0"/>
            <rate name="audio">
                <arg name="in" rate="ugen"/>
            </rate>
            <rate name="control"/>
            <rate name="scalar"/>
            <arg name="bus"/>
            <arg name="in" multi="true"/>
        </ugen>
        <ugen name="LocalOut">
            <outputs num="0"/>
            <rate name="control"/>
            <rate name="audio">
                <arg name="in" rate="ugen"/>
            </rate>
            <arg name="in" multi="true"/>
        </ugen>
        <ugen name="In" readsbus="true">
            <outputs num="numChannels"/>
            <rate name="scalar"/>
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="bus"/>
            <arg name="numChannels" type="Int" default="1"/>
        </ugen>
        <ugen name="LagIn" readsbus="true">
            <outputs num="numChannels"/>
            <rate name="control"/>
            <arg name="bus"/>
            <arg name="numChannels" type="Int" default="1"/>
            <arg name="lag" default="0.1"/>
        </ugen>
        <ugen name="InFeedback" readsbus="true">
            <outputs num="numChannels"/>
            <rate name="audio" implied="true"/>
            <arg name="bus">
                <doc>
                    the index of the audio bus to read in from.
                </doc>
            </arg>
            <arg name="numChannels" type="Int" default="1">
                <doc>
                    the number of channels (i.e. adjacent buses) to read in. Since
                    this is a constant, a change in number of channels of the underlying bus must
                    be reflected by creating different SynthDefs.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen which reads a signal from an audio bus with a current or one cycle old timestamp

                    Audio buses adhere to the concept of a cycle timestamp, which increases for each audio block
                    calculated. When the various output ugens (`Out`, `OffsetOut`, `XOut`) write data to a bus,
                    they mix it with any data from the current cycle, but overwrite any data from the previous cycle.
                    (`ReplaceOut` overwrites all data regardless.) Thus depending on node order and what synths are
                    writing to the bus, the data on a given bus may be from the current cycle or be one cycle old at
                    the time of reading.

                    `In.ar` checks the timestamp of any data it reads in and zeros any data from the previous
                    cycle (for use within that node; the data remains on the bus). This is fine for audio data,
                    as it avoids feedback, but for control data it is useful to be able to read data from any place
                    in the node order. For this reason `In.kr` also reads data that is older than the current cycle.

                    In some cases one might also want to read audio from a node later in the current node order.
                    This can be achieved with `InFeedback`. It reads from the previous cycle, and hence introduces
                    a '''delay''' of one block size, which by default is 64 sample frames (equal to about 1.45 ms
                    at 44.1 kHz sample rate).
                </text>
                <see>ugen.In</see>
                <see>ugen.LocalIn</see>
                <see>ugen.ControlDur</see>
            </doc>
        </ugen>
        <ugen name="InTrig" readsbus="true">
            <outputs num="numChannels"/>
            <rate name="control" implied="true"/>
            <arg name="bus">
                <doc>
                    the index of the control bus to read in from.
                </doc>
            </arg>
            <arg name="numChannels" type="Int" default="1">
                <doc>
                    the number of channels (i.e. adjacent buses) to read in. Since
                    this is a constant, a change in number of channels of the underlying bus must
                    be reflected by creating different SynthDefs.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen which generates a trigger anytime a control bus is set.

                    Any time the bus is "touched" i.e. has its value set (using `"/c_set"` etc.), a single
                    impulse trigger will be generated. Its amplitude is the value that the bus was set to.
                    Note that if a signal is continuously written to that bus, for instance using
                    `Out.kr`, only one initial trigger is generated once that ugen starts writing, but
                    no successive triggers are generated.
                </text>
                <see>ugen.In</see>
            </doc>
        </ugen>
        <!-- TODO:
        <ugen name="SharedOut"/>
        <ugen name="SharedIn"/>
        -->
    </file>

    <file name="KeyboardUGens">
        <ugen name="KeyState">
            <rate name="control" implied="true"/>
            <arg name="keyCode"/>
            <arg name="lo" default="0"/>
            <arg name="hi" default="1"/>
            <arg name="lag" default="0.2"/>
        </ugen>
    </file>

    <file name="LFUGens">
        <ugen name="Vibrato">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="440"/>
            <arg name="beat" default="6"/>
            <arg name="depth" default="0.02"/>
            <arg name="delay" default="0"/>
            <arg name="onset" default="0"/>
            <arg name="beatVar" default="0.04"/>
            <arg name="depthVar" default="0.1"/>
            <arg name="iphase" default="0"/>
        </ugen>
        <ugen name="LFPulse">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="440">
                <doc>
                    oscillator frequency in Hertz
                </doc>
            </arg>
            <arg name="iphase" default="0">
                <doc>
                    initial phase offset in cycles ( `0..1` ). If you think
                    of a buffer of one cycle of the waveform, this is the starting offset
                    into this buffer. Hence, an `iphase` of `0.25` means that you will hear
                    the first impulse after `0.75` periods! If you prefer to specify the
                    perceived delay instead, you could use an `iphase` of `-0.25 + 1` which
                    is more intuitive. Note that the phase is not automatically wrapped
                    into the range of `0..1`, so putting an `iphase` of `-0.25` currently
                    results in a strange initial signal which only stabilizes to the
                    correct behaviour after one period!
                </doc>
            </arg>
            <arg name="width" default="0.5">
                <doc>
                    pulse width duty cycle from zero to one. If you want to
                    specify the width rather in seconds, you can use the formula
                    `width = freq * dur`, e.g. for a single sample impulse use
                    `width = freq * SampleDur.ir`.
                </doc>
            </arg>
            <doc>
                <text>
                    A non-band-limited pulse oscillator UGen.
                    Outputs a high value of one and a low value of zero.
                </text>
                <see>ugen.Pulse</see>
            </doc>
        </ugen>
        <ugen name="LFSaw">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="440">
                <doc>
                    oscillator frequency in Hertz
                </doc>
            </arg>
            <arg name="iphase" default="0">
                <doc>
                    initial phase offset. For efficiency reasons this is a
                    value ranging from 0 to 2. Note that a phase of zero (default) means
                    the wave starts at 0 and rises to +1 before jumping down to -1. Use
                    a phase of 1 to have the wave start at -1.
                </doc>
            </arg>
            <doc>
                <text>
                    A sawtooth oscillator UGen. The oscillator is creating an aliased sawtooth,
                    that is it does not use band-limiting. For a band-limited version use
                    `Saw` instead. The signal range is -1 to +1.
                </text>
                <see>ugen.Saw</see>
            </doc>
        </ugen>
        <ugen name="LFPar">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="440"/>
            <arg name="iphase" default="0"/>
        </ugen>
        <ugen name="LFCub">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="440"/>
            <arg name="iphase" default="0"/>
        </ugen>
        <ugen name="LFTri">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="440"/>
            <arg name="iphase" default="0"/>
        </ugen>
        <ugen name="LFGauss">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="dur" default="1"/>
            <arg name="width" default="0.1"/>
            <arg name="iphase" default="0"/>
            <arg name="loop" default="1"/>
            <arg name="doneAction" default="doNothing"/>
        </ugen>
        <ugen name="Impulse">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="440"/>
            <arg name="phase" default="0"/>
        </ugen>
        <ugen name="VarSaw">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="440"/>
            <arg name="iphase" default="0"/>
            <arg name="width" default="0.5"/>
        </ugen>
        <ugen name="SyncSaw">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="syncFreq" default="440"/>
            <arg name="sawFreq" default="440"/>
        </ugen>
        <ugen name="K2A">
            <rate name="audio" implied="true"/>
            <arg name="in"/>
        </ugen>
        <ugen name="A2K">
            <rate name="control" implied="true"/>
            <arg name="in"/>
        </ugen>
        <ugen name="T2K">
            <rate name="control" implied="true"/>
            <arg name="in"/>
        </ugen>
        <ugen name="T2A">
            <rate name="audio" implied="true"/>
            <arg name="in"/>
        </ugen>
        <ugen name="DC">
            <rate name="control"/>
            <rate name="audio"/>
            <outputs num="in"/>
            <arg name="in" multi="true"/>
        </ugen>
        <ugen name="Silent">
            <rate name="audio" implied="true"/>
            <outputs num="numChannels"/>
            <arg name="numChannels" type="Int" default="1"/>
        </ugen>
        <ugen name="Line" sideeffect="true" doneflag="true">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="start" default="0">
                <doc>
                    Starting value. Note that this is read only once at initialization
                </doc>
            </arg>
            <arg name="end" default="1">
                <doc>
                    Ending value. Note that this is read only once at initialization
                </doc>
            </arg>
            <arg name="dur" default="1">
                <doc>
                    Duration in seconds. Note that this is read only once at initialization
                </doc>
            </arg>
            <arg name="doneAction" default="doNothing">
                <doc>
                    A done-action that is evaluated when the Line has reached the end value after the
                    given duration
                </doc>
            </arg>
            <doc>
                <text>
                    A line generator UGen that moves from a start value to the end value in a given duration.
                </text>
                <see>ugen.XLine</see>
                <see>ugen.EnvGen</see>
                <see>ugen.Ramp</see>
            </doc>
        </ugen>
        <ugen name="XLine" sideeffect="true" doneflag="true">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="start" default="1"/>
            <arg name="end" default="2"/>
            <arg name="dur" default="1"/>
            <arg name="doneAction" default="doNothing"/>
        </ugen>

        <ugen name="Wrap">
            <rate name="scalar"/>
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="lo" default="0"/>
            <arg name="hi" default="1"/>
        </ugen>
        <ugen name="Fold">
            <rate name="scalar"/>
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="lo" default="0"/>
            <arg name="hi" default="1"/>
        </ugen>
        <ugen name="Clip">
            <rate name="scalar"/>
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="lo" default="0"/>
            <arg name="hi" default="1"/>
        </ugen>
        <!-- this should exist according to plugin sources...
        <ugen name="Unwrap"/>
        -->
        <ugen name="AmpComp">
            <rate name="scalar"/>
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="60.midicps"/>
            <arg name="root" default="60.midicps"/>
            <arg name="expon" default="0.3333"/>
        </ugen>
        <ugen name="AmpCompA">
            <rate name="scalar"/>
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="1000"/>
            <arg name="root" default="0"/>
            <arg name="minAmp" default="0.32"/>
            <arg name="rootAmp" default="1"/>
        </ugen>
        <ugen name="InRange">
            <rate name="scalar"/>
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="lo" default="0"/>
            <arg name="hi" default="1"/>
        </ugen>
        <ugen name="InRect">
            <rate name="scalar"/>
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="x"/>
            <arg name="y"/>
            <arg name="left" default="0"/>
            <arg name="top" default="0"/>
            <arg name="right" default="1"/>
            <arg name="bottom" default="1"/>
        </ugen>
        <ugen name="LinExp">
            <rate name="scalar"/>
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="srcLo" default="0"/>
            <arg name="srcHi" default="1"/>
            <arg name="dstLo" default="1"/>
            <arg name="dstHi" default="2"/>
        </ugen>
        <ugen name="LinLin">
            <rate name="scalar"/>
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="srcLo" default="0"/>
            <arg name="srcHi" default="1"/>
            <arg name="dstLo" default="0"/>
            <arg name="dstHi" default="1"/>
        </ugen>
        <ugen name="EnvGen">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="gate" default="1" pos="1"/>
            <arg name="levelScale" default="1" pos="2"/>
            <arg name="levelBias" default="0" pos="3"/>
            <arg name="timeScale" default="1" pos="4"/>
            <arg name="doneAction" default="doNothing" pos="5"/>
            <arg name="envelope" multi="true" pos="0"/>
        </ugen>
        <ugen name="Linen">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="gate" default="1"/>
            <arg name="attack" default="0.01"/>
            <arg name="sustain" default="1"/>
            <arg name="release" default="1"/>
            <arg name="doneAction" default="doNothing"/>
        </ugen>
        <ugen name="IEnvGen">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="index" default="1" pos="1"/>
            <arg name="envelope" multi="true" pos="0"/>
        </ugen>
    </file>

    <file name="MachineListening">
        <ugen name="BeatTrack" readsfft="true">
            <rate name="control" implied="true"/>
            <arg name="chain">
                <doc>
                    the output (buffer) of an FFT UGen which transforms the audio input to track.
                    The expected size of FFT is 1024 for 44100 and 48000 sampling rate, and 2048 for double those.
                    No other sampling rates are supported.
                </doc>
            </arg>
            <arg name="lock" default="0">
                <doc>
                    If this argument is greater than 0.5, the tracker will lock at its current
                    periodicity and continue from the current phase. Whilst it updates the model's phase and period,
                    this is not reflected in the output until lock goes back below 0.5. Can be control-rate modulated.
                </doc>
            </arg>
            <doc>
                <text>
                    An autocorrelation based beat tracker UGen.

                    The underlying model assumes 4/4, but it should work on any isochronous beat structure, though
                    there are biases to 100-120 bpm; a fast 7/8 may not be tracked in that sense. There are '''four''' control-rate
                    outputs, being ticks at quarter, eighth and sixteenth level from the determined beat, and the current
                    detected tempo. Note that the sixteenth note output won't necessarily make much sense if the music
                    being tracked has swing; it is provided just as a convenience.

                    This beat tracker determines the beat, biased to the midtempo range by weighting functions. It does not
                    determine the measure level, only a tactus. It is also slow reacting, using a 6 second temporal window for
                    its autocorrelation maneouvres. Don't expect human musician level predictive tracking.

                    On the other hand, it is tireless, relatively general (though obviously best at transient 4/4 heavy material
                    without much expressive tempo variation), and can form the basis of computer processing that is decidedly
                    faster than human.

                    '''Warning''': This UGen only works properly at 44.1 or 48.0 kHz.
                </text>
            </doc>
        </ugen>
        <ugen name="Loudness" readsfft="true">
            <rate name="control" implied="true"/>
            <arg name="chain">
                <doc>
                    the output (buffer) of an FFT UGen which transforms the audio input to track.
                    The FFT size should be 1024 for 44.1 and 48 kHz sampling rate, and 2048 for 88.2 and 96 kHz sampling rate.
                </doc>
            </arg>
            <arg name="smask" default="0.25">
                <doc>
                    Spectral masking parameter: lower bins mask higher bin power within ERB bands, with a power
                    falloff (leaky integration multiplier) of smask per bin. Can be control-rate modulated.
                </doc>
            </arg>
            <arg name="tmask" default="1">
                <doc>
                    Temporal masking parameter: the phon level let through in an ERB band is the maximum of
                    the new measurement, and the previous minus tmask phons. Can be control-rate modulated.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen for the extraction of instantaneous loudness.
                    A perceptual loudness function which outputs loudness in sones; this is a variant of an MP3 perceptual model,
                    summing excitation in ERB bands. It models simple spectral and temporal masking, with equal loudness contour
                    correction in ERB bands to obtain phons (relative dB), then a phon to sone transform. The final output is
                    typically in the range of 0 to 64 sones, though higher values can occur with specific synthesised stimuli.
                </text>
            </doc>
        </ugen>
        <ugen name="KeyTrack" readsfft="true">
            <rate name="control" implied="true"/>
            <arg name="chain">
                <doc>
                    the output (buffer) of an FFT UGen which transforms the audio input to track.
                    For the FFT chain, with a standard hop of half FFT size, the FFT size should be
                    4096 at 44.1 or 48 kHz and 8192 at 88.2 or 96 kHz sampling rate.
                </doc>
            </arg>
            <arg name="keyDecay" default="2">
                <doc>
                    Number of seconds for the influence of a window on the final key decision to decay by
                    40dB (to 0.01 its original value). Can be control-rate modulated.
                </doc>
            </arg>
            <arg name="chromaLeak" default="0.5">
                <doc>
                    Each frame, the chroma values are set to the previous value multiplied by the chromadecay.
                    0.0 will start each frame afresh with no memory. Can be control-rate modulated.
                </doc>
            </arg>
            <doc>
                <text>
                    A (12TET major/minor) key tracker UGen.
                    It is based on a pitch class profile of energy across FFT bins and matching this to templates for major and
                    minor scales in all transpositions. It assumes a 440 Hz concert A reference. Output is 0-11  C major to B major,
                    12-23 C minor to B minor.
                </text>
            </doc>
        </ugen>
        <ugen name="MFCC" readsfft="true">
            <rate name="control" implied="true"/>
            <outputs num="numCoeffs"/>
            <arg name="chain">
                <doc>
                    the output (buffer) of an FFT UGen which transforms the audio input to track.
                    For the FFT chain, with a standard hop of half FFT size, the FFT size should be
                    1024 at 44.1 or 48 kHz and 2048 at 88.2 or 96 kHz sampling rate.
                </doc>
            </arg>
            <arg name="numCoeffs" type="Int" default="13">
                <doc>
                    the number of coefficients, defaults to 13, maximum of 42; more efficient to use less of course!
                    Since this number determines the number of output channels of the UGen, it has to be an `Int`.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen for extracting mel frequency cepstral coefficients.
                    It generates a set of MFCCs; these are obtained from a band-based frequency representation (using the Mel scale
                    by default), and then a discrete cosine transform (DCT). The DCT is an efficient approximation for principal
                    components analysis, so that it allows a compression, or reduction of dimensionality, of the data, in this case
                    reducing 42 band readings to a smaller set of MFCCs. A small number of features (the coefficients) end up
                    describing the spectrum. The MFCCs are commonly used as timbral descriptors.

                    The output values are somewhat normalised for the range 0.0 to 1.0, but there are no guarantees on exact
                    conformance to this. Commonly, the first coefficient will be the highest value.
                    The number of output channels corresponds to the number of coefficients specified.
                    Technical note: The 0th coefficient is not generated as it consists of multiplying all bands by 1 and summing
                </text>
            </doc>
        </ugen>
        <ugen name="Onsets" readsfft="true">
            <rate name="control" implied="true"/>
            <arg name="chain">
                <doc>
                    the output (buffer) of an FFT UGen which transforms the audio input to track.
                    For the FFT chain, you should typically use a frame size of 512 or 1024 (at 44.1 kHz sampling rate)
                    and 50% hop size (which is the default setting in SC). For different sampling rates choose an FFT
                    size to cover a similar time-span (around 10 to 20 ms).
                </doc>
            </arg>
            <arg name="thresh" default="0.5">
                <doc>
                    the detection threshold, typically between 0 and 1, although in rare cases you may
                    find values outside this range useful
                </doc>
            </arg>
            <arg name="fun" default="3">
                <doc>
                    index of a function to be used to analyse the signal. See main paragraph for possible
                    values (usually can be left to default).
                </doc>
            </arg>
            <arg name="decay" default="1">
                <doc>
                    (advanced setting) Specifies the time (in seconds) for the normalisation to "forget"
                    about a recent onset. If you find too much re-triggering (e.g. as a note dies away unevenly) then
                    you might wish to increase this value. Not used with "mkl".
                </doc>
            </arg>
            <arg name="noiseFloor" default="0.1">
                <doc>
                    (advanced setting) This is a lower limit, connected to the idea of how quiet the
                    sound is expected to get without becoming indistinguishable from noise. For some cleanly-recorded
                    classical music with wide dynamic variations, it was found helpful to go down as far as 1e-6.
                    Not used with "mkl".
                </doc>
            </arg>
            <arg name="minGap" default="10">
                <doc>
                    (advanced setting) Specifies a minimum gap (in FFT frames) between onset detections,
                    a brute-force way to prevent too many doubled detections.
                </doc>
            </arg>
            <arg name="medianSpan" default="11">
                <doc>
                    (advanced setting) Specifies the size (in FFT frames) of the median window used for
                    smoothing the detection function before triggering.
                </doc>
            </arg>
            <arg name="whType" default="1">
                <doc>
                    (advanced setting) ?
                </doc>
            </arg>
            <arg name="raw" default="0">
                <doc>
                    (advanced setting) ?
                </doc>
            </arg>
            <doc>
                <text>
                    An onset detecting UGen for musical audio signals.
                    It detects the beginning of notes/drumbeats/etc. Outputs a control-rate trigger signal which is 1
                    when an onset is detected, and 0 otherwise.

                    The onset detection should work well for a general range of monophonic and polyphonic audio signals.
                    The onset detection is purely based on signal analysis and does not make use of any "top-down" inferences
                    such as tempo.

                    There are different functions available for the analysis:

                    - 0 "power" -- generally OK, good for percussive input, and also very efficient
                    - 1 "magsum" -- generally OK, good for percussive input, and also very efficient
                    - 2 "complex" -- performs generally very well, but more CPU-intensive
                    - 3 "rcomplex" (default) -- performs generally very well, and slightly more efficient than "complex"
                    - 4 "phase" -- generally good, especially for tonal input, medium efficiency
                    - 5 "wphase" -- generally very good, especially for tonal input, medium efficiency
                    - 6 "mkl" -- generally very good, medium efficiency, pretty different from the other methods

                    The differences aren't large, so it is recommended you stick with the default "rcomplex" unless you
                    find specific problems with it. Then maybe try "wphase". The "mkl" type is a bit different from the
                    others so maybe try that too. They all have slightly different characteristics, and in tests perform
                    at a similar quality level.
                </text>
            </doc>
        </ugen>

        <ugen name="BeatTrack2" readsfft="true">
            <rate name="control" implied="true"/>
            <outputs num="6"/>
            <arg name="bus">
                <doc>
                    index of a control bus to read from. the number of channels of that bus are expected
                    to match the `numChannels` argument. To track a particular audio signal, analyse it first
                    into `numChannels` features, that is onset-detection-triggers, as generated by `Onsets`, and write the
                    trigger-output to this control bus.
                </doc>
            </arg>
            <arg name="numChannels"> <!-- Int? -->
                <doc>
                    (scalar) How many features (ie how many control bus channels) are provided
                </doc>
            </arg>
            <arg name="winSize" default="2">
                <doc>
                    (scalar) Size of the temporal window desired (2.0 to 3.0 seconds models the human
                    temporal window). You might use longer values for stability of estimate at the expense of reactiveness.
                </doc>
            </arg>
            <arg name="phaseSpacing" default="0.02">
                <doc>
                    (scalar) Relates to how many different phases to test. At the default of 0.02 seconds,
                    50 different phases spaced by those 0.02 seconds would be tried out for 60bpm; 16 would be trialed for 180 bpm.
                    Larger phaseSpacing means more tests and more CPU cost.
                </doc>
            </arg>
            <arg name="lock" default="0">
                <doc>
                    If this argument is greater than 0.5, the tracker will lock at its current periodicity
                    and continue from the current phase. Whilst it updates the model's phase and period, this is not reflected
                    in the output until lock goes back below 0.5. Can be control-rate modulated.
                </doc>
            </arg>
            <arg name="weighting" default="-2.1">
                <doc>
                    (scalar) Use (-2.5) for flat weighting of tempi, (-1.5) for compensation weighting based
                    on the number of events tested (because different periods allow different numbers of events within the
                    temporal window). If an integer from 0 upwards is given, this is specifying the ID of a buffer containing
                    120 frames which represent individual tempo weights; tempi go from 60 to 179 bpm in steps of one bpm, so
                    you make sure the buffer has 120 frames.
                </doc>
            </arg>
            <doc>
                <text>
                    A template matching beat tracker UGen.
                    This beat tracker is based on exhaustively testing particular template patterns against feature streams;
                    the testing takes place every 0.5 seconds. The two basic templates are a straight (groove=0) and a swung
                    triplet (groove=1) pattern of 16th notes; this pattern is tried out at scalings corresponding to the tempi
                    from 60 to 180 bpm. This is the cross-corellation method of beat tracking. A majority vote is taken on the
                    best tempo detected, but this must be confirmed by a consistency check after a phase estimate. Such a
                    consistency check helps to avoid wild fluctuating estimates, but is at the expense of an additional half
                    second delay. The latency of the beat tracker with default settings is thus at least 2.5 seconds; because
                    of block-based amortisation of calculation, it is actually around 2.8 seconds latency for a 2.0 second
                    temporal window.

                    This beat tracker is designed to be flexible for user needs; you can try out different window sizes, tempo
                    weights and combinations of features. However, there are no guarantees on stability and effectiveness, and you
                    will need to explore such parameters for a particular situation.

                    The UGen has '''six outputs''' corresponding to beat-tick, eighth-tick, groove-tick, tempo, phase, and groove.
                    '''Warning''': it reads from input control bus instead of taking a regular control input signal as its first
                    argument!
                </text>
            </doc>
        </ugen>

        <ugen name="SpecFlatness" readsfft="true">
            <rate name="control" implied="true"/>
            <arg name="chain">
                <doc>
                    the fft signal (buffer) to analyze
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen to measure spectral flatness.
                    Given an FFT chain this calculates the Spectral Flatness measure, defined as a power spectrum's geometric
                    mean divided by its arithmetic mean. This gives a measure which ranges from approx 0 for a pure sinusoid,
                    to approx 1 for white noise.

                    The measure is calculated linearly. For some applications you may wish to convert the value to a decibel
                    scale. '''Note''' that this UGen may output NaN when the input is zero (probably due to division by zero).
                    In that case, `CheckBadValues` can be used to prevent further problems.
                </text>
                <see>ugen.CheckBadValues</see>
            </doc>
        </ugen>
        <ugen name="SpecPcile" readsfft="true">
            <rate name="control" implied="true"/>
            <arg name="chain">
                <doc>
                    the fft signal (buffer) to analyze
                </doc>
            </arg>
            <arg name="percent" default="0.5">
                <doc>
                    the percentage between 0.0 (0%) and 1.0 (100%)
                </doc>
            </arg>
            <arg name="interp" default="0">
                <doc>
                    specifies whether interpolation should be used to try and make the percentile
                    frequency estimate more accurate, at the cost of a little higher CPU usage. Set it to 1 to enable this.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen to find the percentile of a signal's magnitude spectrum.
                    Given an FFT chain this calculates the cumulative distribution of the frequency spectrum, and outputs
                    the frequency value which corresponds to the desired percentile. For example, to find the frequency at
                    which 90% of the spectral energy lies below that frequency, you want the 90-percentile, which means
                    the value of `percent` should be 0.9. The 90-percentile or 95-percentile is often used as a measure of
                    spectral roll-off.
                </text>
            </doc>
        </ugen>
        <ugen name="SpecCentroid" readsfft="true">
            <rate name="control" implied="true"/>
            <arg name="chain">
                <doc>
                    the fft signal (buffer) to analyze
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen to measure the spectral centroid.
                    Given an FFT chain, this measures the spectral centroid, which is the weighted mean frequency, or
                    the "centre of mass" of the spectrum. (DC is ignored.) This can be a useful indicator of the perceptual
                    brightness of a signal.

                    Note that the output frequency is pretty close to the correct value when feeding in a
                    sine signal, but the estimate is usually too high when using for example filtered noise.
                    In that case, you will get better results using `SpecPcile` at 50%.
                </text>
                <see>ugen.SpecPcile</see>
            </doc>
        </ugen>
    </file>

    <file name="MouseUGens">
        <ugen name="MouseX">
            <rate name="control" implied="true"/>
            <arg name="lo" default="0"/>
            <arg name="hi" default="1"/>
            <arg name="warp" default="0"/>
            <arg name="lag" default="0.2"/>
        </ugen>
        <ugen name="MouseY">
            <rate name="control" implied="true"/>
            <arg name="lo" default="0"/>
            <arg name="hi" default="1"/>
            <arg name="warp" default="0"/>
            <arg name="lag" default="0.2"/>
        </ugen>
        <ugen name="MouseButton">
            <rate name="control" implied="true"/>
            <arg name="lo" default="0"/>
            <arg name="hi" default="1"/>
            <arg name="lag" default="0.2"/>
        </ugen>
    </file>

    <file name="NoiseUGens">
        <ugen name="WhiteNoise" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="mul" default="1" expandbin="*"/>
        </ugen>
        <ugen name="GrayNoise" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="mul" default="1" expandbin="*"/>
        </ugen>
        <ugen name="ClipNoise" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="mul" default="1" expandbin="*"/>
        </ugen>
        <ugen name="PinkNoise" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="mul" default="1" expandbin="*"/>
        </ugen>
        <ugen name="BrownNoise" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="mul" default="1" expandbin="*"/>
        </ugen>
        <ugen name="Dust" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="density" default="1">
                <doc>
                    the average number of impulses per second
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen generating random impulses with values ranging from
                    `0` to `+1`. The pulse duration is one sample for audio-rate
                    and one block for control-rate operation.
                </text>
                <see>ugen.Dust2</see>
                <see>ugen.TRand</see>
            </doc>
        </ugen>
        <ugen name="Dust2" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="density" default="1">
                <doc>
                    the average number of impulses per second
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen generating random impulses with values ranging from
                    `-1` to `+1`. The pulse duration is one sample for audio-rate
                    and one block for control-rate operation.
                </text>
                <see>ugen.Dust</see>
                <see>ugen.TRand</see>
            </doc>
        </ugen>
        <ugen name="Crackle">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="chaos" default="1.5"/>
        </ugen>
        <ugen name="Logistic">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="chaos" default="3"/>
            <arg name="freq" default="1000"/>
            <arg name="init" default="0.5"/>
        </ugen>
        <ugen name="Hasher">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
        </ugen>
        <ugen name="MantissaMask">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="bits" default="3"/>
        </ugen>
        <ugen name="LFClipNoise" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="500"/>
        </ugen>
        <ugen name="LFNoise0" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="500"/>
        </ugen>
        <ugen name="LFNoise1" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="500"/>
        </ugen>
        <ugen name="LFNoise2" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="500"/>
        </ugen>
        <ugen name="Rand" random="true">
            <rate name="scalar" implied="true" method="apply"/>
            <arg name="lo" default="0"/>
            <arg name="hi" default="1"/>
        </ugen>
        <ugen name="IRand" random="true">
            <rate name="scalar" implied="true" method="apply"/>
            <arg name="lo" default="0"/>
            <arg name="hi" default="127"/>
        </ugen>
        <ugen name="TRand" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="lo" default="0"/>
            <arg name="hi" default="1"/>
            <arg name="trig"/>
        </ugen>
        <ugen name="TExpRand" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="lo" default="0.01"/>
            <arg name="hi" default="1.0"/>
            <arg name="trig"/>
        </ugen>
        <ugen name="TIRand" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="lo" default="0"/>
            <arg name="hi" default="127"/>
            <arg name="trig"/>
        </ugen>
        <ugen name="NRand" random="true">
            <rate name="scalar" implied="true" method="apply"/>
            <arg name="lo" default="0"/>
            <arg name="hi" default="127"/>
            <arg name="n" default="0"/>
        </ugen>
        <ugen name="LinRand" random="true">
            <rate name="scalar" implied="true" method="apply"/>
            <arg name="lo" default="0"/>
            <arg name="hi" default="127"/>
            <arg name="minMax" default="0"/>
        </ugen>
        <ugen name="ExpRand" random="true">
            <rate name="scalar" implied="true" method="apply"/>
            <arg name="lo" default="0.01"/>
            <arg name="hi" default="1.0"/>
        </ugen>
        <ugen name="CoinGate" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="prob" default="0.5" pos="1"/>
            <arg name="in" pos="0"/>
            <doc warnpos="true"/>
        </ugen>
        <ugen name="RandSeed" sideeffect="true">
            <rate name="scalar"/>
            <rate name="control"/>
            <arg name="trig" default="1"/>
            <arg name="seed" default="56789"/>
        </ugen>
        <ugen name="RandID" sideeffect="true">
            <rate name="scalar"/>
            <rate name="control"/>
            <arg name="id" default="0"/>
        </ugen>
    </file>

    <file name="OSCUGens">
        <ugen name="DegreeToKey" readsbuf="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in"/>
            <arg name="octave" default="12"/>
        </ugen>
        <ugen name="Select">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="index">
                <doc>
                    an index signal into the channels of the `multi` argument. The index
                    is automatically clipped to lie between `0` and `multi.numOutputs - 1`. The index
                    is truncated to its integer part (not rounded), hence using for instance an
                    index of `0.9` will still be interpreted as index `0`.
                </doc>
            </arg>
            <arg name="in" multi="true">
                <doc>
                    a graph element which is composed of the channels to be indexed.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen which selects among a sequence of inputs, according to an index signal.
                    Note that, although only one signal of the `multi` input is let through at
                    a time, sill all ugens are continuously running.
                </text>
                <see>ugen.TWindex</see>
            </doc>
        </ugen>
        <ugen name="TWindex">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="trig">
                <doc>
                    the trigger used to calculate a new index. a trigger occurs when passing
                    from non-positive to positive
                </doc>
            </arg>
            <arg name="prob">
                <doc>
                    a multi-channel graph element, where the output channels correspond to
                    to the probabilites of their respective indices being chosen.
                </doc>
            </arg>
            <arg name="normalize" default="0">
                <doc>
                    `0` if the seq argument already sums up to 1.0 and thus doesn't need
                    normalization, `1` if the sum is not guaranteed to be 1.0 and thus the ugen is asked
                    to provide the normalization.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen providing a probability-weighted index into a sequence upon receiving a trigger.

                    When triggered, returns a random index value based the values of the channels of the
                    `prob` argument functioning as probabilities. The index is zero based, hence goes from
                    `0` to `prob.numOutputs - 1`.

                    By default the sequence of probabilities should sum to 1.0, however for convenience, this
                    can be achieved by the ugen when the `normalize` flag is set to 1 (less efficient).
                </text>
                <see>ugen.Select</see>
            </doc>
        </ugen>
        <ugen name="Index" readsbuf="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in" default="0"/>
        </ugen>
        <!-- this should exist according to plugin sources...
        <ugen name="FoldIndex"/>
        -->
        <ugen name="WrapIndex" readsbuf="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in" default="0"/>
        </ugen>
        <ugen name="IndexInBetween" readsbuf="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in" default="0"/>
        </ugen>
        <ugen name="DetectIndex" readsbuf="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in" default="0"/>
        </ugen>
        <ugen name="Shaper" readsbuf="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in" default="0"/>
        </ugen>
        <!-- this should exist according to plugin sources...
        <ugen name="SigOsc"/>
        -->
        <ugen name="FSinOsc">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="freq" default="440"/>
            <arg name="iphase" default="0"/>
        </ugen>
        <ugen name="SinOsc">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="freq" default="440">
                <doc>
                    frequency in Hertz
                </doc>
            </arg>
            <arg name="phase" default="0">
                <doc>
                    phase offset or modulator in radians
                </doc>
            </arg>
            <doc>
                <text>
                    A Sinusoidal (sine tone) oscillator UGen.
                    This is the same as `Osc` except that it uses a built-in interpolating sine table of 8192 entries.
                </text>
                <see>ugen.Osc</see>
                <see>ugen.FSinOsc</see>
            </doc>
        </ugen>
        <ugen name="SinOscFB">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="freq" default="440"/>
            <arg name="feedback" default="0"/>
        </ugen>
        <ugen name="VOsc" readsbuf="true">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="bufPos"/>
            <arg name="freq" default="440"/>
            <arg name="phase" default="0"/>
        </ugen>
        <ugen name="VOsc3" readsbuf="true">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="bufPos"/>
            <arg name="freq1" default="110"/>
            <arg name="freq2" default="220"/>
            <arg name="freq3" default="440"/>
        </ugen>
        <ugen name="Osc" readsbuf="true">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="buf"/>
            <arg name="freq" default="440"/>
            <arg name="phase" default="0"/>
        </ugen>
        <ugen name="OscN" readsbuf="true">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="buf"/>
            <arg name="freq" default="440"/>
            <arg name="phase" default="0"/>
        </ugen>
        <ugen name="COsc" readsbuf="true">
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="freq" default="440"/>
            <arg name="beats" default="0.5"/>
        </ugen>
        <ugen name="Formant">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="fundFreq" default="440"/>
            <arg name="formFreq" default="1760"/>
            <arg name="bw" default="880"/>
        </ugen>
        <ugen name="Blip">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="440"/>
            <arg name="numHarm" default="200"/>
        </ugen>
        <ugen name="Saw">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="440"/>
        </ugen>
        <ugen name="Pulse">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="440"/>
            <arg name="width" default="0.5"/>
        </ugen>

        <!-- TODO:
        <ugen name="Klang"/>
        <ugen name="Klank"/>
        -->
    </file>

    <file name="PanUGens">
        <ugen name="Pan2">
            <rate name="control"/>
            <rate name="audio">
                <arg name="in" rate="ugen"/>
            </rate>
            <outputs num="2"/>
            <arg name="in"/>
            <arg name="pos" default="0"/>
            <arg name="level" default="1"/>
        </ugen>
        <ugen name="Pan4">
            <rate name="control"/>
            <rate name="audio">
                <arg name="in" rate="ugen"/>
            </rate>
            <outputs num="4"/>
            <arg name="in"/>
            <arg name="xpos" default="0"/>
            <arg name="ypos" default="0"/>
            <arg name="level" default="1"/>
        </ugen>
        <ugen name="LinPan2">
            <rate name="control"/>
            <rate name="audio">
                <arg name="in" rate="ugen"/>
            </rate>
            <outputs num="2"/>
            <arg name="in"/>
            <arg name="pos" default="0"/>
            <arg name="level" default="1"/>
        </ugen>
        <ugen name="Balance2">
            <rate name="control"/>
            <rate name="audio">
                <arg name="left" rate="ugen"/>
                <arg name="right" rate="ugen"/>
            </rate>
            <outputs num="2"/>
            <arg name="left"/>
            <arg name="right"/>
            <arg name="pos" default="0"/>
            <arg name="level" default="1"/>
        </ugen>
        <ugen name="Rotate2">
            <rate name="control"/>
            <rate name="audio">
                <arg name="left" rate="ugen"/>
                <arg name="right" rate="ugen"/>
            </rate>
            <outputs num="2"/>
            <arg name="x"/>
            <arg name="y"/>
            <arg name="pos" default="0"/>
        </ugen>
        <ugen name="XFade2">
            <rate name="control">
                <arg name="inB" default="0"/>
            </rate>
            <rate name="audio">
                <arg name="inA" rate="ugen"/>
                <!-- DC.ar(0) and K2A.ar(0) take about the same amount of CPU,
                  where the latter is favorable as it is a singleout ugen.
                  In contrast, Silent.ar takes about 20% more CPU (measured 07-jan-10) -->
                <arg name="inB" rate="ugen" default="K2A.ar(0)"/>
            </rate>
            <arg name="inA">
                <doc>
                    The first input signal
                </doc>
            </arg>
            <arg name="inB">
                <doc>
                    The second input signal
                </doc>
            </arg>
            <arg name="pan" default="0">
                <doc>
                    the xfade position from `-1` (only input A audible) to
                    `+1` (only input B audible)
                </doc>
            </arg>
            <arg name="level" default="1">
                <doc>
                    An overall amplitude multiplier that is applied to the output signal
                </doc>
            </arg>
            <doc>
                <text>
                    An equal power two channel cross fading UGen.
                </text>
                <see>ugen.LinXFade2</see>
            </doc>
        </ugen>
        <ugen name="LinXFade2">
            <rate name="control">
                <arg name="inB" default="0"/>
            </rate>
            <rate name="audio">
                <arg name="inA" rate="ugen"/>
                <!-- DC.ar(0) and K2A.ar(0) take about the same amount of CPU,
                  where the latter is favorable as it is a singleout ugen.
                  In contrast, Silent.ar takes about 20% more CPU (measured 07-jan-10) -->
                <arg name="inB" rate="ugen" default="K2A.ar(0)"/>
            </rate>
            <arg name="inA">
                <doc>
                    The first input signal
                </doc>
            </arg>
            <arg name="inB">
                <doc>
                    The second input signal
                </doc>
            </arg>
            <arg name="pan" default="0">
                <doc>
                    the xfade position from `-1` (only input A audible) to
                    `+1` (only input B audible)
                </doc>
            </arg>
            <arg name="level" default="1">
                <doc>
                    An overall amplitude multiplier that is applied to the output signal
                </doc>
            </arg>
            <doc>
                <text>
                    An linear two channel cross fading UGen.
                </text>
                <see>ugen.LinXFade2</see>
            </doc>
        </ugen>
        <ugen name="PanB">
            <rate name="control"/>
            <rate name="audio">
                <arg name="in" rate="ugen"/>
            </rate>
            <outputs num="4"/>
            <arg name="in"/>
            <arg name="azimuth" default="0"/>
            <arg name="elevation" default="0"/>
            <arg name="level" default="1"/>
        </ugen>
        <ugen name="PanB2">
            <rate name="control"/>
            <rate name="audio">
                <arg name="in" rate="ugen"/>
            </rate>
            <outputs num="3"/>
            <arg name="in"/>
            <arg name="azimuth" default="0"/>
            <arg name="level" default="1"/>
        </ugen>
        <ugen name="BiPanB2">
            <rate name="control"/>
            <rate name="audio">
                <arg name="inA" rate="ugen"/>
                <arg name="inB" rate="ugen"/>
            </rate>
            <outputs num="3"/>
            <arg name="inA"/>
            <arg name="inB"/>
            <arg name="azimuth" default="0"/>
            <arg name="level" default="1"/>
        </ugen>
        <ugen name="PanAz">
            <rate name="control"/>
            <rate name="audio">
                <arg name="in" rate="ugen"/>
            </rate>
            <outputs num="numChannels"/>
            <arg name="numChannels" type="Int">
                <doc>
                    the number of output channels
                </doc>
            </arg>
            <arg name="in">
                <doc>
                    the input signal
                </doc>
            </arg>
            <arg name="pos" default="0">
                <doc>
                    the pan position. Channels are evenly spaced over a cyclic period of 2.0.
                    the output channel position is `pos / 2 * numChannels + orient`. Thus, assuming an `orient`
                    of `0.0`, and `numChannels` being for example `3`, a `pos` of `0*2.0/3 == 0.0` corresponds to the first
                    output channel, a `pos` of `1*2.0/3` corresponds to the second output channel,
                    a `pos` of `2*2.0/3=4.0/3` corresponds to the third and last output channel, and
                    a `pos` of `3*2.0/3=2.0` completes the circle and wraps again to the first channel.
                    Using a bipolar pan position, such as a sawtooth that ranges from -1 to +1, all channels will be
                    cyclically panned through.
                </doc>
            </arg>
            <arg name="level" default="1">
                <doc>
                    a control rate level input (linear multiplier).
                </doc>
            </arg>
            <arg name="width" default="2">
                <doc>
                    the width of the panning envelope. The default of 2.0 pans between pairs
                    of adjacent speakers. Width values greater than two will spread the pan over greater numbers
                    of speakers. Width values less than one will leave silent gaps between speakers.
                </doc>
            </arg>
            <arg name="orient" default="0">
                <doc>
                    the offset in the output channels regarding a pan position of zero.
                    Note that ScalaCollider uses a default of zero which means that a pan pos of zero outputs
                    the signal exactly on the first output channel. This is different in sclang where the default is
                    0.5 which means that a pan position of zero will output the signal inbetween the first and second
                    speaker. Accordingly, an `orient` of `1.0` would result in a channel offset of one, where a
                    pan position of zero would output the signal exactly on the second output channel, and so forth.
                </doc>
            </arg>
            <doc>
                <text>
                    An azimuth-based panorama UGen. It uses vector-based-amplitude panning where
                    the arbitrary number of speakers is supposed to be distributed in a circle
                    with even spacing between them. It uses an equal-power-curve to transition
                    between adjectant speakers. '''Note''' the different default value for
                    the `orient` argument!

                    Use case: To spread an multi-channel input signal across an output bus
                    with a different number of channels, such that the first input channel is played on the
                    first output channel (no spread to adjectant channels) and the last input channel is played
                    to the last output channel (no spread to adjectant channels), you would create a dedicated `PanAz` per
                    input channel where the pan position
                    is `inChanIdx * 2f / (inChannels - 1) * (outChannels - 1) / outChannels`.
                </text>
            </doc>
        </ugen>
        <ugen name="DecodeB2">
            <rate name="control"/>
            <rate name="audio">
                <arg name="w" rate="ugen"/>
                <arg name="x" rate="ugen"/>
                <arg name="y" rate="ugen"/>
            </rate>
            <outputs num="numChannels"/>
            <arg name="numChannels" type="Int"/>
            <arg name="w"/>
            <arg name="x"/>
            <arg name="y"/>
            <arg name="orient" default="0.5"/>
        </ugen>
    </file>

    <file name="PhysicalModellingUGens">
        <ugen name="Spring">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="spring" default="1"/>
            <arg name="damp" default="0"/>
        </ugen>
        <ugen name="Ball">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="g" default="1"/>
            <arg name="damp" default="0"/>
            <arg name="friction" default="0.01"/>
        </ugen>
        <ugen name="TBall">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="g" default="10"/>
            <arg name="damp" default="0"/>
            <arg name="friction" default="0.01"/>
        </ugen>
    </file>

    <file name="ReverbUGens">
        <ugen name="FreeVerb">
            <rate name="audio" implied="true"/>
            <arg name="in" rate="ugen"/>
            <arg name="mix" default="0.33"/>
            <arg name="room" default="0.5"/>
            <arg name="damp" default="0.5"/>
        </ugen>
        <ugen name="FreeVerb2">
            <rate name="audio" implied="true"/>
            <outputs num="2"/>
            <arg name="left" rate="ugen"/>
            <arg name="right" rate="ugen"/>
            <arg name="mix" default="0.33"/>
            <arg name="room" default="0.5"/>
            <arg name="damp" default="0.5"/>
        </ugen>
        <ugen name="GVerb">
            <rate name="audio" implied="true"/>
            <outputs num="2"/>
            <arg name="in" rate="ugen"/>
            <arg name="roomSize" default="10"/>
            <arg name="revTime" default="3"/>
            <arg name="damping" default="0.5"/>
            <arg name="inputBW" default="0.5"/>
            <arg name="spread" default="15"/>
            <arg name="dryLevel" default="1"/>
            <arg name="earlyRefLevel" default="0.7"/>
            <arg name="tailLevel" default="0.5"/>
            <arg name="maxRoomSize" default="300"/>
        </ugen>
    </file>

    <file name="TestUGens">
        <ugen name="CheckBadValues" sideeffect="true">
            <rate name="scalar"/>
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in">
                <doc>
                    the signal to be tested
                </doc>
            </arg>
            <arg name="id" default="0">
                <doc>
                    an identifier showing up with the values in the console
                </doc>
            </arg>
            <arg name="post" default="2">
                <doc>
                    One of three post modes: 0 = no posting; 1 = post a line for every bad value;
                    2 = post a line only when the floating-point classification changes (e.g., normal -&gt; NaN and vice versa)
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen to test for infinity, not-a-number (NaN), and denormals.
                    Its output is as follows: 0 = a normal float, 1 = NaN, 2 = infinity, and 3 = a denormal.
                    According to the post settings it will print the information to the console along
                    with a given identifier.
                </text>
            </doc>
        </ugen>
    </file>

    <file name="TriggerUGens">
        <ugen name="Trig1">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="in">
                <doc>
                    the trigger. This can be any signal. A trigger happens when the signal changes
                    from non-positive to positive.
                </doc>
            </arg>
            <arg name="dur" default="0.1">
                <doc>
                    the duration for which the ugens holds the value of 1 when triggered
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen which outputs a value of 1 for a given duration when triggered.

                    When a trigger occurs at the input, a value of 1 is output for the specified duration,
                    otherwise zero is output. When a new trigger occurs while this ugens outputs 1, the
                    hold-time is reset to the duration.
                </text>
                <see>ugen.Trig</see>
            </doc>
        </ugen>
        <ugen name="Trig">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="in">
                <doc>
                    the trigger. This can be any signal. A trigger happens when the signal changes
                    from non-positive to positive.
                </doc>
            </arg>
            <arg name="dur" default="0.1">
                <doc>
                    the duration for which the ugens holds the value of the input signal when triggered
                </doc>
            </arg>
        </ugen>
        <ugen name="SendTrig" sideeffect="true">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="trig">
                <doc>
                    the trigger signal causing the value to be read and sent. A trigger occurs
                    when passing from non-positive to positive.
                </doc>
            </arg>
            <arg name="value" default="0">
                <doc>
                    a changing signal or constant that will be polled at the time of trigger,
                    and its value passed with the trigger message
                </doc>
            </arg>
            <arg name="id" default="0">
                <doc>
                    an arbitrary integer that will be sent along with the `"/tr"` message.
                    This is useful to distinguish between several SendTrig instances per SynthDef.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen that sends a value from the server to all notified clients upon receiving triggers.
                    The message sent is `OSCMessage( "/tr", &lt;(Int) nodeID&gt;, &lt;(Int) trigID&gt;, &lt;(Float) value&gt; )`.

                    For sending an array of values, or using an arbitrary reply command, see `SendReply`.

                    '''Warning''': We have changed the argument order. While in sclang, `id` precedes `value`,
                    we are using them in reverse order here!
                </text>
                <see>ugen.SendReply</see>
            </doc>
        </ugen>

        <!-- XXX TODO
        <ugen name="SendReply" sideeffect="true">
        <ugen name="Poll" sideeffect="true">
        -->

        <ugen name="ToggleFF">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="trig">
                <doc>
                    a signal to trigger the flip-flop. a trigger occurs when the signal
                    changes from non-positive to positive.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen that toggles like a flip-flop between zero and one upon receiving a trigger.
                    The flip-flop is initially outputing zero, so changes to one when the first trigger
                    arrives.
                </text>
            </doc>
        </ugen>
        <ugen name="SetResetFF">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="trig"/>
            <arg name="reset"/>
        </ugen>
        <ugen name="Latch">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in">
                <doc>
                    the input signal
                </doc>
            </arg>
            <arg name="trig">
                <doc>
                    the trigger. The can be any signal. A trigger happens when the signal changes from
                    non-positive to positive.
                </doc>
            </arg>
            <doc>
                <text>
                    A sample-and-hold UGen. When triggered, a new value is taken from the input and
                    hold until the next trigger occurs.
                </text>
                <see>ugen.Gate</see>
                <see>ugen.Demand</see>
            </doc>
        </ugen>
        <ugen name="Gate">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in">
                <doc>
                    the input signal to gate
                </doc>
            </arg>
            <arg name="gate">
                <doc>
                    the signal specifying whether to pass the input signal (when greater than zero) or
                    whether to close the gate and hold the last value (when less than or equal to zero)
                </doc>
            </arg>
            <doc>
                <text>
                    A gate or hold UGen.
                    It allows the input signal value to pass when the `gate` argument is positive,
                    otherwise it holds last value.
                </text>
                <see>ugen.Latch</see>
            </doc>
        </ugen>
        <ugen name="Schmidt">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="trig"/>
            <arg name="lo" default="0"/>
            <arg name="hi" default="1"/>
        </ugen>
        <ugen name="PulseDivider">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="trig"/>
            <arg name="div" default="2"/>
            <arg name="start" default="0"/>
        </ugen>
        <ugen name="PulseCount">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="trig"/>
            <arg name="reset" default="0"/>
        </ugen>
        <ugen name="Stepper">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="trig"/>
            <arg name="reset" default="0"/>
            <arg name="lo" default="0"/>
            <arg name="hi" default="7"/>
            <arg name="step" default="1"/>
            <arg name="resetVal" default="0"/>
        </ugen>
        <ugen name="TDelay">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="trig"/>
            <arg name="dur" default="0.1"/>
        </ugen>
        <ugen name="ZeroCrossing">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
        </ugen>
        <ugen name="Timer">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="trig">
                <doc>
                    the trigger to update the output signal.
                    A trigger occurs when trig signal crosses from non-positive to positive.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen that returns time since last triggered.
                    The time returned is in seconds and is measured from the last received trigger.
                    Note that currently it seems the initial memory is at -1 sample, so for
                    `Impulse.ar(1)` the result (at 44.1 kHz) is 2.26757e-05, followed strangely
                    by 1.00002, and then (as expected) 1.0.
                </text>
            </doc>
        </ugen>
        <ugen name="Sweep">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="trig">
                <doc>
                    the trigger that restarts the ramp, when passing from
                    non-positive to positive
                </doc>
            </arg>
            <arg name="speed">
                <doc>
                    the amount of increment of the output signal per second.
                    In SCLang this argument is named `rate`, while ScalaCollider uses
                    `speed` to avoid conflict with the UGen's calculation rate.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen which starts a linear raise from zero each time it is
                    triggered.
                </text>
                <see>ugen.Ramp</see>
                <see>ugen.Phasor</see>
                <see>ugen.Line</see>
            </doc>
        </ugen>
        <ugen name="Phasor">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="trig"/>
            <arg name="speed" default="1"/>
            <arg name="lo" default="0"/>
            <arg name="hi" default="1"/>
            <arg name="resetVal" default="0"/>
        </ugen>
        <ugen name="Peak">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="trig"/>
        </ugen>
        <ugen name="RunningMin">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="trig"/>
        </ugen>
        <ugen name="RunningMax">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="trig"/>
        </ugen>
        <ugen name="PeakFollower">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="decay" default="0.999"/>
        </ugen>
        <ugen name="MostChange">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="a"/>
            <arg name="b"/>
        </ugen>
        <ugen name="LeastChange">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="a"/>
            <arg name="b"/>
        </ugen>
        <ugen name="LastValue">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="thresh" default="0.01"/>
        </ugen>
        <ugen name="Done" sideeffect="true">
            <rate name="control" implied="true"/>
            <arg name="src" doneflag="true">
                <doc>
                    the UGen to track
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen which monitors another UGen to see when it is finished.
                    Some UGens, such as `PlayBuf`, `RecordBuf`, `Line`, `XLine`, `EnvGen`, `Linen`, `BufRd`, `BufWr`, `DbufRd`,
                    and the Buffer delay UGens set a 'done' flag when they are finished playing. This UGen echoes that flag
                    as an explicit output signal when it is set to track a particular UGen. When the tracked UGen changes
                    to done, the output signal changes from zero to one.
                </text>
                <see>ugen.PlayBuf</see>
                <see>ugen.Line</see>
                <see>ugen.EnvGen</see>
            </doc>
        </ugen>
        <ugen name="Pause" sideeffect="true">
            <rate name="control" implied="true"/>
            <arg name="gate">
                <doc>
                    when 0, node is paused, when 1, node is resumed
                </doc>
            </arg>
            <arg name="node">
                <doc>
                    the id of the node to be paused or resumed
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen which pauses and resumes another node.
                    Note that the UGen initially assumes the node is running, that is,
                    if `gate` is initially 1, this will '''not''' resume a paused node.
                    Instead, the gate must go to zero and back to one to resume the node.
                    Additionally, this UGen will only cause action if the gate value
                    changes, that is, if the node is paused or resumed otherwise, this
                    UGen will not interfere with that action, unless the gate value is
                    adjusted.
                </text>
                <see>ugen.Free</see>
                <see>ugen.PauseSelf</see>
            </doc>
        </ugen>
        <ugen name="FreeSelf" sideeffect="true">
            <rate name="control" implied="true"/>
            <arg name="trig">
                <doc>
                    the input signal which will trigger the action.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen that, when triggered, frees enclosing synth.
                    It frees the enclosing synth when the input signal crosses from non-positive to positive.

                    This UGen outputs its input signal for convenience.
                </text>
                <see>ugen.Free</see>
                <see>ugen.PauseSelf</see>
            </doc>
        </ugen>
        <ugen name="PauseSelf" sideeffect="true">
            <rate name="control" implied="true"/>
            <arg name="trig">
                <doc>
                    the input signal which will trigger the action.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen that, when triggered, pauses enclosing synth.
                    It pauses the enclosing synth when the input signal crosses from non-positive to positive.

                    This UGen outputs its input signal for convenience.
                </text>
                <see>ugen.Pause</see>
                <see>ugen.FreeSelf</see>
            </doc>
        </ugen>
        <ugen name="Free" sideeffect="true">
            <rate name="control" implied="true"/>
            <arg name="trig">
                <doc>
                    the trigger to cause the action
                </doc>
            </arg>
            <arg name="node">
                <doc>
                    the id of the target node to free upon receiving the trigger
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen that, when triggered, frees a given node.

                    This UGen outputs its trig input signal for convenience.
                </text>
                <see>ugen.Pause</see>
                <see>ugen.FreeSelf</see>
            </doc>
        </ugen>
        <ugen name="FreeSelfWhenDone" sideeffect="true">
            <rate name="control" implied="true"/>
            <arg name="src" doneflag="true">
                <doc>
                    the input UGen which when finished will trigger the action.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen that, when its input UGen is finished, frees enclosing synth.
                    This is essentially a shortcut for `FreeSelf.kr( Done.kr( src ))`, so instead
                    of providing a trigger signal it reads directly the done flag of an
                    appropriate ugen (such as `Line` or `PlayBuf`).

                    This UGen outputs its input signal for convenience.
                </text>
                <see>ugen.Free</see>
                <see>ugen.FreeSelf</see>
                <see>ugen.PauseSelfWhenDone</see>
                <see>ugen.Done</see>
            </doc>
        </ugen>
        <ugen name="PauseSelfWhenDone" sideeffect="true">
            <rate name="control" implied="true"/>
            <arg name="src" doneflag="true">
                <doc>
                    the input UGen which when finished will trigger the action.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen that, when its input UGen is finished, pauses enclosing synth.
                    This is essentially a shortcut for `PauseSelf.kr( Done.kr( src ))`, so instead
                    of providing a trigger signal it reads directly the done flag of an
                    appropriate ugen (such as `Line` or `PlayBuf`).

                    This UGen outputs its input signal for convenience.
                </text>
                <see>ugen.Pause</see>
                <see>ugen.PauseSelf</see>
                <see>ugen.FreeSelfWhenDone</see>
                <see>ugen.Done</see>
            </doc>
        </ugen>
    </file>

    <file name="UnpackFFTUGens">
        <ugen name="Unpack1FFT" readsfft="true">
            <rate name="demand" implied="true" method="apply"/>
            <arg name="chain"/>
            <arg name="fftSize"/>
            <arg name="bin"/>
            <arg name="which" default="0"/>
        </ugen>

        <!-- TODO:
        <ugen name="PackFFT"/>
        -->
    </file>
</ugens>