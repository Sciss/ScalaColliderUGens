<ugens>
    <file name="DelayUGens">
        <ugen name="ControlRate">
            <rate name="scalar" implied="true"/>
            <doc>
                <text>
                    A UGen that reports the server's current control rate. This is equivalent to the reciprocal
                    of `ControlDur`
                </text>
                <see>ugen.ControlDur</see>
                <see>ugen.SampleRate</see>
            </doc>
        </ugen>
        <ugen name="SampleRate">
            <rate name="scalar" implied="true"/>
            <doc>
                <text>
                    A UGen that reports the server's current (audio) sample rate. This is equivalent to the reciprocal
                    of `SampleDur`
                </text>
                <see>ugen.SampleDur</see>
                <see>ugen.ControlRate</see>
                <see>ugen.RadiansPerSample</see>
            </doc>
        </ugen>
        <ugen name="SampleDur">
            <rate name="scalar" implied="true"/>
            <doc>
                <text>
                    A UGen that reports the server's current (audio) sample period in seconds. This is equivalent to the reciprocal
                    of `SampleRate`
                </text>
                <see>ugen.SampleRate</see>
                <see>ugen.ControlDur</see>
            </doc>
        </ugen>
        <ugen name="ControlDur">
            <rate name="scalar" implied="true"/>
            <doc>
                <text>
                    A UGen that reports the server's current control period in seconds. This is equivalent to the reciprocal
                    of `ControlRate`
                </text>
                <see>ugen.ControlRate</see>
                <see>ugen.SampleDur</see>
            </doc>
        </ugen>
        <ugen name="SubsampleOffset">
            <rate name="scalar" implied="true"/>
            <doc>
                <text>
                    A UGen that reports the fractional sample offset of the current Synth from its requested scheduled start.

                    When a synth is created from a time stamped osc-bundle, it starts
                    calculation at the next possible block (normally 64 samples). Using an
                    `OffsetOut` UGen, one can delay the audio so that it matches sample
                    accurately.

                    For some synthesis methods, one even needs subsample accuracy. `SubsampleOffset`
                    provides the information where, within the current sample, the synth was
                    scheduled. It can be used to offset envelopes or resample the audio
                    output.
                </text>
                <see>ugen.ControlRate</see>
                <see>ugen.SampleDur</see>
            </doc>
        </ugen>
        <ugen name="RadiansPerSample">
            <rate name="scalar" implied="true"/>
            <doc>
                <text>
                    A UGen that delivers the conversion factor from frequency in Hertz to radians (normalized frequency).
                    The relation is `RadiansPerSample * sr = 2pi`, thus multiplying the UGen with a frequency between
                    zero and nyquist (sr/2) yields the normalized frequency between zero and pi.
                </text>
                <see>ugen.SampleRate</see>
            </doc>
        </ugen>
        <ugen name="NumInputBuses">
            <rate name="scalar" implied="true"/>
        </ugen>
        <ugen name="NumOutputBuses">
            <rate name="scalar" implied="true"/>
        </ugen>
        <ugen name="NumAudioBuses">
            <rate name="scalar" implied="true"/>
        </ugen>
        <ugen name="NumControlBuses">
            <rate name="scalar" implied="true"/>
        </ugen>
        <ugen name="NumBuffers">
            <rate name="scalar" implied="true"/>
        </ugen>
        <ugen name="NumRunningSynths">
            <rate name="scalar" implied="true"/>
        </ugen>

        <ugen name="BufSampleRate">
            <rate name="scalar"/>
            <rate name="control"/>
            <arg name="buf"/>
        </ugen>
        <ugen name="BufRateScale">
            <rate name="scalar"/>
            <rate name="control"/>
            <arg name="buf"/>
        </ugen>
        <ugen name="BufSamples">
            <rate name="scalar"/>
            <rate name="control"/>
            <arg name="buf"/>
        </ugen>
        <ugen name="BufFrames">
            <rate name="scalar"/>
            <rate name="control"/>
            <arg name="buf"/>
        </ugen>
        <ugen name="BufChannels">
            <rate name="scalar"/>
            <rate name="control"/>
            <arg name="buf"/>
        </ugen>
        <ugen name="BufDur">
            <rate name="scalar"/>
            <rate name="control"/>
            <arg name="buf"/>
        </ugen>

        <ugen name="PlayBuf" readsbuf="true" sideeffect="true" doneflag="true">
            <rate name="control"/>
            <rate name="audio"/>
            <outputs num="numChannels"/>
            <arg name="numChannels" type="Int">
                <doc>
                    the number of channels that the buffer will be. Since
                    this is a constant, a change in number of channels of the underlying bus must
                    be reflected by creating different SynthDefs. If a buffer identifier is used of a buffer
                    that has a different numChannels then specified in the PlayBuf, it will fail silently.
                </doc>
            </arg>
            <arg name="buf">
                <doc>
                    the identifier of the buffer to use
                </doc>
            </arg>
            <arg name="speed" default="1">
                <doc>
                    1.0 advances the play head by the server's sample rate each second,
                    so 2.0 means doubling speed (and pitch), and 0.5 means half speed (and half pitch).
                    Negative numbers can be used for backwards playback. If the underlying buffer
                    represents a sound at a different sample rate, the rate should be
                    multiplied by `BufRateScale.kr( bufID )` to obtain the correct speed.
                </doc>
            </arg>
            <arg name="trig" default="1">
                <doc>
                    a trigger which causes a jump to the given startPos. A trigger occurs when a
                    signal changes from non-positive to positive (e.g. &lt;= 0 to &gt; 0).
                </doc>
            </arg>
            <arg name="startPos" default="0">
                <doc>
                    sample frame to start playback. This is read when a trigger occurs.
                </doc>
            </arg>
            <arg name="loop" default="1">
                <doc>
                    1 to loop after the play head reaches the buffer end, 0 to not loop. this can be modulated.
                </doc>
            </arg>
            <arg name="doneAction" default="doNothing">
                <doc>
                    what to do when the play head reaches the buffer end.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen to play back samples from a buffer in memory.

                    `PlayBuf` provides a kind of high-level interface to sample-playback, whereas `BufRd`
                    represents a kind of lower-level access. While `BufRd` has a random-access-pointer
                    in the form of a phase input, `PlayBuf` advances the phase automatically based on
                    a given playback speed. `PlayBuf` uses cubic interpolation.
                </text>
                <see>ugen.BufRd</see>
                <see>ugen.DiskIn</see>
                <see>ugen.RecordBuf</see>
                <see>DoneAction</see>
                <see>ugen.Done</see>
                <see>ugen.BufRateScale</see>
                <see>ugen.BufFrames</see>
            </doc>
        </ugen>
        <!-- <ugen name="SimpleLoopBuf">
        </ugen> -->
        <ugen name="RecordBuf" writesbuf="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="buf" pos="1"/>
            <arg name="offset" default="0" pos="2"/>
            <arg name="recLevel" default="1" pos="3"/>
            <arg name="preLevel" default="0" pos="4"/>
            <arg name="run" default="1" pos="5"/>
            <arg name="loop" default="1" pos="6"/>
            <arg name="trig" default="1" pos="7"/>
            <arg name="doneAction" default="doNothing" pos="8"/>
            <arg name="in" multi="true" pos="0"/>
        </ugen>
        <ugen name="BufRd" readsbuf="true">
            <rate name="control"/>
            <rate name="audio"/>
            <outputs num="numChannels"/>
            <arg name="numChannels" type="Int">
                <doc>
                    number of channels that the buffer will be.
                    Since this is an integer constant, a change in the number of channels must
                    be reflected by creating different SynthDefs.
                </doc>
            </arg>
            <arg name="buf">
                <doc>
                    the identifier of the buffer to use
                </doc>
            </arg>
            <arg name="phase" default="0">
                <doc>
                    audio rate frame-index into the buffer.
                </doc>
            </arg>
            <arg name="loop" default="1">
                <doc>
                    1 to enable looping, 0 to disable looping. this can be modulated.
                </doc>
            </arg>
            <arg name="interp" default="2">
                <doc>
                    1 for no interpolation, 2 for linear, and 4 for cubic interpolation
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen which reads the content of a buffer, using an index pointer.

                    Warning: if the supplied `bufID` refers to a buffer whose number of channels
                    differs from `numChannels`, the UGen will fail silently.

                    An alternative to `BufRd` is `PlayBuf`. While `PlayBuf` plays
                    through the buffer by itself, `BufRd` only moves its read point by the phase input
                    and therefore has no pitch input. `PlayBuf` uses cubic interplation, while
                    `BufRd` has variable interpolation. `PlayBuf` can determine the end of the buffer
                    and issue a done-action.
                </text>
                <see>ugen.PlayBuf</see>
                <see>ugen.BufWr</see>
                <see>ugen.Phasor</see>
                <see>ugen.BufFrames</see>
                <see>ugen.BufRateScale</see>
            </doc>
        </ugen>
        <ugen name="BufWr" writesbuf="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="buf" pos="1"/>
            <arg name="phase" default="0" pos="2"/>
            <arg name="loop" default="1" pos="3"/>
            <arg name="in" multi="true" pos="0"/>
        </ugen>
        <ugen name="Pitch">
            <rate name="control"/>
            <outputs num="2"/>
            <arg name="in"/>
            <arg name="initFreq" default="440"/>
            <arg name="minFreq" default="60"/>
            <arg name="maxFreq" default="4000"/>
            <arg name="execFreq" default="100"/>
            <arg name="binsPerOct" default="16"/>
            <arg name="median" default="1"/>
            <arg name="ampThresh" default="0.01"/>
            <arg name="peakThresh" default="0.5"/>
            <arg name="downSample" default="1"/>
        </ugen>

        <ugen name="BufDelayN">
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in"/>
            <arg name="delayTime" default="0.2"/>
        </ugen>
        <ugen name="BufDelayL">
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in"/>
            <arg name="delayTime" default="0.2"/>
        </ugen>
        <ugen name="BufDelayC">
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in"/>
            <arg name="delayTime" default="0.2"/>
        </ugen>
        <ugen name="BufCombN">
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
        </ugen>
        <ugen name="BufCombL">
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
        </ugen>
        <ugen name="BufCombC">
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
        </ugen>
        <ugen name="BufAllpassN">
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
        </ugen>
        <ugen name="BufAllpassL">
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
        </ugen>
        <ugen name="BufAllpassC">
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
        </ugen>

        <ugen name="DelayN">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="maxDelayTime" default="0.2"/>
            <arg name="delayTime" default="0.2"/>
        </ugen>
        <ugen name="DelayL">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="maxDelayTime" default="0.2"/>
            <arg name="delayTime" default="0.2"/>
        </ugen>
        <ugen name="DelayC">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="maxDelayTime" default="0.2"/>
            <arg name="delayTime" default="0.2"/>
        </ugen>
        <ugen name="CombN">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="in"/>
            <arg name="maxDelayTime" default="0.2"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
        </ugen>
        <ugen name="CombL">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="in"/>
            <arg name="maxDelayTime" default="0.2"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
        </ugen>
        <ugen name="CombC">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="in"/>
            <arg name="maxDelayTime" default="0.2"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
        </ugen>
        <ugen name="AllpassN">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="maxDelayTime" default="0.2"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
        </ugen>
        <ugen name="AllpassL">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="maxDelayTime" default="0.2"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
        </ugen>
        <ugen name="AllpassC">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="maxDelayTime" default="0.2"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
        </ugen>

        <ugen name="PitchShift">
            <rate name="audio" implied="true"/>
            <arg name="in"/>
            <arg name="winSize" default="0.2"/>
            <arg name="pitchRatio" default="1"/>
            <arg name="pitchDispersion" default="0"/>
            <arg name="timeDispersion" default="0"/>
        </ugen>
        <!-- this should exist according to plugin sources... <ugen name="GrainTap">
        </ugen> -->
        <ugen name="TGrains">
            <rate name="audio" implied="true"/>
            <outputs num="numChannels"/>
            <arg name="numChannels" type="Int"/>
            <arg name="trig"/>
            <arg name="buf"/>
            <arg name="speed" default="1"/>
            <arg name="centerPos" default="0"/>
            <arg name="dur" default="0.1"/>
            <arg name="pan" default="0"/>
            <arg name="amp" default="0.1"/>
            <arg name="interp" default="4"/>
        </ugen>
        <ugen name="ScopeOut"> <!-- XXX zero outputs? -->
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="buf"/>
            <arg name="in" multi="true"/>
        </ugen>
        <ugen name="Pluck">
            <rate name="audio" implied="true"/>
            <arg name="in"/>
            <arg name="trig" default="1"/>
            <arg name="maxDelayTime" default="0.2"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
            <arg name="coef" default="0.5"/>
        </ugen>

        <ugen name="DelTapWr">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="buf"/>
            <arg name="in"/>
        </ugen>
        <ugen name="DelTapRd">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="buf"/>
            <arg name="phase"/>
            <arg name="delayTime"/>
            <arg name="interp" default="1"/>
        </ugen>

        <!-- XXX TODO
        <ugen name="LocalBuf">
        </ugen>
        <ugen name="MaxLocalBufs">
        </ugen>
        <ugen name="SetBuf">
        </ugen>
        <ugen name="ClearBuf">
        </ugen> -->
    </file>

    <file name="EnvGen">
        <ugen name="Done" sideeffect="true">
            <rate name="control" implied="true"/>
            <arg name="src" doneflag="true">
                <doc>
                    the UGen to track
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen which monitors another UGen to see when it is finished.
                    Some UGens, such as `PlayBuf`, `RecordBuf`, `Line`, `XLine`, `EnvGen`, `Linen`, `BufRd`, `BufWr`, `DbufRd`,
                    and the Buffer delay UGens set a 'done' flag when they are finished playing. This UGen echoes that flag
                    as an explicit output signal when it is set to track a particular UGen. When the tracked UGen changes
                    to done, the output signal changes from zero to one.
                </text>
                <see>ugen.PlayBuf</see>
                <see>ugen.Line</see>
                <see>ugen.EnvGen</see>
            </doc>
        </ugen>
    </file>

    <file name="Filter">
        <ugen name="Ramp">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    the signal to smooth out
                </doc>
            </arg>
            <arg name="dur" default="0.1">
                <doc>
                    the ramp-time (seconds) which is also the interval of the sampling
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen which produces a linear lag (time smear) regarding
                    and input signal. Other than `Lag` which is a feedback
                    filter with exponential decay, `Ramp` applies a linear
                    ramp. This is achieved by sampling the input signal
                    at regular intervals given by the `lagTime` and starting
                    a new line segment after each interval.
                </text>
                <see>ugen.Lag</see>
                <see>ugen.Sweep</see>
            </doc>
        </ugen>
        <ugen name="Lag">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal.
                </doc>
            </arg>
            <arg name="time" default="0.1">
                <doc>
                    60 dB lag time in seconds.
                </doc>
            </arg>
            <doc>
                <text>
                    An exponential lag UGen.
                    This is essentially the same as `OnePole` except that instead of supplying the coefficient directly,
                    it is calculated from a 60 dB lag time. This is the time required for the filter to converge to
                    within 0.01 % of a value. This is useful for smoothing out control signals.
                </text>
                <see>ugen.OnePole</see>
                <see>ugen.LagUD</see>
                <see>ugen.Lag2</see>
                <see>ugen.Ramp</see>
            </doc>
        </ugen>
        <ugen name="Lag2">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal.
                </doc>
            </arg>
            <arg name="time" default="0.1">
                <doc>
                    60 dB lag time in seconds.
                </doc>
            </arg>
            <doc>
                <text>
                    A cascaded exponential lag
                    UGen. `Lag2.kr(in, time)` is equivalent to `Lag.kr(Lag.kr(in, time), time)`,
                    thus resulting in a smoother transition. This saves on CPU as you only have to
                    calculate the decay factor once instead of twice.
                </text>
                <see>ugen.Lag</see>
                <see>ugen.Lag2UD</see>
                <see>ugen.Lag3</see>
            </doc>
        </ugen>
        <ugen name="Lag3">
             <rate name="control"/>
             <rate name="audio"/>
             <arg name="in" rate="ugen">
                 <doc>
                     input signal.
                 </doc>
             </arg>
             <arg name="time" default="0.1">
                 <doc>
                     60 dB lag time in seconds.
                 </doc>
             </arg>
             <doc>
                 <text>
                     A cascaded exponential lag
                    UGen. `Lag3.kr(in, time)` is equivalent to `Lag.kr(Lag.kr(Lag.kr(Lag.kr(in, time), time), time)`,
                    thus resulting in a smoother transition. This saves on CPU as you only have to
                    calculate the decay factor once instead of three times.
                 </text>
                 <see>ugen.Lag</see>
                 <see>ugen.Lag3UD</see>
                 <see>ugen.Lag2</see>
             </doc>
         </ugen>
        <ugen name="LagUD">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal.
                </doc>
            </arg>
            <arg name="timeUp" default="0.1">
                <doc>
                    60 dB lag time in seconds effective during a rising slope in the input signal
                </doc>
            </arg>
            <arg name="timeDown" default="0.1">
                <doc>
                    60 dB lag time in seconds effective during a falling slope in the input signal
                </doc>
            </arg>
            <doc>
                <text>
                    An exponential lag UGen with separate inputs for up and down slope.
                    This is essentially the same as `Lag` except that you can supply a different 60 dB time
                    for when the signal goes up, from when the signal goes down.
                </text>
                <see>ugen.Lag</see>
                <see>ugen.Lag2UD</see>
            </doc>
        </ugen>
        <ugen name="Lag2UD">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal.
                </doc>
            </arg>
            <arg name="timeUp" default="0.1">
                <doc>
                    60 dB lag time in seconds effective during a rising slope in the input signal
                </doc>
            </arg>
            <arg name="timeDown" default="0.1">
                <doc>
                    60 dB lag time in seconds effective during a falling slope in the input signal
                </doc>
            </arg>
            <doc>
                <text>
                    A cascaded exponential lag UGen with separate inputs for up and down
                    slope. `Lag2UD.kr(in, up, down)` is equivalent to `LagUD.kr(LagUD.kr(in, up, down), up, down)`,
                    thus resulting in a smoother transition. This saves on CPU as you only have to
                    calculate the decay factors once instead of twice.
                </text>
                <see>ugen.LagUD</see>
                <see>ugen.Lag2</see>
                <see>ugen.Lag3UD</see>
            </doc>
        </ugen>
        <ugen name="Lag3UD">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal.
                </doc>
            </arg>
            <arg name="timeUp" default="0.1">
                <doc>
                    60 dB lag time in seconds effective during a rising slope in the input signal
                </doc>
            </arg>
            <arg name="timeDown" default="0.1">
                <doc>
                    60 dB lag time in seconds effective during a falling slope in the input signal
                </doc>
            </arg>
            <doc>
                <text>
                    A cascaded exponential lag UGen with separate inputs for up and down
                    slope. `Lag3UD.kr(in, up, down)` is equivalent to `LagUD.kr(LagUD.kr(LagUD.kr(in, up, down), up, down), up, down)`,
                    thus resulting in a smoother transition. This saves on CPU as you only have to
                    calculate the decay factors once instead of three times.
                </text>
                <see>ugen.LagUD</see>
                <see>ugen.Lag3</see>
                <see>ugen.Lag2UD</see>
            </doc>
        </ugen>
        <ugen name="OnePole">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal to be processed
                </doc>
            </arg>
            <arg name="coeff" default="0.5">
                <doc>
                    feedback coefficient. Should be between -1 and +1
                </doc>
            </arg>
            <doc>
                <text>
                    A one pole (IIR) filter UGen.
                    Implements the formula :
                    {{{
                    out(i) = ((1 - abs(coef)) * in(i)) + (coef * out(i-1))
                    }}}
                </text>
                <see>ugen.OneZero</see>
                <see>ugen.Lag</see>
            </doc>
        </ugen>
        <ugen name="OneZero">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal to be processed
                </doc>
            </arg>
            <arg name="coeff" default="0.5">
                <doc>
                    feed forward coefficient. +0.5 makes a two point averaging filter (see also `LPZ1`),
                    -0.5 makes a differentiator (see also `HPZ1`),  +1 makes a single sample delay (see also `Delay1`),
                    -1 makes an inverted single sample delay.
                </doc>
            </arg>
            <doc>
                <text>
                    A one zero (FIR) filter UGen.
                    Implements the formula :
                    {{{
                    out(i) = ((1 - abs(coef)) * in(i)) + (coef * in(i-1))
                    }}}
                </text>
                <see>ugen.OnePole</see>
                <see>ugen.LPZ1</see>
                <see>ugen.HPZ1</see>
                <see>ugen.Delay1</see>
                <see>ugen.Integrator</see>
            </doc>
        </ugen>
        <ugen name="TwoPole">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal to be processed
                </doc>
            </arg>
            <arg name="freq" default="440"/>
            <arg name="radius" default="0.8"/>
        </ugen>
        <ugen name="TwoZero">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal to be processed
                </doc>
            </arg>
            <arg name="freq" default="440"/>
            <arg name="radius" default="0.8"/>
        </ugen>
        <ugen name="Decay">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal to be processed
                </doc>
            </arg>
            <arg name="time" default="1"/>
        </ugen>
        <ugen name="Decay2">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal to be processed
                </doc>
            </arg>
            <arg name="attack" default="0.01"/>
            <arg name="release" default="1"/>
        </ugen>
        <!-- this should exist according to plugin sources... <ugen name="Flip">
        </ugen> -->
        <ugen name="Delay1">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
        </ugen>
        <ugen name="Delay2">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
        </ugen>
        <ugen name="Integrator">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal to be processed
                </doc>
            </arg>
            <arg name="coeff" default="1">
                <doc>
                    the leak coefficient. Should be between -1 and +1
                </doc>
            </arg>
            <doc>
                <text>
                    A filter UGen to integrate an input signal with a leak.
                    Implements the formula :
                    {{{
                    out(i) = in(i) + (coef * out(i-1))
                    }}}
                </text>
                <see>ugen.OnePole</see>
                <see>ugen.HPZ1</see>
                <see>ugen.LPZ1</see>
            </doc>
        </ugen>
        <ugen name="LeakDC">
            <rate name="control">
                <arg name="coeff" default="0.9"/>
            </rate>
            <rate name="audio">
                <arg name="coeff" default="0.995"/>
            </rate>
            <arg name="in" rate="ugen"/>
            <arg name="coeff"/>
        </ugen>
        <ugen name="LPZ1">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal to be processed
                </doc>
            </arg>
            <doc>
                <text>
                    two point average filter UGen.
                    Implements the formula :
                    {{{
                    out(i) = 0.5 * (in(i) + in(i-1))
                    }}}
                </text>
                <see>ugen.OnePole</see>
                <see>ugen.HPZ1</see>
                <see>ugen.Integrator</see>
            </doc>
        </ugen>
        <ugen name="HPZ1">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal to be processed
                </doc>
            </arg>
            <doc>
                <text>
                    A two point difference filter UGen.
                    Implements the formula :
                    {{{
                    out(i) = 0.5 * (in(i) - in(i-1))
                    }}}
                </text>
                <see>ugen.OneZero</see>
                <see>ugen.LPZ1</see>
            </doc>
        </ugen>
        <ugen name="LPZ2">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
        </ugen>
        <ugen name="HPZ2">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
        </ugen>
        <ugen name="BPZ2">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
        </ugen>
        <ugen name="BRZ2">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
        </ugen>
        <ugen name="APF">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="freq" default="440"/>
            <arg name="radius" default="0.8"/>
        </ugen>
        <ugen name="LPF">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="freq" default="440"/>
        </ugen>
        <ugen name="HPF">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="freq" default="440"/>
        </ugen>
        <ugen name="BPF">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="freq" default="440"/>
            <arg name="rq" default="1"/>
        </ugen>
        <ugen name="BRF">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="freq" default="440"/>
            <arg name="rq" default="1"/>
        </ugen>
        <ugen name="RLPF">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="freq" default="440"/>
            <arg name="rq" default="1"/>
        </ugen>
        <ugen name="RHPF">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="freq" default="440"/>
            <arg name="rq" default="1"/>
        </ugen>

        <ugen name="Slew">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal
                </doc>
            </arg>
            <arg name="up" default="1">
                <doc>
                    maximum upward slope.
                </doc>
            </arg>
            <arg name="down" default="1">
                <doc>
                    maximum downward slope.
                </doc>
            </arg>
            <doc>
                <text>
                    A slew rate limiter UGen.
                    Limits the slope of an input signal. The slope is expressed in units per second.
                </text>
            </doc>
        </ugen>
        <ugen name="Slope">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal to be measured
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen measuring the slope of signal.
                    It calculates the rate of change per second of a signal, as given by the following formula:
                    {{{
                    out(i) = (in(i) - in(i-1)) * sampleRate
                    }}}
                    It thus equal to `HPZ1.ar(_) * 2 * SampleRate.ir`
                </text>
            </doc>
        </ugen>

        <ugen name="MidEQ">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="freq" default="440"/>
            <arg name="rq" default="1"/>
            <arg name="gain" default="0"/>
        </ugen>
        <ugen name="Median">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen" pos="0"/>
            <arg name="length" default="3" pos="1"/>
            <doc warnpos="true"/>
        </ugen>

        <ugen name="Resonz">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="freq" default="440"/>
            <arg name="rq" default="1"/>
        </ugen>
        <ugen name="Ringz">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="freq" default="440"/>
            <arg name="attack" default="1"/>
            <arg name="decay" default="1"/>
        </ugen>
        <ugen name="Formlet">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="freq" default="440"/>
            <arg name="attack" default="1"/>
            <arg name="decay" default="1"/>
        </ugen>

        <ugen name="FOS">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="a0" default="0"/>
            <arg name="a1" default="0"/>
            <arg name="b1" default="0"/>
        </ugen>
        <ugen name="SOS">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="a0" default="0"/>
            <arg name="a1" default="0"/>
            <arg name="a2" default="0"/>
            <arg name="b1" default="0"/>
            <arg name="b2" default="0"/>
        </ugen>

        <ugen name="Compander">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in">
                <doc>
                    The signal to be compressed / expanded / gated.
                </doc>
            </arg>
            <arg name="ctrl">
                <doc>
                    The signal whose amplitude controls the processor. Often the same as in, but one may wish
                    to apply equalization or delay to it to change the compressor character (side-chaining), or even feed
                    a completely different signal, for instance in a ducking application.
                </doc>
            </arg>
            <arg name="thresh" default="0.5">
                <doc>
                    Control signal amplitude threshold, which determines the break point between slopeBelow
                    and slopeAbove. Usually 0..1. The control signal amplitude is calculated using RMS.
                </doc>
            </arg>
            <arg name="ratioBelow" default="1">
                <doc>
                    Slope of the amplitude curve below the threshold. If this slope &gt; 1.0, the amplitude
                    will drop off more quickly the softer the control signal gets; when the control signal is close to 0
                    amplitude, the output should be exactly zero -- hence, noise gating. Values &lt; 1.0 are possible,
                    but it means that a very low-level control signal will cause the input signal to be amplified,
                    which would raise the noise floor.
                </doc>
            </arg>
            <arg name="ratioAbove" default="1">
                <doc>
                    Slope of the amplitude curve above the threshold. Values &lt; 1.0 achieve compression
                    (louder signals are attenuated); &gt; 1.0, you get expansion (louder signals are made even louder).
                    For 3:1 compression, you would use a value of 1/3 here.
                </doc>
            </arg>
            <arg name="attack" default="0.01">
                <doc>
                    The amount of time it takes for the amplitude adjustment to kick in fully. This is
                    usually pretty small, not much more than 10 milliseconds (the default value). I often set it as low as
                    2 milliseconds (0.002).
                </doc>
            </arg>
            <arg name="release" default="0.1">
                <doc>
                    The amount of time for the amplitude adjustment to be released. Usually a bit longer
                    than attack; if both times are too short, you can get some (possibly unwanted) artifacts.
                </doc>
            </arg>
            <doc>
                <text>
                    A compressor, expander, limiter, gate and ducking UGen. This dynamic processor uses a
                    hard-knee characteristic. All of the thresholds and ratios are given as direct
                    values, not in decibels!
                </text>
                <see>ugen.Limiter</see>
                <see>ugen.Normalizer</see>
            </doc>
        </ugen>
        <ugen name="Limiter">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="level" default="1"/>
            <arg name="dur" default="0.01"/>
        </ugen>
        <ugen name="Normalizer">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="level" default="1"/>
            <arg name="dur" default="0.01"/>
        </ugen>

        <ugen name="Amplitude">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="attack" default="0.01"/>
            <arg name="release" default="0.01"/>
        </ugen>
        <ugen name="DetectSilence" sideeffect="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="amp" default="0.0001"/>
            <arg name="dur" default="0.1"/>
            <arg name="doneAction" default="doNothing"/>
        </ugen>

        <ugen name="Hilbert">
            <outputs num="2"/>
            <rate name="audio"/>
            <arg name="in"/>
        </ugen>
        <ugen name="FreqShift">
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="freq" default="0"/>
            <arg name="phase" default="0"/>
        </ugen>
        <ugen name="MoogFF">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="freq" default="200"/>
            <arg name="gain" default="2"/>
            <arg name="reset" default="0"/>
        </ugen>

        <ugen name="BLowPass">
            <rate name="audio" implied="true"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal to be processed.
                </doc>
            </arg>
            <arg name="freq" default="440">
                <doc>
                    cutoff frequency.
                </doc>
            </arg>
            <arg name="rq" default="1">
                <doc>
                    the reciprocal of Q, hence bandwidth / cutoffFreq.
                </doc>
            </arg>
            <doc>
                <text>
                    A 2nd order (12db per oct rolloff) resonant low pass filter UGen.
                    The B equalization suite is based on the Second Order Section (SOS) biquad UGen.

                    Note: Biquad coefficient calculations imply certain amount of CPU overhead. These
                    plugin UGens contain optimizations such that the coefficients get updated only when
                    there has been a change to one of the filter's parameters. This can cause spikes in
                    CPU performance and should be considered when using several of these units.
                </text>
            </doc>
        </ugen>
        <ugen name="BHiPass">
            <rate name="audio" implied="true"/>
            <arg name="in" rate="ugen">
                <doc>
                     input signal to be processed.
                 </doc>
            </arg>
            <arg name="freq" default="440">
                <doc>
                    cutoff frequency.
                </doc>
            </arg>
            <arg name="rq" default="1">
                <doc>
                    the reciprocal of Q, hence bandwidth / cutoffFreq.
                </doc>
            </arg>
            <doc>
                <text>
                    A 2nd order (12db per oct rolloff) resonant high pass filter UGen.
                    The B equalization suite is based on the Second Order Section (SOS) biquad UGen.

                    Note: Biquad coefficient calculations imply certain amount of CPU overhead. These
                    plugin UGens contain optimizations such that the coefficients get updated only when
                    there has been a change to one of the filter's parameters. This can cause spikes in
                    CPU performance and should be considered when using several of these units.
                </text>
            </doc>
        </ugen>
        <ugen name="BBandPass">
            <rate name="audio" implied="true"/>
            <arg name="in" rate="ugen">
                <doc>
                     input signal to be processed.
                 </doc>
            </arg>
            <arg name="freq" default="440">
                <doc>
                    center frequency.
                </doc>
            </arg>
            <arg name="bw" default="1">
                <doc>
                    the bandwidth '''in octaves''' between -3 dB frequencies
                </doc>
            </arg>
            <doc>
                <text>
                    An band pass filter UGen.
                    The B equalization suite is based on the Second Order Section (SOS) biquad UGen.

                    Note: Biquad coefficient calculations imply certain amount of CPU overhead. These
                    plugin UGens contain optimizations such that the coefficients get updated only when
                    there has been a change to one of the filter's parameters. This can cause spikes in
                    CPU performance and should be considered when using several of these units.
                </text>
            </doc>
        </ugen>
        <ugen name="BBandStop">
            <rate name="audio" implied="true"/>
            <arg name="in" rate="ugen">
                <doc>
                     input signal to be processed.
                 </doc>
            </arg>
            <arg name="freq" default="440">
                <doc>
                    center frequency.
                </doc>
            </arg>
            <arg name="bw" default="1">
                <doc>
                    the bandwidth '''in octaves''' between -3 dB frequencies
                </doc>
            </arg>
            <doc>
                <text>
                    An band stop (reject) filter UGen.
                    The B equalization suite is based on the Second Order Section (SOS) biquad UGen.

                    Note: Biquad coefficient calculations imply certain amount of CPU overhead. These
                    plugin UGens contain optimizations such that the coefficients get updated only when
                    there has been a change to one of the filter's parameters. This can cause spikes in
                    CPU performance and should be considered when using several of these units.
                </text>
            </doc>
        </ugen>
        <ugen name="BPeakEQ">
            <rate name="audio" implied="true"/>
            <arg name="in" rate="ugen">
                <doc>
                     input signal to be processed.
                 </doc>
            </arg>
            <arg name="freq" default="440">
                <doc>
                    center frequency.
                </doc>
            </arg>
            <arg name="rq" default="1">
                <doc>
                    the reciprocal of Q, hence bandwidth / cutoffFreq.
                </doc>
            </arg>
            <arg name="gain" default="0">
                <doc>
                    boost/cut at the center frequency (in decibels).
                </doc>
            </arg>
            <doc>
                <text>
                    An parametric equalizer UGen.
                    The B equalization suite is based on the Second Order Section (SOS) biquad UGen.

                    Note: Biquad coefficient calculations imply certain amount of CPU overhead. These
                    plugin UGens contain optimizations such that the coefficients get updated only when
                    there has been a change to one of the filter's parameters. This can cause spikes in
                    CPU performance and should be considered when using several of these units.
                </text>
            </doc>
        </ugen>
        <ugen name="BAllPass">
            <rate name="audio" implied="true"/>
            <arg name="in" rate="ugen">
                <doc>
                     input signal to be processed.
                 </doc>
            </arg>
            <arg name="freq" default="440">
                <doc>
                    cutoff frequency.
                </doc>
            </arg>
            <arg name="rq" default="1">
                <doc>
                    the reciprocal of Q, hence bandwidth / cutoffFreq.
                </doc>
            </arg>
            <doc>
                <text>
                    An all pass filter UGen.
                    The B equalization suite is based on the Second Order Section (SOS) biquad UGen.

                    Note: Biquad coefficient calculations imply certain amount of CPU overhead. These
                    plugin UGens contain optimizations such that the coefficients get updated only when
                    there has been a change to one of the filter's parameters. This can cause spikes in
                    CPU performance and should be considered when using several of these units.
                </text>
            </doc>
        </ugen>
        <ugen name="BLowShelf">
            <rate name="audio" implied="true"/>
            <arg name="in" rate="ugen">
                <doc>
                     input signal to be processed.
                 </doc>
            </arg>
            <arg name="freq" default="440">
                <doc>
                    cutoff frequency.
                </doc>
            </arg>
            <arg name="rs" default="1">
                <doc>
                    the reciprocal of the slope S (Shell boost/cut slope).
                    When `S = 1`, the shelf slope is as steep as it can be and remain monotonically increasing
                    or decreasing gain with frequency.  The shelf slope, in dB/octave, remains proportional to
                    S for all other values for a fixed freq/sample-rate and `gain`.
                </doc>
            </arg>
            <arg name="gain" default="0">
                <doc>
                    boost/cut at the cutoff frequency (in decibels).
                </doc>
            </arg>
            <doc>
                <text>
                    A low shelf equalizer UGen.
                    The B equalization suite is based on the Second Order Section (SOS) biquad UGen.

                    Note: Biquad coefficient calculations imply certain amount of CPU overhead. These
                    plugin UGens contain optimizations such that the coefficients get updated only when
                    there has been a change to one of the filter's parameters. This can cause spikes in
                    CPU performance and should be considered when using several of these units.
                </text>
            </doc>
        </ugen>
        <ugen name="BHiShelf">
            <rate name="audio" implied="true"/>
            <arg name="in" rate="ugen">
                <doc>
                     input signal to be processed.
                 </doc>
            </arg>
            <arg name="freq" default="440">
                <doc>
                    cutoff frequency.
                </doc>
            </arg>
            <arg name="rs" default="1">
                <doc>
                    the reciprocal of the slope S (Shell boost/cut slope).
                    When `S = 1`, the shelf slope is as steep as it can be and remain monotonically increasing
                    or decreasing gain with frequency.  The shelf slope, in dB/octave, remains proportional to
                    S for all other values for a fixed freq/sample-rate and `gain`.
                </doc>
            </arg>
            <arg name="gain" default="0">
                <doc>
                    boost/cut at the cutoff frequency (in decibels).
                </doc>
            </arg>
            <doc>
                <text>
                    A high shelf equalizer UGen.
                    The B equalization suite is based on the Second Order Section (SOS) biquad UGen.

                    Note: Biquad coefficient calculations imply certain amount of CPU overhead. These
                    plugin UGens contain optimizations such that the coefficients get updated only when
                    there has been a change to one of the filter's parameters. This can cause spikes in
                    CPU performance and should be considered when using several of these units.
                </text>
            </doc>
        </ugen>
    </file>

    <file name="InOut">
        <ugen name="Out" writesbus="true">
            <outputs num="0"/>
            <rate name="audio">
                <arg name="in" rate="ugen"/>
            </rate>
            <rate name="control"/>
            <rate name="scalar"/>
            <arg name="bus"/>
            <arg name="in" multi="true"/>
        </ugen>
    </file>

    <file name="Line">
        <ugen name="Line" sideeffect="true" doneflag="true">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="start" default="0">
                <doc>
                    Starting value. Note that this is read only once at initialization
                </doc>
            </arg>
            <arg name="end" default="1">
                <doc>
                    Ending value. Note that this is read only once at initialization
                </doc>
            </arg>
            <arg name="dur" default="1">
                <doc>
                    Duration in seconds. Note that this is read only once at initialization
                </doc>
            </arg>
            <arg name="doneAction" default="doNothing">
                <doc>
                    A done-action that is evaluated when the Line has reached the end value after the
                    given duration
                </doc>
            </arg>
            <doc>
                <text>
                    A line generator UGen that moves from a start value to the end value in a given duration.
                </text>
                <see>ugen.XLine</see>
                <see>ugen.EnvGen</see>
                <see>ugen.Ramp</see>
            </doc>
        </ugen>
    </file>

    <file name="Osc">
        <ugen name="LFSaw">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="freq" default="440">
                <doc>
                    frequency in Hertz
                </doc>
            </arg>
            <arg name="phase" default="0">
                <doc>
                    Initial phase offset. For efficiency reasons this is a
                    value ranging from 0 to 2. Note that a phase of zero (default) means
                    the wave starts at 0 and rises to +1 before jumping down to -1. Use
                    a phase of 1 to have the wave start at -1. The initial phase cannot
                    be modulated.
                </doc>
            </arg>
            <doc>
                <text>
                    A sawtooth oscillator UGen. The oscillator is creating an aliased sawtooth,
                    that is it does not use band-limiting. For a band-limited version use
                    `Saw` instead. The signal range is -1 to +1
                </text>
                <see>ugen.Saw</see>
            </doc>
        </ugen>
        <ugen name="SinOsc">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="freq" default="440">
                <doc>
                    frequency in Hertz
                </doc>
            </arg>
            <arg name="phase" default="0">
                <doc>
                    phase offset or modulator in radians
                </doc>
            </arg>
            <doc>
                <text>
                    A Sinusoidal (sine tone) oscillator UGen.
                    This is the same as `Osc` except that it uses a built-in interpolating sine table of 8192 entries.
                </text>
                <see>ugen.Osc</see>
                <see>ugen.FSinOsc</see>
            </doc>
        </ugen>
    </file>

    <file name="DiskIO">
        <!-- // side-effect: advancing sf offset -->
        <ugen name="DiskIn" sideeffect="true">
            <rate name="audio" implied="true"/>
            <outputs num="numChannels"/>
            <arg name="numChannels" type="Int">
                <doc>
                    the amount of channels the file and the buffer will have. This is an Int and hence
                    must be pre-determined. Different SynthDefs must be created for different numbers of channels.
                </doc>
            </arg>
            <arg name="buf">
                <doc>
                    the id of the buffer with the correct number of channels and frames
                </doc>
            </arg>
            <arg name="loop" default="0">
                <doc>
                    whether the file should loop when its end is reached
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen to stream in a signal from an audio file. Continuously plays a longer audio file
                    from disk. This requires a buffer to be preloaded with one buffer size of sound. If loop is
                    set to 1, the file will loop.

                    '''Note''': The buffer size must be a multiple of (2 * the server's block size). See
                    `Buffer#cue` for details.
                </text>
                <see>Buffer#cue</see>
                <see>ugen.VDiskIn</see>
                <see>ugen.PlayBuf</see>
            </doc>
        </ugen>
        
        <ugen name="DiskOut" writesbuf="true">
            <rate name="audio" implied="true"/>
            <arg name="buf">
                <doc>
                    the buffer used internally by the UGen. this number of frames in the buffer must
                    be a power of two (this is currently not checked!). The buffer must have been initialized
                    with a `write` command whose `leaveOpen` argument is true. Note that the number of channels of
                    the buffer and of the input signal must be the same, otherwise `DiskOut` will fail silently
                    (and not write anything to the file).
                </doc>
            </arg>
            <arg name="in" multi="true" rate="ugen">
                <doc>
                    the signal to be recorded
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen which writes a signal to a soundfile on disk. To achieve this efficiently, a buffer is
                    needs to be provides which is used to buffer the incoming signal.

                    '''Note''': It might be that the buffer size must be a multiple of (2 * the server's block size).
                    We haven't currently verified this, but to be safe, you should make sure this property is met.

                    The signal output by the UGen represents the number of frames written.
                </text>
                <see>Buffer#write</see>
                <see>ugen.DiskIn</see>
                <see>ugen.RecordBuf</see>
            </doc>
        </ugen>

        <!-- // side-effect: advancing sf offset -->
        <ugen name="VDiskIn" readsbuf="true" sideeffect="true">
            <!-- note: argument 'rate' renamed to 'speed' -->
            <rate name="audio" implied="true"/>
            <outputs num="numChannels"/>
            <arg name="numChannels" type="Int">
                <doc>
                    the amount of channels the file and the buffer will have. This is an Int and hence
                    must be pre-determined. Different SynthDefs must be created for different numbers of channels
                </doc>
            </arg>
            <arg name="buf">
                <doc>
                    the id of the buffer with the correct number of channels and frames
                </doc>
            </arg>
            <arg name="speed" default="1">
                <doc>
                    controls the speed of playback. Values below 4 are probably fine, but the higher the value,
                    the more disk activity there is, and the more likelihood there will be a problem.
                    The following must be true: `rate &lt; bufFrames / (2 * blockSize)`, e.g with typical default
                    values, this will be `32768 / (2 * 64) = 256`.
                </doc>
            </arg>
            <arg name="loop" default="0">
                <doc>
                    whether the file should loop when its end is reached
                </doc>
            </arg>
            <arg name="sendID" default="0">
                <doc>
                    If a value other than zero is used, the UGen sends an OSC message with this id and the
                    file position each time it reloads the buffer: `OSCMessage( "/diskin", nodeID, sendID, frame )`
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen to stream in a signal from an audio file with variable playback speed.
                    Continuously plays a longer audio file
                    from disk. This requires a buffer to be preloaded with one buffer size of sound. If loop is
                    set to 1, the file will loop.

                    '''Note''': The buffer size must be a multiple of (2 * the server's block size). See
                    `Buffer#cue` for details.

                    If the speed is too high, the UGen will not execute, posting a warning.
                </text>
            </doc>
            <see>Buffer#cue</see>
            <see>ugen.DiskIn</see>
            <see>ugen.DiskOut</see>
            <see>ugen.PlayBuf</see>
        </ugen>
    </file>
</ugens>