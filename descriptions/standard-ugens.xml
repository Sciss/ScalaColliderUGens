<ugens> <!-- list as of 02-sep-10 -->
    <file name="ChaosUGens">
        <ugen name="CuspN">
            <rate name="audio"/>
            <doc>
                <text>
                    A non-interpolating sound generator based on the difference equation:
                    {{{
                    x[n+1] = a - b * sqrt(abs(x[n]))
                    }}}
                </text>
            </doc>
            <arg name="freq" default="SampleRate.ir * 0.5">
                <doc>
                    Iteration frequency in Hertz
                </doc>
            </arg>
            <arg name="a" default="1">
                <doc>
                    Equation variable
                </doc>
            </arg>
            <arg name="b" default="1.9">
                <doc>
                    Equation variable
                </doc>
            </arg>
            <arg name="xi" default="0">
                <doc>
                    Initial value of x
                </doc>
            </arg>
        </ugen>
        <ugen name="CuspL">
            <rate name="audio"/>
            <doc>
                <text>
                    A linear-interpolating sound generator based on the difference equation:
                    {{{
                    x[n+1] = a - b * sqrt(abs(x[n]))
                    }}}
                </text>
            </doc>
            <arg name="freq" default="SampleRate.ir * 0.5">
                <doc>
                    Iteration frequency in Hertz
                </doc>
            </arg>
            <arg name="a" default="1">
                <doc>
                    Equation variable
                </doc>
            </arg>
            <arg name="b" default="1.9">
                <doc>
                    Equation variable
                </doc>
            </arg>
            <arg name="xi" default="0">
                <doc>
                    Initial value of x
                </doc>
            </arg>
        </ugen>
        <ugen name="FBSineN">
            <rate name="audio"/>
            <doc>
                <text>
                    A non-interpolating sound generator based on the difference equations:
                    {{{
                        x[n+1] = sin(im * y[n] + fb * x[n])
                        y[n+1] = (a * y[n] + c) % 2pi
                    }}}
                    This uses a linear congruential function to drive the phase indexing of a sine wave. For  im = 1 ,  fb = 0 , and  a = 1 a normal sinewave results.
                </text>
            </doc>
            <arg name="freq" default="SampleRate.ir * 0.5">
                <doc>
                    Iteration frequency in Hertz
                </doc>
            </arg>
            <arg name="im" default="1">
                <doc>
                    Index multiplier amount
                </doc>
            </arg>
            <arg name="fb" default="0.1">
                <doc>
                    Feedback amount
                </doc>
            </arg>
            <arg name="a" default="1.1">
                <doc>
                    Phase multiplier amount
                </doc>
            </arg>
            <arg name="c" default="0.5">
                <doc>
                    Phase increment amount
                </doc>
            </arg>
            <arg name="xi" default="0.1">
                <doc>
                    Initial value of x
                </doc>
            </arg>
            <arg name="yi" default="0.1">
                <doc>
                    Initial value of y
                </doc>
            </arg>
        </ugen>
        <ugen name="FBSineL">
            <rate name="audio"/>
            <doc>
                <text>
                    A non-interpolating sound generator based on the difference equations:
                    {{{
                        x[n+1] = sin(im * y[n] + fb * x[n])
                        y[n+1] = (a * y[n] + c) % 2pi
                    }}}
                    This uses a linear congruential function to drive the phase indexing of a sine wave. For  im = 1 ,  fb = 0 , and  a = 1 a normal sinewave results.
                </text>
            </doc>
            <arg name="freq" default="SampleRate.ir * 0.5">
                <doc>
                    Iteration frequency in Hertz
                </doc>
            </arg>
            <arg name="im" default="1">
                <doc>
                    Index multiplier amount
                </doc>
            </arg>
            <arg name="fb" default="0.1">
                <doc>
                    Feedback amount
                </doc>
            </arg>
            <arg name="a" default="1.1">
                <doc>
                    Phase multiplier amount
                </doc>
            </arg>
            <arg name="c" default="0.5">
                <doc>
                    Phase increment amount
                </doc>
            </arg>
            <arg name="xi" default="0.1">
                <doc>
                    Initial value of x
                </doc>
            </arg>
            <arg name="yi" default="0.1">
            <doc>
                Initial value of y
            </doc>
            </arg>
        </ugen>
        <ugen name="FBSineC">
            <rate name="audio"/>
            <doc>
                <text>
                    A non-interpolating sound generator based on the difference equations:
                    {{{
                        x[n+1] = sin(im * y[n] + fb * x[n])
                        y[n+1] = (a * y[n] + c) % 2pi
                    }}}
                    This uses a linear congruential function to drive the phase indexing of a sine wave. For  im = 1 ,  fb = 0 , and  a = 1 a normal sinewave results.
                </text>
            </doc>
            <arg name="freq" default="SampleRate.ir * 0.5">
                <doc>
                    Iteration frequency in Hertz
                </doc>
            </arg>
            <arg name="im" default="1">
                <doc>
                    Index multiplier amount
                </doc>
            </arg>
            <arg name="fb" default="0.1">
                <doc>
                    Feedback amount
                </doc>
            </arg>
            <arg name="a" default="1.1">
                <doc>
                    Phase multiplier amount
                </doc>
            </arg>
            <arg name="c" default="0.5">
                <doc>
                    Phase increment amount
                </doc>
            </arg>
            <arg name="xi" default="0.1">
                <doc>
                    Initial value of x
                </doc>
            </arg>
            <arg name="yi" default="0.1">
                <doc>
                    Initial value of y
                </doc>
            </arg>
        </ugen>
        <ugen name="GbmanN">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="xi" default="1.2"/>
            <arg name="yi" default="2.1"/>
        </ugen>
        <ugen name="GbmanL">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="xi" default="1.2"/>
            <arg name="yi" default="2.1"/>
        </ugen>
        <ugen name="HenonN">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="a" default="1.4"/>
            <arg name="b" default="0.3"/>
            <arg name="x0" default="0"/>
            <arg name="x1" default="0"/>
        </ugen>
        <ugen name="HenonL">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="a" default="1.4"/>
            <arg name="b" default="0.3"/>
            <arg name="x0" default="0"/>
            <arg name="x1" default="0"/>
        </ugen>
        <ugen name="HenonC">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="a" default="1.4"/>
            <arg name="b" default="0.3"/>
            <arg name="x0" default="0"/>
            <arg name="x1" default="0"/>
        </ugen>
        <ugen name="LatoocarfianN">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="a" default="1"/>
            <arg name="b" default="3"/>
            <arg name="c" default="0.5"/>
            <arg name="d" default="0.5"/>
            <arg name="xi" default="0.5"/>
            <arg name="yi" default="0.5"/>
        </ugen>
        <ugen name="LatoocarfianL">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="a" default="1"/>
            <arg name="b" default="3"/>
            <arg name="c" default="0.5"/>
            <arg name="d" default="0.5"/>
            <arg name="xi" default="0.5"/>
            <arg name="yi" default="0.5"/>
        </ugen>
        <ugen name="LatoocarfianC">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="a" default="1"/>
            <arg name="b" default="3"/>
            <arg name="c" default="0.5"/>
            <arg name="d" default="0.5"/>
            <arg name="xi" default="0.5"/>
            <arg name="yi" default="0.5"/>
        </ugen>
        <ugen name="LinCongN">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="a" default="1.1"/>
            <arg name="c" default="0.13"/>
            <arg name="m" default="1.0"/>
            <arg name="xi" default="0"/>
        </ugen>
        <ugen name="LinCongL">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="a" default="1.1"/>
            <arg name="c" default="0.13"/>
            <arg name="m" default="1.0"/>
            <arg name="xi" default="0"/>
        </ugen>
        <ugen name="LinCongC">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="a" default="1.1"/>
            <arg name="c" default="0.13"/>
            <arg name="m" default="1.0"/>
            <arg name="xi" default="0"/>
        </ugen>
        <ugen name="LorenzL">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="s" default="10"/>
            <arg name="r" default="28"/>
            <arg name="b" default="2.667"/>
            <arg name="h" default="0.05"/>
            <arg name="xi" default="0.1"/>
            <arg name="yi" default="0"/>
            <arg name="zi" default="0"/>
        </ugen>
        <ugen name="QuadN">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="a" default="1"/>
            <arg name="b" default="-1"/>
            <arg name="c" default="-0.75"/>
            <arg name="xi" default="0"/>
        </ugen>
        <ugen name="QuadL">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="a" default="1"/>
            <arg name="b" default="-1"/>
            <arg name="c" default="-0.75"/>
            <arg name="xi" default="0"/>
        </ugen>
        <ugen name="QuadC">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="a" default="1"/>
            <arg name="b" default="-1"/>
            <arg name="c" default="-0.75"/>
            <arg name="xi" default="0"/>
        </ugen>
        <ugen name="StandardN">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="k" default="1.0"/>
            <arg name="xi" default="0.5"/>
            <arg name="yi" default="0"/>
        </ugen>
        <ugen name="StandardL">
            <rate name="audio"/>
            <arg name="freq" default="SampleRate.ir * 0.5"/>
            <arg name="k" default="1.0"/>
            <arg name="xi" default="0.5"/>
            <arg name="yi" default="0"/>
        </ugen>
    </file>

    <file name="DelayUGens">
        <ugen name="ControlRate">
            <rate name="scalar" implied="true"/>
            <doc>
                <text>
                    A UGen that reports the server's current control rate. This is equivalent to the reciprocal
                    of `ControlDur`
                </text>
                <see>ugen.ControlDur</see>
                <see>ugen.SampleRate</see>
            </doc>
        </ugen>
        <ugen name="SampleRate">
            <rate name="scalar" implied="true"/>
            <doc>
                <text>
                    A UGen that reports the server's current (audio) sample rate. This is equivalent to the reciprocal
                    of `SampleDur`
                </text>
                <see>ugen.SampleDur</see>
                <see>ugen.ControlRate</see>
                <see>ugen.RadiansPerSample</see>
            </doc>
        </ugen>
        <ugen name="SampleDur">
            <rate name="scalar" implied="true"/>
            <doc>
                <text>
                    A UGen that reports the server's current (audio) sample period in seconds. This is equivalent to the reciprocal
                    of `SampleRate`
                </text>
                <see>ugen.SampleRate</see>
                <see>ugen.ControlDur</see>
            </doc>
        </ugen>
        <ugen name="ControlDur">
            <rate name="scalar" implied="true"/>
            <doc>
                <text>
                    A UGen that reports the server's current control period in seconds. This is equivalent to the reciprocal
                    of `ControlRate`
                </text>
                <see>ugen.ControlRate</see>
                <see>ugen.SampleDur</see>
            </doc>
        </ugen>
        <ugen name="SubsampleOffset">
            <rate name="scalar" implied="true"/>
            <doc>
                <text>
                    A UGen that reports the fractional sample offset of the current Synth from its requested scheduled start.

                    When a synth is created from a time stamped osc-bundle, it starts
                    calculation at the next possible block (normally 64 samples). Using an
                    `OffsetOut` UGen, one can delay the audio so that it matches sample
                    accurately.

                    For some synthesis methods, one even needs subsample accuracy. `SubsampleOffset`
                    provides the information where, within the current sample, the synth was
                    scheduled. It can be used to offset envelopes or resample the audio
                    output.
                </text>
                <see>ugen.ControlRate</see>
                <see>ugen.SampleDur</see>
            </doc>
        </ugen>
        <ugen name="RadiansPerSample">
            <rate name="scalar" implied="true"/>
            <doc>
                <text>
                    A UGen that delivers the conversion factor from frequency in Hertz to radians (normalized frequency).
                    The relation is `RadiansPerSample * sr = 2pi`, thus multiplying the UGen with a frequency between
                    zero and nyquist (sr/2) yields the normalized frequency between zero and pi.
                </text>
                <see>ugen.SampleRate</see>
            </doc>
        </ugen>
        <ugen name="NumInputBuses">
            <rate name="scalar" implied="true"/>
        </ugen>
        <ugen name="NumOutputBuses">
            <rate name="scalar" implied="true"/>
        </ugen>
        <ugen name="NumAudioBuses">
            <rate name="scalar" implied="true"/>
        </ugen>
        <ugen name="NumControlBuses">
            <rate name="scalar" implied="true"/>
        </ugen>
        <ugen name="NumBuffers">
            <rate name="scalar" implied="true"/>
        </ugen>
        <ugen name="NumRunningSynths">
            <rate name="scalar" implied="true"/>
        </ugen>

        <ugen name="BufSampleRate">
            <rate name="scalar"/>
            <rate name="control"/>
            <arg name="buf"/>
        </ugen>
        <ugen name="BufRateScale">
            <rate name="scalar"/>
            <rate name="control"/>
            <arg name="buf"/>
        </ugen>
        <ugen name="BufSamples">
            <rate name="scalar"/>
            <rate name="control"/>
            <arg name="buf"/>
        </ugen>
        <ugen name="BufFrames">
            <rate name="scalar"/>
            <rate name="control"/>
            <arg name="buf"/>
        </ugen>
        <ugen name="BufChannels">
            <rate name="scalar"/>
            <rate name="control"/>
            <arg name="buf"/>
        </ugen>
        <ugen name="BufDur">
            <rate name="scalar"/>
            <rate name="control"/>
            <arg name="buf"/>
        </ugen>

        <ugen name="PlayBuf" readsbuf="true" sideeffect="true" doneflag="true">
            <rate name="control"/>
            <rate name="audio"/>
            <outputs num="numChannels"/>
            <arg name="numChannels" type="Int">
                <doc>
                    the number of channels that the buffer will be. Since
                    this is a constant, a change in number of channels of the underlying bus must
                    be reflected by creating different SynthDefs. If a buffer identifier is used of a buffer
                    that has a different numChannels then specified in the PlayBuf, it will fail silently.
                </doc>
            </arg>
            <arg name="buf">
                <doc>
                    the identifier of the buffer to use
                </doc>
            </arg>
            <arg name="speed" default="1">
                <doc>
                    1.0 advances the play head by the server's sample rate each second,
                    so 2.0 means doubling speed (and pitch), and 0.5 means half speed (and half pitch).
                    Negative numbers can be used for backwards playback. If the underlying buffer
                    represents a sound at a different sample rate, the rate should be
                    multiplied by `BufRateScale.kr( bufID )` to obtain the correct speed.
                </doc>
            </arg>
            <arg name="trig" default="1">
                <doc>
                    a trigger which causes a jump to the given startPos. A trigger occurs when a
                    signal changes from non-positive to positive (e.g. &lt;= 0 to &gt; 0).
                </doc>
            </arg>
            <arg name="startPos" default="0">
                <doc>
                    sample frame to start playback. This is read when a trigger occurs.
                </doc>
            </arg>
            <arg name="loop" default="1">
                <doc>
                    1 to loop after the play head reaches the buffer end, 0 to not loop. this can be modulated.
                </doc>
            </arg>
            <arg name="doneAction" default="doNothing">
                <doc>
                    what to do when the play head reaches the buffer end.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen to play back samples from a buffer in memory.

                    `PlayBuf` provides a kind of high-level interface to sample-playback, whereas `BufRd`
                    represents a kind of lower-level access. While `BufRd` has a random-access-pointer
                    in the form of a phase input, `PlayBuf` advances the phase automatically based on
                    a given playback speed. `PlayBuf` uses cubic interpolation.
                </text>
                <see>ugen.BufRd</see>
                <see>ugen.DiskIn</see>
                <see>ugen.RecordBuf</see>
                <see>DoneAction</see>
                <see>ugen.Done</see>
                <see>ugen.BufRateScale</see>
                <see>ugen.BufFrames</see>
            </doc>
        </ugen>
        <!-- <ugen name="SimpleLoopBuf">
        </ugen> -->
        <ugen name="RecordBuf" writesbuf="true" doneflag="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="buf" pos="1"/>
            <arg name="offset" default="0" pos="2"/>
            <arg name="recLevel" default="1" pos="3"/>
            <arg name="preLevel" default="0" pos="4"/>
            <arg name="run" default="1" pos="5"/>
            <arg name="loop" default="1" pos="6"/>
            <arg name="trig" default="1" pos="7"/>
            <arg name="doneAction" default="doNothing" pos="8"/>
            <arg name="in" multi="true" pos="0"/>
        </ugen>
        <ugen name="BufRd" readsbuf="true" doneflag="true">
            <rate name="control"/>
            <rate name="audio"/>
            <outputs num="numChannels"/>
            <arg name="numChannels" type="Int">
                <doc>
                    number of channels that the buffer will be.
                    Since this is an integer constant, a change in the number of channels must
                    be reflected by creating different SynthDefs.
                </doc>
            </arg>
            <arg name="buf">
                <doc>
                    the identifier of the buffer to use
                </doc>
            </arg>
            <arg name="index" default="0">
                <doc>
                    audio rate frame-index into the buffer.
                </doc>
            </arg>
            <arg name="loop" default="1">
                <doc>
                    1 to enable looping, 0 to disable looping. this can be modulated.
                </doc>
            </arg>
            <arg name="interp" default="2">
                <doc>
                    1 for no interpolation, 2 for linear, and 4 for cubic interpolation
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen which reads the content of a buffer, using an index pointer.

                    Warning: if the supplied `bufID` refers to a buffer whose number of channels
                    differs from `numChannels`, the UGen will fail silently.

                    An alternative to `BufRd` is `PlayBuf`. While `PlayBuf` plays
                    through the buffer by itself, `BufRd` only moves its read point by the phase input
                    and therefore has no pitch input. `PlayBuf` uses cubic interplation, while
                    `BufRd` has variable interpolation. `PlayBuf` can determine the end of the buffer
                    and issue a done-action.
                </text>
                <see>ugen.PlayBuf</see>
                <see>ugen.BufWr</see>
                <see>ugen.Phasor</see>
                <see>ugen.BufFrames</see>
                <see>ugen.BufRateScale</see>
            </doc>
        </ugen>
        <ugen name="BufWr" writesbuf="true" doneflag="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="buf" pos="1"/>
            <arg name="index" default="0" pos="2"/>
            <arg name="loop" default="1" pos="3"/>
            <arg name="in" multi="true" pos="0"/>
        </ugen>
        <ugen name="Pitch">
            <rate name="control"/>
            <outputs num="2"/>
            <arg name="in">
                <doc>
                    The signal to be analyzed.
                </doc>
            </arg>
            <arg name="initFreq" default="440">
                <doc>
                    The initial value of the `freq` output, until the first valid pitch is found.
                </doc>
            </arg>
            <arg name="minFreq" default="60">
                <doc>
                    The minimum frequency in Hertz to be considered for reporting.
                    (This parameter is scalar only?)
                </doc>
            </arg>
            <arg name="maxFreq" default="4000">
                <doc>
                    The maximum frequency in Hertz to be considered for reporting.
                    (This parameter is scalar only?)
                </doc>
            </arg>
            <arg name="execFreq" default="100">
                <doc>
                    The frequency at which the pitch is estimated. This will be
                    automatically clipped to be between `minFreq` and `maxFreq`.
                    This parameter is scalar only.
                </doc>
            </arg>
            <arg name="binsPerOct" default="16">
                <doc>
                    A value which guides the search for the peak frequency in the first
                    coarse step. Its setting does *not* affect the final pitch resolution;
                    setting it larger will cause the coarse search to take longer, and setting
                    it smaller will cause the fine search to take longer.
                    This parameter is scalar only.
                </doc>
            </arg>
            <arg name="median" default="1">
                <doc>
                    This specifies the length of a median filter applied to the frequency output
                    estimation. With the default value of `1` the filter is defeated. Median filtering
                    can help eliminating single spikes and jitter. This will however add latency to
                    the output.
                    This parameter is scalar only.
                </doc>
            </arg>
            <arg name="ampThresh" default="0.01">
                <doc>
                    The minimum amplitude threshold above which the pitch follower
                    operates. An input signal below this threshold is not analyzed.
                    (This parameter is scalar only?)
                </doc>
            </arg>
            <arg name="peakThresh" default="0.5">
                <doc>
                    This is a threshold used to find the first peak in the autocorrelation signal which
                    gives the reported frequency. It is a factor of the energy of the signal
                    (autocorrelation coefficient at zero). Set this value higher (e.g. to `1`) to
                    eliminate false frequencies corresponding to overtones.
                    (This parameter is scalar only?)
                </doc>
            </arg>
            <arg name="downSample" default="1">
                <doc>
                    An integer factor by which the input signal is down sampled to reduce CPU overhead.
                    This will also reduce the pitch resolution. The default value of `1` means that
                    the input signal is not down sampled.
                    This parameter is scalar only.
                </doc>
            </arg>
            <arg name="clarity" default="0">
                <doc>
                    If the `clarity` argument is greater than zero (it is zero by default) then the `hasFreq`
                    output is given additional detail. Rather than simply being 1 when a pitch is detected,
                    it is a "clarity" measure in the range between zero and one. (Technically, it's the height
                    of the autocorrelation peak normalised by the height of the zero-lag peak.) It therefore
                    gives a kind of measure of "purity" of the pitched signal.
                    This parameter is scalar only.
                </doc>
            </arg>
            <doc>
                <text>
                    An autocorrelation based pitch following UGen. It is more accurate than `ZeroCrossing`, but
                    more also more CPU costly. For most purposes the default settings can be used and only `in`
                    needs to be supplied.

                    The UGen has two outputs: The first output is the frequency estimate in Hertz, the second
                    output is a toggle `hasFreq`, which tells whether a pitch was found (1) or not (0). If
                    the `clarify` argument is used, `hasFreq` has more fine grained information.

                    The pitch follower executes periodically at the rate specified by `execFreq` in cps.
                    First it detects whether the input peak to peak amplitude is above the `ampThresh`.
                    If it is not then no pitch estimation is performed, the `hasFreq` output is set to zero
                    and the `freq` output is held at its previous value. Otherwise, the autocorrelation is
                    calculated, and the first peak after the peak around the lag of zero that is
                    above `peakThresh` times the amplitude of the peak at lag zero is reported.
                </text>
            </doc>
        </ugen>

        <!-- do these set the done flag? XXX -->
        <ugen name="BufDelayN" readsbuf="true" writesbuf="true">
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in"/>
            <arg name="delayTime" default="0.2"/>
        </ugen>
        <ugen name="BufDelayL" readsbuf="true" writesbuf="true">
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in"/>
            <arg name="delayTime" default="0.2"/>
        </ugen>
        <ugen name="BufDelayC" readsbuf="true" writesbuf="true">
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in"/>
            <arg name="delayTime" default="0.2"/>
        </ugen>
        <ugen name="BufCombN" readsbuf="true" writesbuf="true">
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
        </ugen>
        <ugen name="BufCombL" readsbuf="true" writesbuf="true">
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
        </ugen>
        <ugen name="BufCombC" readsbuf="true" writesbuf="true">
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
        </ugen>
        <ugen name="BufAllpassN" readsbuf="true" writesbuf="true">
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
        </ugen>
        <ugen name="BufAllpassL" readsbuf="true" writesbuf="true">
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
        </ugen>
        <ugen name="BufAllpassC" readsbuf="true" writesbuf="true">
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
        </ugen>

        <ugen name="DelayN">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="maxDelayTime" default="0.2"/>
            <arg name="delayTime" default="0.2"/>
        </ugen>
        <ugen name="DelayL">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="maxDelayTime" default="0.2"/>
            <arg name="delayTime" default="0.2"/>
        </ugen>
        <ugen name="DelayC">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="maxDelayTime" default="0.2"/>
            <arg name="delayTime" default="0.2"/>
        </ugen>
        <ugen name="CombN">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="in"/>
            <arg name="maxDelayTime" default="0.2"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
        </ugen>
        <ugen name="CombL">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="in"/>
            <arg name="maxDelayTime" default="0.2"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
        </ugen>
        <ugen name="CombC">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="in"/>
            <arg name="maxDelayTime" default="0.2"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
        </ugen>
        <ugen name="AllpassN">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="maxDelayTime" default="0.2"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
        </ugen>
        <ugen name="AllpassL">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="maxDelayTime" default="0.2"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
        </ugen>
        <ugen name="AllpassC">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="maxDelayTime" default="0.2"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
        </ugen>

        <ugen name="PitchShift">
            <rate name="audio" implied="true"/>
            <arg name="in"/>
            <arg name="winSize" default="0.2"/>
            <arg name="pitchRatio" default="1"/>
            <arg name="pitchDispersion" default="0"/>
            <arg name="timeDispersion" default="0"/>
        </ugen>
        <!-- this should exist according to plugin sources...
        <ugen name="GrainTap"/>
        -->
        <ugen name="TGrains" readsbuf="true">  <!-- accepts demand rate -->
            <rate name="audio" implied="true"/>
            <outputs num="numChannels"/>
            <arg name="numChannels" type="Int"/>
            <arg name="trig"/>
            <arg name="buf"/>
            <arg name="speed" default="1"/>
            <arg name="centerPos" default="0"/>
            <arg name="dur" default="0.1"/>
            <arg name="pan" default="0"/>
            <arg name="amp" default="0.1"/>
            <arg name="interp" default="4"/>
        </ugen>
        <ugen name="ScopeOut" writesbuf="true"> <!-- XXX zero outputs? -->
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="buf"/>
            <arg name="in" multi="true"/>
        </ugen>
        <ugen name="Pluck">
            <rate name="audio" implied="true"/>
            <arg name="in"/>
            <arg name="trig" default="1"/>
            <arg name="maxDelayTime" default="0.2"/>
            <arg name="delayTime" default="0.2"/>
            <arg name="decayTime" default="1"/>
            <arg name="coef" default="0.5"/>
        </ugen>

        <ugen name="DelTapWr" writesbuf="true">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="buf"/>
            <arg name="in"/>
        </ugen>
        <ugen name="DelTapRd" readsbuf="true">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="buf"/>
            <arg name="phase"/>
            <arg name="delayTime"/>
            <arg name="interp" default="1"/>
        </ugen>

        <!-- XXX TODO
        <ugen name="LocalBuf">
        </ugen>
        <ugen name="MaxLocalBufs">
        </ugen>
        <ugen name="SetBuf">
        </ugen>
        <ugen name="ClearBuf">
        </ugen> -->
    </file>

    <file name="DemandUGens">
        <ugen name="Demand"> <!-- note: might get a Done flag some day -->
            <rate name="control"/>
            <rate name="audio"/>
            <outputs num="in"/>
            <arg name="trig" pos="0">
                <doc>
                    trigger. Can be any signal. A trigger happens when the signal changes from non-positive to positive.
                </doc>
            </arg>
            <arg name="reset" default="0" pos="2">
                <doc>
                    trigger. Resets the list of ugens (`in`) when triggered.
                </doc>
            </arg>
            <arg name="in" multi="true" pos="1">
                <doc>
                    a demand-rate signal (possibly multi-channel) which is read at each trigger
                </doc>
            </arg>
            <doc warnpos="true">
                <text>
                    A UGen which polls results from demand-rate ugens when receiving a trigger.
                    When there is a trigger at the `trig` input, a value is demanded from each ugen in the `in` input
                    and output. The unit generators in the list should be demand-rate.
                    When there is a trigger at the reset input, the demand rate ugens in the list are reset.

                    Note: By design, a reset trigger only resets the demand ugens; it does not reset the value at Demand's output.
                    Demand continues to hold its value until the next value is demanded, at which point its output value will
                    be the first expected item in the `in` argument.

                    Note: One demand-rate ugen represents a single stream of values, so that embedding the same ugen twice
                    calls this stream twice per demand, possibly yielding different values. To embed the same sequence
                    twice, either make sure the ugen is demanded only once, or create two instances of the ugen.

                    '''Warning''': Demand currently seems to have problems with infinite sequences. As a workaround
                    use a very large length instead. E.g. instead of `Dbrown( 0, 1, inf )` use `Dbrown( 0, 1, 0xFFFFFFFF )`!
                </text>
            </doc>
            <see>ugen.Duty</see>
            <see>ugen.TDuty</see>
        </ugen>
        <ugen name="Duty">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="dur" default="1">
                <doc>
                    the provider of time values. Can be a demand-rate ugen or any signal.
                    The next poll is acquired after the previous duration.
                </doc>
            </arg>
            <arg name="reset" default="0">
                <doc>
                    a trigger which resets the dur input (if demand-rated) and the
                    the level input ugen. The reset input may also be a demand-rate ugen, in this case
                    providing a stream of reset times.
                </doc>
            </arg>
            <arg name="level">
                <doc>
                    a demand-rate ugen providing the output values.
                </doc>
            </arg>
            <arg name="doneAction" default="doNothing">
                <doc>
                    a doneAction that is evaluated when the duration stream ends.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen which polls results from demand-rate ugens in intervals specified by a durational input.
                    A value from the `level` ugen is demanded and output according to a stream
                    of duration values. When there is a trigger at the reset input, the `level`
                    and the `dur` input are reset.
                </text>
                <see>ugen.TDuty</see>
                <see>ugen.Demand</see>
                <see>DoneAction</see>
            </doc>
        </ugen>
        <ugen name="TDuty">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="dur" default="1">
                <doc>
                    the provider of time values. Can be a demand-rate ugen or any signal.
                    The next poll is acquired after the previous duration.
                </doc>
            </arg>
            <arg name="reset" default="0">
                <doc>
                    a trigger which resets the dur input (if demand-rated) and the
                    the level input ugen. The reset input may also be a demand-rate ugen, in this case
                    providing a stream of reset times.
                </doc>
            </arg>
            <arg name="level" default="1">
                <doc>
                    a demand-rate ugen providing the output values.
                </doc>
            </arg>
            <arg name="doneAction" default="doNothing">
                <doc>
                    a doneAction that is evaluated when the duration stream ends.
                </doc>
            </arg>
            <arg name="gapFirst" default="0">
                <doc>
                    when 0 (default), the UGen does the first level poll immediately and then
                    waits for the first durational value. When this is 1, the UGen initially polls the first
                    durational value, waits for that duration, and then polls the first level
                    (along with polling the next durational value).
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen which polls results from demand-rate ugens in intervals specified by a durational input,
                    and outputs them as trigger values.
                    A value from the `level` ugen is demanded and output for one sample (when
                    running at audio-rate) or one block (when running at control-rate) according to a stream
                    of duration values. When there is a trigger at the reset input, the `level` and
                    the `dur` input are reset.
                </text>
                <see>ugen.Duty</see>
                <see>ugen.Demand</see>
                <see>DoneAction</see>
            </doc>
        </ugen>
        <ugen name="DemandEnvGen">
            <!-- XXX TODO: tricky rate constraint: if either of gate
            and reset is audio-rate, the other needs to be, too -->
            <rate name="audio"/>
            <arg name="levels">
                <doc>
                    demand-rate ugen (or other ugen) returning level values
                </doc>
            </arg>
            <arg name="durs">
                <doc>
                    demand-rate ugen (or other ugen) returning durational values
                </doc>
            </arg>
            <arg name="shapes" default="1">
                <doc>
                    demand-rate ugen (or other ugen) returning shape number for the envelope segment.
                </doc>
            </arg>
            <arg name="curvatures" default="0">
                <doc>
                    demand-rate ugen (or other ugen) returning curvature values. these are
                    used for curveShape segments (shape number 5) and should be zero for other shapes.
                </doc>
            </arg>
            <arg name="gate" default="1">
                <doc>
                    a control rate gate: if gate is x &gt;= 1, the ugen runs.
                    if gate is 0 &gt; x &gt; 1, the ugen is released at the next level (according to doneAction).
                    if gate is x &lt;= 0, the ugen is sampled end held.
                </doc>
            </arg>
            <arg name="reset" default="1">
                <doc>
                    a trigger signal. a trigger occurs when passing from non-positive to positive.
                    when the trigger amplitude is &lt; 1, the input ugens (those that are demand-rated)
                    are reset when the current segment ends. if the trigger amplitude is &gt; 1,
                    the reset is performed immediately.
                </doc>
            </arg>
            <arg name="levelScale" default="1">
                <doc>
                    demand-rate ugen returning level scaling values
                </doc>
            </arg>
            <arg name="levelBias" default="0">
                <doc>
                    demand-rate ugen returning level offset values
                </doc>
            </arg>
            <arg name="timeScale" default="1">
                <doc>
                    demand-rate ugen returning time scaling values
                </doc>
            </arg>
            <arg name="doneAction" default="doNothing">
                <doc>
                    a done action performed when one of the demand-rated series ends
                </doc>
            </arg>
            <doc>
                <text>
                    An envelope generator UGen using demand-rate inputs for the envelope segments.
                    For each parameter of the envelope (levels, durations and shapes), values are polled
                    every time a new segment starts.
                </text>
                <see>ugen.EnvGen</see>
                <see>EnvShape</see>
                <see>DoneAction</see>
            </doc>
        </ugen>
        <ugen name="Dseries" indiv="true">
            <rate name="demand" implied="true" method="apply"/>
            <arg name="start" default="0">
                <doc>
                    the start value of the series
                </doc>
            </arg>
            <arg name="step" default="1">
                <doc>
                    the incremental step by which the series changes. the step is
                    added to the previous value on each demand.
                </doc>
            </arg>
            <arg name="length" default="inf">
                <doc>
                    the number of elements to produces (maybe be infinite)
                </doc>
            </arg>
            <doc>
                <text>
                    A demand-rate UGen which produces an arithmetic (linear) series.

                    The arguments can be constant or any other ugens.
                </text>
                <see>ugen.Dgeom</see>
                <see>ugen.Dseq</see>
            </doc>
        </ugen>
        <ugen name="Dgeom" indiv="true">
            <rate name="demand" implied="true" method="apply"/>
            <arg name="start" default="1"/>
            <arg name="grow" default="2"/>
            <arg name="length" default="inf"/>
        </ugen>
        <ugen name="Dwhite" indiv="true" random="true">
            <rate name="demand" implied="true" method="apply"/>
            <arg name="lo" default="0"/>
            <arg name="hi" default="1"/>
            <arg name="length" default="inf"/>
        </ugen>
        <ugen name="Dbrown" indiv="true" random="true">
            <rate name="demand" implied="true" method="apply"/>
            <arg name="lo" default="0"/>
            <arg name="hi" default="1"/>
            <arg name="step" default="0.01"/>
            <arg name="length" default="inf"/>
        </ugen>
        <ugen name="Diwhite" indiv="true" random="true">
            <rate name="demand" implied="true" method="apply"/>
            <arg name="lo" default="0"/>
            <arg name="hi" default="1"/>
            <arg name="length" default="inf"/>
        </ugen>
        <ugen name="Dseq" indiv="true">
            <rate name="demand" implied="true" method="apply"/>
            <arg name="repeats" default="1" pos="1"/>
            <arg name="seq" multi="true" pos="0"/>
        </ugen>
        <ugen name="Dser" indiv="true">
            <rate name="demand" implied="true" method="apply"/>
            <arg name="repeats" default="1" pos="1"/>
            <arg name="seq" multi="true" pos="0"/>
        </ugen>
        <ugen name="Dbufrd" indiv="true" readsbuf="true" doneflag="true">
            <rate name="demand" implied="true" method="apply"/>
            <arg name="buf">
                <doc>
                    the identifier of the buffer to read out
                </doc>
            </arg>
            <arg name="index" default="0">
                <doc>
                    the frame index into the buffer
                </doc>
            </arg>
            <arg name="loop" default="1">
                <doc>
                    whether to wrap an exceeding phase around the buffer length (1) or not (0)
                </doc>
            </arg>
            <doc>
                <text>
                    A demand-rate UGen that reads out a buffer. All inputs can be either demand ugen or any other ugen.
                </text>
                <see>ugen.BufRd</see>
                <see>ugen.Dbufwr</see>
            </doc>
        </ugen>
        <ugen name="Dbufwr" indiv="true" writesbuf="true">
            <rate name="demand" implied="true" method="apply"/>
            <arg name="in"/>
            <arg name="buf"/>
            <arg name="index" default="0"/>
            <arg name="loop" default="1"/>
        </ugen>
        <ugen name="Drand" indiv="true" random="true">
            <rate name="demand" implied="true" method="apply"/>
            <arg name="repeats" default="1" pos="1"/>
            <arg name="seq" multi="true" pos="0"/>
        </ugen>
        <ugen name="Dxrand" indiv="true" random="true">
            <rate name="demand" implied="true" method="apply"/>
            <arg name="repeats" default="1" pos="1"/>
            <arg name="seq" multi="true" pos="0"/>
        </ugen>
        <ugen name="Dshuf" indiv="true" random="true">
            <rate name="demand" implied="true" method="apply"/>
            <arg name="repeats" default="1" pos="1"/>
            <arg name="seq" multi="true" pos="0"/>
        </ugen>
        <ugen name="Dswitch1" indiv="true">
            <rate name="demand" implied="true" method="apply"/>
            <arg name="index" pos="1"/>
            <arg name="seq" multi="true" pos="0"/>
        </ugen>
        <ugen name="Dswitch" indiv="true">
            <rate name="demand" implied="true" method="apply"/>
            <arg name="index" pos="1"/>
            <arg name="seq" multi="true" pos="0"/>
        </ugen>
        <ugen name="Dstutter" indiv="true">
            <rate name="demand" implied="true" method="apply"/>
            <arg name="n"/>
            <arg name="in"/>
        </ugen>
        <ugen name="Donce" indiv="true">
            <rate name="demand" implied="true" method="apply"/>
            <arg name="in"/>
        </ugen>
        <ugen name="Dreset" indiv="true">
            <rate name="demand" implied="true" method="apply"/>
            <arg name="in"/>
            <arg name="reset"/>
        </ugen>
        <ugen name="Dpoll">
            <arg name="in" pos="0">
                <doc>
                    the signal you want to poll
                </doc>
            </arg>
            <arg name="trigID" default="-1" pos="3">
                <!-- !verify! <doc>
                    if greater then 0, a `"/tr"` OSC message is sent back to the client
                    (similar to `SendTrig`)
                </doc> -->
            </arg>
            <arg name="run" default="1" pos="2">
                <doc>
                    if 1 the polling is active, if 0 it is inactive.
                </doc>
            </arg>
            <arg name="label" type="String" default="poll" pos="1">
                <doc>
                    a string or symbol to be printed with the polled value
                </doc>
            </arg>
            <doc>
                <text>
                    A demand rate UGen printing the current output value of its input to the console when polled.
                </text>
                <see>ugen.SendTrig</see>
                <see>ugen.Poll</see>
            </doc>
        </ugen>
    </file>

    <file name="DiskIOUGens">
        <!-- // side-effect: advancing sf offset -->
        <ugen name="DiskIn" readsbuf="true" sideeffect="true">
            <rate name="audio" implied="true"/>
            <outputs num="numChannels"/>
            <arg name="numChannels" type="Int">
                <doc>
                    the amount of channels the file and the buffer will have. This is an Int and hence
                    must be pre-determined. Different SynthDefs must be created for different numbers of channels.
                </doc>
            </arg>
            <arg name="buf">
                <doc>
                    the id of the buffer with the correct number of channels and frames
                </doc>
            </arg>
            <arg name="loop" default="0">
                <doc>
                    whether the file should loop when its end is reached
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen to stream in a signal from an audio file. Continuously plays a longer audio file
                    from disk. This requires a buffer to be preloaded with one buffer size of sound. If loop is
                    set to 1, the file will loop.

                    '''Note''': The buffer size must be a multiple of (2 * the server's block size). See
                    `Buffer#cue` for details.
                </text>
                <see>Buffer#cue</see>
                <see>ugen.VDiskIn</see>
                <see>ugen.PlayBuf</see>
            </doc>
        </ugen>

        <ugen name="DiskOut" writesbuf="true">
            <rate name="audio" implied="true"/>
            <arg name="buf">
                <doc>
                    the buffer used internally by the UGen. this number of frames in the buffer must
                    be a power of two (this is currently not checked!). The buffer must have been initialized
                    with a `write` command whose `leaveOpen` argument is true. Note that the number of channels of
                    the buffer and of the input signal must be the same, otherwise `DiskOut` will fail silently
                    (and not write anything to the file).
                </doc>
            </arg>
            <arg name="in" multi="true" rate="ugen">
                <doc>
                    the signal to be recorded
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen which writes a signal to a soundfile on disk. To achieve this efficiently, a buffer is
                    needs to be provides which is used to buffer the incoming signal.

                    '''Note''': It might be that the buffer size must be a multiple of (2 * the server's block size).
                    We haven't currently verified this, but to be safe, you should make sure this property is met.

                    The signal output by the UGen represents the number of frames written.
                </text>
                <see>Buffer#write</see>
                <see>ugen.DiskIn</see>
                <see>ugen.RecordBuf</see>
            </doc>
        </ugen>

        <!-- // side-effect: advancing sf offset -->
        <ugen name="VDiskIn" readsbuf="true" sideeffect="true">
            <!-- note: argument 'rate' renamed to 'speed' -->
            <rate name="audio" implied="true"/>
            <outputs num="numChannels"/>
            <arg name="numChannels" type="Int">
                <doc>
                    the amount of channels the file and the buffer will have. This is an Int and hence
                    must be pre-determined. Different SynthDefs must be created for different numbers of channels
                </doc>
            </arg>
            <arg name="buf">
                <doc>
                    the id of the buffer with the correct number of channels and frames
                </doc>
            </arg>
            <arg name="speed" default="1">
                <doc>
                    controls the speed of playback. Values below 4 are probably fine, but the higher the value,
                    the more disk activity there is, and the more likelihood there will be a problem.
                    The following must be true: `rate &lt; bufFrames / (2 * blockSize)`, e.g with typical default
                    values, this will be `32768 / (2 * 64) = 256`.
                </doc>
            </arg>
            <arg name="loop" default="0">
                <doc>
                    whether the file should loop when its end is reached
                </doc>
            </arg>
            <arg name="sendID" default="0">
                <doc>
                    If a value other than zero is used, the UGen sends an OSC message with this id and the
                    file position each time it reloads the buffer: `OSCMessage( "/diskin", nodeID, sendID, frame )`
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen to stream in a signal from an audio file with variable playback speed.
                    Continuously plays a longer audio file
                    from disk. This requires a buffer to be preloaded with one buffer size of sound. If loop is
                    set to 1, the file will loop.

                    '''Note''': The buffer size must be a multiple of (2 * the server's block size). See
                    `Buffer#cue` for details.

                    If the speed is too high, the UGen will not execute, posting a warning.
                </text>
                <see>Buffer#cue</see>
                <see>ugen.DiskIn</see>
                <see>ugen.DiskOut</see>
                <see>ugen.PlayBuf</see>
            </doc>
        </ugen>
    </file>

    <file name="DynNoiseUGens">
        <ugen name="LFDNoise0" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="500">
                <doc>
                    rate at which to generate random values.
                </doc>
            </arg>
            <doc>
                <text>
                    A dynamic step noise UGen. Like `LFNoise0`, it generates abruptly changing random values
                    between `-1` and `+1` at a rate given by the `freq` argument, with two differences:
                    There is no time quantization, and it there is fast recovery from low freq values.

                    In contrast, `LFNoise0`, `LFNoise1`, and `LFNoise2` quantize to the nearest integer division
                    of the samplerate, and they poll the freq argument only when scheduled, and thus seem
                    to hang when freqs get very low.

                    If very high or very low freqs are not needed, or fixed freqs are used,
                    `LFNoise0` is more efficient.
                </text>
                <see>ugen.LFNoise0</see>
                <see>ugen.LFDNoise1</see>
                <see>ugen.LFDNoise2</see>
                <see>ugen.TRand</see>
            </doc>
        </ugen>
        <ugen name="LFDNoise1" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="500">
                <doc>
                    rate at which to generate random values.
                </doc>
            </arg>
            <doc>
                <text>
                    A dynamic ramp noise UGen. Like `LFNoise1`, it generates linearly interpolated random values
                    between `-1` and `+1` at a rate given by the `freq` argument, with two differences:
                    There is no time quantization, and it there is fast recovery from low freq values.

                    In contrast, `LFNoise0`, `LFNoise1`, and `LFNoise2` quantize to the nearest integer division
                    of the samplerate, and they poll the freq argument only when scheduled, and thus seem
                    to hang when freqs get very low.

                    If very high or very low freqs are not needed, or fixed freqs are used,
                    `LFNoise1` is more efficient.
                </text>
                <see>ugen.LFNoise1</see>
                <see>ugen.LFDNoise0</see>
                <see>ugen.LFDNoise2</see>
                <see>ugen.Ramp</see>
            </doc>
        </ugen>
        <ugen name="LFDNoise3" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="500">
                <doc>
                    rate at which to generate random values.
                </doc>
            </arg>
        </ugen>
        <ugen name="LFDClipNoise" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="500">
                <doc>
                    rate at which to generate random values.
                </doc>
            </arg>
        </ugen>
    </file>

    <file name="FFT_UGens">
        <ugen name="FFT" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="buf">
                <doc>
                    The buffer to use for writing the FFT to. The size must be a power of two.
                    Since `FFT` operates at control rate (also being a power of two),
                    the buffer should probably be at least as long as the control block size.
                </doc>
            </arg>
            <arg name="in">
                <doc>
                    The time domain signal to be transformed into the spectral domain.
                </doc>
            </arg>
            <arg name="hop" default="0.5">
                A factor determining the step size between successive FFTs. That is, FFTs are performed
                every fftSize * hop sample frames. The default of 0.5 means thus a 50% overlap, while
                a hope of 1.0 means no overlapping. Choosing 0.0 will most likely crash the server!
            </arg>
            <arg name="winType" default="0">
                <doc>
                    The window function applied before each FFT is taken. The default of 0 is a
                    sine window which is good for phase vocoder applications (using the `PV_...` UGens).
                    For analysis applications, you may want to use -1 which is a rectangle window
                    (effectively no windowing) or 1 which is a Hann window. A Hann window gives
                    perfect overlap-add reconstruction for a hope size of 0.5 (or 0.25 etc.)
                </doc>
            </arg>
            <arg name="active" default="1">
                <doc>
                    This parameter can be temporarily set to &lt;= 0 to pause the FFT operation.
                </doc>
            </arg>
            <arg name="winSize" default="0">
                <doc>
                    With the default value of zero, the window size equals the fft size. If you wish to
                    perform zero padding, an explicit window size can be specified.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen performing short-time forward fourier transformations. In order to properly link
                    the spectral ugens (`PV_...`), you should begin by using the output of each UGen
                    (which is just the fft buffer identifier), and use that as buffer input of the next UGen.
                    That way, the UGen graph is correctly sorted. E.g. `IFFT( PV_...( FFT( buf, in )))`.

                    The UGen will initially output zero until the first FFT can be performed. This is the
                    case after `hop * fftSize`. Thus for a default fft buffer size of 1024 and a `hop` of
                    0.5, and for a default control block size of 64, for the first 1024*0.5/64 = 8
                    control blocks the UGen will output zero. This also implies that the first FFT in this
                    case if performed on the first 512 samples of the `in` signal (prepended by 512 zeros).
                    In other words, the first 'full' FFT of the input happens after fftSize/controlBlockSize
                    cycles, no matter what hop size was chosen.

                    If you use FFT for performing signal analysis and not phase vocoding effects, make sure
                    you change the window type accordingly.
                </text>
                <see>ugen.IFFT</see>
                <see>ugen.FFTTrigger</see>
            </doc>
        </ugen>
        <ugen name="IFFT" readsfft="true">
            <rate name="control"/>
            <rate name="audio" methodalias="apply"/>
            <arg name="chain"/>
            <arg name="winType" default="0"/>
            <arg name="winSize" default="0"/>
        </ugen>
        <ugen name="FFTTrigger" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="buf">
                <doc>
                    the identifier of the buffer to use
                </doc>
            </arg>
            <arg name="hop" default="0.5">
                <doc>
                    the hop size for timing triggers
                </doc>
            </arg>
            <arg name="polar" default="0">
                <doc>
                    whether the complex buffer content is given in cartesian coordinates (0) or
                    in polar coordinates (1)
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that takes a buffer and prepares it to be used in FFT chains,
                    without doing an actual FFT on a signal. This is useful if you want to provide
                    a buffer whose content had already been transformed into the Fourier domain.
                </text>
            </doc>
        </ugen>

        <ugen name="PV_MagAbove" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <arg name="thresh" default="0">
                <doc>
                    magnitude threshold.
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that passes only those bins whose magnitudes are above a given threshold.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_MagBelow" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <arg name="thresh" default="0">
                <doc>
                    magnitude threshold.
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that passes only those bins whose magnitudes are below a given threshold.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_MagClip" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <arg name="thresh" default="0">
                <doc>
                    magnitude threshold. Each bin's magnitude is limited to
                    be not greater than this threshold.
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that limits (clips) the magnitude of the bins to a given threshold.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_MagMul" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chainA">
                <doc>
                    the first FFT'ed buffer (this gets replaced by
                    the output signal)
                </doc>
            </arg>
            <arg name="chainB">
                <doc>
                    the second FFT'ed buffer
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that multiplies the magnitudes of two inputs and keeps the
                    phases of the first input.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_MagDiv" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chainA">
                <doc>
                    the first FFT'ed buffer (this gets replaced by
                    the output signal)
                </doc>
            </arg>
            <arg name="chainB">
                <doc>
                    the second FFT'ed buffer
                </doc>
            </arg>
            <arg name="zeroes" default="0.0001">
                <doc>
                    the noise floor to assume when detecting zero bins in
                    chainB that would cause a division by zero and hence blow up. The ugen
                    will use divide by this magnitude instead when zeroes are detected,
                    resulting in a maximum boost of `zeroes.reciprocal`.
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that divides magnitudes of two inputs and keeps the
                    phases of the first input.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_MagSquared" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that squares the magnitudes and re-normalizes to previous peak.
                    This makes weak bins weaker.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_MagNoise" readsfft="true" writesfft="true" random="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that multiplies the magnitudes by random noise.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_Copy" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chainA">
                <doc>
                    the first FFT'ed buffer (this gets replaced by
                    the output signal)
                </doc>
            </arg>
            <arg name="chainB">
                <doc>
                    the second FFT'ed buffer
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that copies the spectral frames from chainA
                    to chainB. This allows for parallel processing of spectral data without the
                    need for multiple FFT UGens, and to copy out data at that point in the chain
                    for other purposes. chainA and chainB must be the same size. The output
                    will carry further chainA, so you chan insert the ugen at the appropriate
                    place in the signal chain.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_CopyPhase" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chainA">
                <doc>
                    the first FFT'ed buffer (this gets replaced by
                    the output signal)
                </doc>
            </arg>
            <arg name="chainB">
                <doc>
                    the second FFT'ed buffer
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that combines the magnitudes of first input and phases of the second input.
                    phases of the first input.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_PhaseShift" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <arg name="shift">
                <doc>
                    phase shift in radians
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that shifts the phase of each bins by a given amount.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_PhaseShift90" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that shift the phase of all bins by 90 degrees.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_PhaseShift270" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that shift the phase of all bins by 270 (or -90) degrees.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_Min" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chainA">
                <doc>
                    the first FFT'ed buffer (this gets replaced by
                    the output signal)
                </doc>
            </arg>
            <arg name="chainB">
                <doc>
                    the second FFT'ed buffer
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that outputs the bins with the minimum magnitude
                    of the two inputs.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_Max" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chainA">
                <doc>
                    the first FFT'ed buffer (this gets replaced by
                    the output signal)
                </doc>
            </arg>
            <arg name="chainB">
                <doc>
                    the second FFT'ed buffer
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that outputs the bins with the maximum magnitude
                    of the two inputs.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_Mul" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chainA">
                <doc>
                    the first FFT'ed buffer (this gets replaced by
                    the output signal)
                </doc>
            </arg>
            <arg name="chainB">
                <doc>
                    the second FFT'ed buffer
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that performs a complex multiplication of the
                    two inputs. The formula
                    is `(Re(A) * Re(B) - Im(A) * Im(B)) + i(Im(A) * Re(B) + Re(A) * Im(B))`.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_Div" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chainA">
                <doc>
                    the first FFT'ed buffer (this gets replaced by
                    the output signal)
                </doc>
            </arg>
            <arg name="chainB">
                <doc>
                    the second FFT'ed buffer
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that performs a complex division of the
                    two inputs. Be careful that `chainB`, the divisor, does not
                    contain zeroes as they would obviously blow up the division.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_Add" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chainA">
                <doc>
                    the first FFT'ed buffer (this gets replaced by
                    the output signal)
                </doc>
            </arg>
            <arg name="chainB">
                <doc>
                    the second FFT'ed buffer
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that performs a complex addition of the
                    two inputs. The formula
                    is `(Re(A) + Re(B)) + i(Im(A) + Im(B))`.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_RectComb" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <arg name="numTeeth" default="1">
                <doc>
                    the number of periods in the rectangle wave, where
                    zero would mean the input signal is not affected, one means that
                    there is exactly one period of the wave across the spectrum,
                    hence one pass-band and one stop-band.
                </doc>
            </arg>
            <arg name="phase" default="0">
                <doc>
                    the phase offset of the rectangle wave, where
                    1.0 is one full period. This is like the offset into the wavetable
                    holding the rectangle, so a value of 0.25 means we start 25%
                    into the basic waveform, and after 0.75 periods the next
                    full period (high slope) begins.
                </doc>
            </arg>
            <arg name="width" default="0.5">
                <doc>
                    the pulse width between 0.0 (infinitely small
                    high slope, so all bins filtered out) to 0.5 (half period is
                    high slope, half period is low slope) to 1.0 (maximally
                    wide high slope, no bins filtered out).
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that makes a series of gaps in a spectrum.
                    This is done by multiplying the spectrum with a kind of
                    rectangle wave that goes from zero to nyquist. The high slope
                    of the rectangle lets the input bins pass (quasi pass-band),
                    the low slope filteres them out (quasi stop-band).
                </text>
                <see>ugen.PV_RectComb2</see>
            </doc>
        </ugen>
        <ugen name="PV_RectComb2" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chainA">
                <doc>
                    the first FFT'ed buffer (this gets replaced by the output signal)
                </doc>
            </arg>
            <arg name="chainB">
                <doc>
                    the second FFT'ed buffer
                </doc>
            </arg>
            <arg name="numTeeth" default="1">
                <doc>
                    the number of periods in the rectangle wave, where
                    zero would mean the first input signal is fully passed through, one means that
                    there is exactly one period of the wave across the spectrum,
                    hence one pass-band (first signal passed through) and one stop-band
                    (second signal passed through).
                </doc>
            </arg>
            <arg name="phase" default="0">
                <doc>
                    the phase offset of the rectangle wave, where
                    1.0 is one full period. This is like the offset into the wavetable
                    holding the rectangle, so a value of 0.25 means we start 25%
                    into the basic waveform, and after 0.75 periods the next
                    full period (high slope) begins.
                </doc>
            </arg>
            <arg name="width" default="0.5">
                <doc>
                    the pulse width between 0.0 (infinitely small
                    high slope, so all bins are copied from the second input) to 0.5
                    (half period is high slope -- copied from first input --, half period is
                    low slope -- copied from second input) to 1.0 (maximally
                    wide high slope, so all bins passed from the first input).
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that switches between two input spectra
                    according to a rectangle wave.
                    This is basically identical to `PV_RectComb`, however during the
                    low slopes of the rectangle wavewave, instead of clearing out the bins,
                    it copies over the corresponding bins of the second fft input buffer.
                </text>
                <see>ugen.PV_RectComb</see>
            </doc>
        </ugen>
        <ugen name="PV_BrickWall" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <arg name="wipe">
                <doc>
                    can range between -1 and +1.
                    if wipe == 0 then there is no effect.
                    if  wipe &gt; 0 then it acts like a high pass filter, clearing bins from the bottom up.
                    if  wipe &lt; 0 then it acts like a low pass filter, clearing bins from the top down.
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that clears bins above or below a cutoff point.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_BinWipe" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chainA">
                <doc>
                    the first FFT'ed buffer (this gets replaced by the output signal)
                </doc>
            </arg>
            <arg name="chainB">
                <doc>
                    the second FFT'ed buffer
                </doc>
            </arg>
            <arg name="wipe">
                <doc>
                    can range between -1 and +1.
                    if wipe == 0 then the output is the same as inA.
                    if  wipe &gt; 0 then it begins replacing with bins from inB from the bottom up.
                    if  wipe &lt; 0 then it begins replacing with bins from inB from the top down.
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that combine low and high bins from two inputs.
                    It does so by copiying low bins from one input and the high bins of the other,
                    thus realizes a kind of "wipe" between the two input signals.
                </text>
                <see>ugen.PV_RandWipe</see>
            </doc>
        </ugen>
        <ugen name="PV_LocalMax" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <arg name="thresh" default="0">
                <doc>
                    magnitude threshold used for general filtering, prior to
                    the local-maximum-filtering
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that passes only those bins whose magnitudes constitute local maxima.
                    Additionally, the given threshold is also used to filter out bins whose magnitude
                    lies below this threshold.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_Conj" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that converts the bins into their
                    complex conjugate counterparts. The complex conjugate
                    is equal to the input, but with reversed sign of the imaginary part.
                </text>
            </doc>
        </ugen>

        <ugen name="PV_BinScramble" readsfft="true" writesfft="true" random="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <arg name="wipe" default="0.5">
                <doc>
                    the amount of bins scrambled, from 0 (none) to 1 (all bins scrambled).
                </doc>
            </arg>
            <arg name="width" default="0.2">
                <doc>
                    a value from zero to one, indicating the maximum randomized distance of a bin from its
                    original location in the spectrum.
                </doc>
            </arg>
            <arg name="trig" default="1">
                <doc>
                    causes a new random bin re-ordering to be made. a trigger
                    occurs when passing from non-positive to positive value.
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that randomizes the order of the bins.
                    The trigger will select a new random ordering.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_MagSmear" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <arg name="bins" default="1">
                <doc>
                    number of bins to average on each side of bin. As this number rises, so will CPU usage.
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that averages each bin's magnitude with its neighbors.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_MagShift" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <arg name="stretch" default="1">
                <doc>
                    the factor to multiply each bin position with
                </doc>
            </arg>
            <arg name="shift" default="0">
                <doc>
                    the translation of the spectrum, in number of bins
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that stretches and shifts the magnitudes of the spectrum.
                    This is live `PV_BinShift` but instead of scaling and shifting the whole complex
                    bins (magnitude and phase), this only operates on the magnitudes and leaves
                    the phases in their original bins.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_BinShift" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <arg name="stretch" default="1">
                <doc>
                    the factor to multiply each bin position with, where 0.5 kind of
                    transposes the signal down by an octave, and 2 transposes it up by an octave.
                </doc>
            </arg>
            <arg name="shift" default="0">
                <doc>
                    the translation of the spectrum, in number of bins. Since the
                    FFT produces a linear frequency axis, the will produce harmonic distortion.
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that stretches and shifts the spectrum.
                    It takes each bin, first stretches (scales) its position (bin number)
                    with a given factor, and then adds a shift to it.
                </text>
            </doc>
        </ugen>

        <ugen name="PV_RandWipe" readsfft="true" writesfft="true" random="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chainA">
                <doc>
                    the first FFT'ed buffer (this gets replaced by the output signal)
                </doc>
            </arg>
            <arg name="chainB">
                <doc>
                    the second FFT'ed buffer
                </doc>
            </arg>
            <arg name="wipe">
                <doc>
                    the crossfader position from 0.0 (all bins are
                    taken from `chainA`) to 1.0 (all bins are taken from `chainB`).
                    For instance, if wipe is 0.5, half of the bins are taken from
                    either input. The decision whether a bin is taken from A or B
                    is random, however remains constant between two triggers.
                </doc>
            </arg>
            <arg name="trig">
                <doc>
                    a signal the triggers the re-newed process of
                    determining for each bin whether it will be taken from input
                    A or B. A trigger occurs when passing from non-positive to
                    positive value.
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that crossfades between two input spectra
                    by taking bins randomly from them according to a given probability.
                </text>
                <see>ugen.PV_BinWipe</see>
            </doc>
        </ugen>
        <ugen name="PV_Diffuser" readsfft="true" writesfft="true" random="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <arg name="trig" default="1">
                <doc>
                    to trigger a new selection of random phases. A trigger occurs when
                    passing from non-positive to positive value.
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that adds a different constant random phase shift to each bin.
                    The trigger will select a new set of random phases.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_RandComb" readsfft="true" writesfft="true" random="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <arg name="wipe" default="0.5">
                <doc>
                    the probability (from 0 to 1) of bins being wiped out,
                    hence 0 means no bins are wiped out, 1 means all bins are wiped out
                    (output will be silence).
                </doc>
            </arg>
            <arg name="trig" default="1">
                <doc>
                    causes a new random bin selection to be made. a trigger
                    occurs when passing from non-positive to positive value.
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that randomly clears out bins of the signal.
                    Which bins are wiped out is subject to a random choice (only the amount is
                    specified) that remains constant between triggers.
                </text>
            </doc>
        </ugen>
        <ugen name="PV_MagFreeze" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain">
                <doc>
                    the FFT'ed buffer
                </doc>
            </arg>
            <arg name="freeze" default="1">
                <doc>
                    whether the current levels are frozen (&gt; 0) or not (0).
                </doc>
            </arg>
            <doc>
                <text>
                    A phase vocoder UGen that freezes the magnitudes at current levels.
                    Freezing happens when the freeze input has a value of &gt; 0.
                </text>
            </doc>
        </ugen>

        <ugen name="PartConv" readsbuf="true">
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="fftSize"/>
            <arg name="buf"/>
        </ugen>
    </file>

    <file name="FFT2_UGens">
        <ugen name="Convolution" readsbuf="true">
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="kernel"/>
            <arg name="frameSize"/>
            <doc>
                <see>ugen.Convolution2L</see>
                <see>ugen.Convolution3</see>
                <see>ugen.Convolution2</see>
                <see>ugen.StereoConvolution2L</see>
            </doc>
        </ugen>
        <ugen name="Convolution2" readsbuf="true">
            <rate name="audio"/>
            <arg name="in">
                <doc>
                    the realtime input to be convolved
                </doc>
            </arg>
            <arg name="kernel">
                <doc>
                    buffer identifier for the fixed kernel, which may be modulated in combination with the trigger
                </doc>
            </arg>
            <arg name="trig" default="1">
                <doc>
                    updates the kernel on a change from non-positive to positive (&lt;= 0 to &gt;0)
                </doc>
            </arg>
            <arg name="frameSize">
                <doc>
                    size of the kernel. this must be a power of two. the FFT calculated internally
                    by the UGen has a size of twice this value. The maximum allowed frameSize
                    is 65536(?).
                </doc>
            </arg>
            <doc>
                <text>
                    A frequency-domain convolution UGen using a fixed kernel which can be updated
                    by a trigger signal. The delay caused by the convolution when the kernel is a dirac impulse
                    is equal to `frameSize - (controlBlockSize + 1)` (measured august 2010), so for a frameSize
                    of 2048 and a controlBlockSize of 64, this is 1983 sample frames.
                </text>
                <see>ugen.Convolution2L</see>
                <see>ugen.Convolution3</see>
                <see>ugen.Convolution</see>
                <see>ugen.StereoConvolution2L</see>
            </doc>
        </ugen>
        <ugen name="Convolution2L" readsbuf="true">
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="kernel"/>
            <arg name="trig" default="1"/>
            <arg name="frameSize"/>
            <arg name="fadePeriods" default="1"/>
            <doc>
                <see>ugen.Convolution2</see>
                <see>ugen.Convolution3</see>
                <see>ugen.Convolution</see>
                <see>ugen.StereoConvolution2L</see>
            </doc>
        </ugen>
        <ugen name="StereoConvolution2L" readsbuf="true">
            <rate name="audio"/>
            <outputs num="2"/>
            <arg name="in">
                <doc>
                    the realtime input to be convolved
                </doc>
            </arg>
            <arg name="kernelL">
                <doc>
                    buffer identifier for the left channel's fixed kernel, which may be modulated in combination
                    with the trigger
                </doc>
            </arg>
            <arg name="kernelR">
                <doc>
                    buffer identifier for the right channel's fixed kernel, which may be modulated in combination
                    with the trigger
                </doc>
            </arg>
            <arg name="trig" default="1">
                <doc>
                    updates the kernel on a change from non-positive to positive (&lt;= 0 to &gt;0), and starts a new
                    crossfade from the previous kernel to the new one over the given amount of periods.
                </doc>
            </arg>
            <arg name="frameSize">
                <doc>
                    size of each kernel. this must be a power of two. the FFT calculated internally
                    by the UGen has a size of twice this value. The maximum allowed frameSize
                    is 65536(?).
                </doc>
            </arg>
            <arg name="fadePeriods" default="1">
                <doc>
                    The number of periods over which a crossfade is performed. This must be an integer
                </doc>
            </arg>
            <doc>
                <text>
                    A frequency domain stereo convolution UGen, capable of performing linear crossfades between kernel updates.
                    When receiving a trigger, there is a linear crossfade between the old kernel the new buffer contents.
                    It operates similar to Convolution2L, however uses two buffers and outputs a stereo signal, resulting
                    in better CPU usage than two discrete instances of Convolution2L as this way one FFT transformation per period
                    is saved.
                </text>
                <see>ugen.Convolution2</see>
                <see>ugen.Convolution3</see>
                <see>ugen.Convolution</see>
                <see>ugen.Convolution2L</see>
            </doc>
        </ugen>
        <ugen name="Convolution3" readsbuf="true">
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="kernel"/>
            <arg name="trig" default="1"/>
            <arg name="frameSize"/>
            <doc>
                <text>
                    A UGen for triggered convolution in the time domain.
                </text>
            </doc>
        </ugen>

        <ugen name="PV_ConformalMap" readsfft="true" writesfft="true">
            <rate name="control" implied="true" method="apply"/>
            <arg name="chain"/>
            <arg name="real" default="0"/>
            <arg name="imag" default="0"/>
        </ugen>

        <ugen name="PV_JensenAndersen" readsfft="true">
            <rate name="audio"/>
            <arg name="chain"/>
            <arg name="propSC" default="0.25"/>
            <arg name="propHFE" default="0.25"/>
            <arg name="propHFC" default="0.25"/>
            <arg name="propSF" default="0.25"/>
            <arg name="thresh" default="1.0"/>
            <arg name="waitTime" default="0.04"/>
        </ugen>
        <ugen name="PV_HainsworthFoote" readsfft="true">
            <rate name="audio"/>
            <arg name="chain"/>
            <arg name="propH" default="0.0"/>
            <arg name="propF" default="0.0"/>
            <arg name="thresh" default="1.0"/>
            <arg name="waitTime" default="0.04"/>
        </ugen>

        <ugen name="RunningSum">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    the input signal to sum up
                </doc>
            </arg>
            <arg name="length" default="440">
                <doc>
                    the length of the sliding window over the input signal.
                    these are the number of audio sample-frames for audio-rate calculation,
                    or the number of blocks for control-rate calculation summed up.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen calculating the running sum of an input signal over a given number of samples.
                </text>
            </doc>
        </ugen>
    </file>

    <file name="FilterUGens">
            <ugen name="Ramp">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    the signal to smooth out
                </doc>
            </arg>
            <arg name="dur" default="0.1">
                <doc>
                    the ramp-time (seconds) which is also the interval of the sampling
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen which produces a linear lag (time smear) regarding
                    and input signal. Other than `Lag` which is a feedback
                    filter with exponential decay, `Ramp` applies a linear
                    ramp. This is achieved by sampling the input signal
                    at regular intervals given by the `lagTime` and starting
                    a new line segment after each interval.
                </text>
                <see>ugen.Lag</see>
                <see>ugen.Sweep</see>
            </doc>
        </ugen>
        <ugen name="Lag">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal.
                </doc>
            </arg>
            <arg name="time" default="0.1">
                <doc>
                    60 dB lag time in seconds.
                </doc>
            </arg>
            <doc>
                <text>
                    An exponential lag UGen.
                    This is essentially the same as `OnePole` except that instead of supplying the coefficient directly,
                    it is calculated from a 60 dB lag time. This is the time required for the filter to converge to
                    within 0.01 % of a value. This is useful for smoothing out control signals.
                </text>
                <see>ugen.OnePole</see>
                <see>ugen.LagUD</see>
                <see>ugen.Lag2</see>
                <see>ugen.Ramp</see>
            </doc>
        </ugen>
        <ugen name="Lag2">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal.
                </doc>
            </arg>
            <arg name="time" default="0.1">
                <doc>
                    60 dB lag time in seconds.
                </doc>
            </arg>
            <doc>
                <text>
                    A cascaded exponential lag
                    UGen. `Lag2.kr(in, time)` is equivalent to `Lag.kr(Lag.kr(in, time), time)`,
                    thus resulting in a smoother transition. This saves on CPU as you only have to
                    calculate the decay factor once instead of twice.
                </text>
                <see>ugen.Lag</see>
                <see>ugen.Lag2UD</see>
                <see>ugen.Lag3</see>
            </doc>
        </ugen>
        <ugen name="Lag3">
             <rate name="control"/>
             <rate name="audio"/>
             <arg name="in" rate="ugen">
                 <doc>
                     input signal.
                 </doc>
             </arg>
             <arg name="time" default="0.1">
                 <doc>
                     60 dB lag time in seconds.
                 </doc>
             </arg>
             <doc>
                 <text>
                     A cascaded exponential lag
                    UGen. `Lag3.kr(in, time)` is equivalent to `Lag.kr(Lag.kr(Lag.kr(Lag.kr(in, time), time), time)`,
                    thus resulting in a smoother transition. This saves on CPU as you only have to
                    calculate the decay factor once instead of three times.
                 </text>
                 <see>ugen.Lag</see>
                 <see>ugen.Lag3UD</see>
                 <see>ugen.Lag2</see>
             </doc>
         </ugen>
        <ugen name="LagUD">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal.
                </doc>
            </arg>
            <arg name="timeUp" default="0.1">
                <doc>
                    60 dB lag time in seconds effective during a rising slope in the input signal
                </doc>
            </arg>
            <arg name="timeDown" default="0.1">
                <doc>
                    60 dB lag time in seconds effective during a falling slope in the input signal
                </doc>
            </arg>
            <doc>
                <text>
                    An exponential lag UGen with separate inputs for up and down slope.
                    This is essentially the same as `Lag` except that you can supply a different 60 dB time
                    for when the signal goes up, from when the signal goes down.
                </text>
                <see>ugen.Lag</see>
                <see>ugen.Lag2UD</see>
            </doc>
        </ugen>
        <ugen name="Lag2UD">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal.
                </doc>
            </arg>
            <arg name="timeUp" default="0.1">
                <doc>
                    60 dB lag time in seconds effective during a rising slope in the input signal
                </doc>
            </arg>
            <arg name="timeDown" default="0.1">
                <doc>
                    60 dB lag time in seconds effective during a falling slope in the input signal
                </doc>
            </arg>
            <doc>
                <text>
                    A cascaded exponential lag UGen with separate inputs for up and down
                    slope. `Lag2UD.kr(in, up, down)` is equivalent to `LagUD.kr(LagUD.kr(in, up, down), up, down)`,
                    thus resulting in a smoother transition. This saves on CPU as you only have to
                    calculate the decay factors once instead of twice.
                </text>
                <see>ugen.LagUD</see>
                <see>ugen.Lag2</see>
                <see>ugen.Lag3UD</see>
            </doc>
        </ugen>
        <ugen name="Lag3UD">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal.
                </doc>
            </arg>
            <arg name="timeUp" default="0.1">
                <doc>
                    60 dB lag time in seconds effective during a rising slope in the input signal
                </doc>
            </arg>
            <arg name="timeDown" default="0.1">
                <doc>
                    60 dB lag time in seconds effective during a falling slope in the input signal
                </doc>
            </arg>
            <doc>
                <text>
                    A cascaded exponential lag UGen with separate inputs for up and down
                    slope. `Lag3UD.kr(in, up, down)` is equivalent to `LagUD.kr(LagUD.kr(LagUD.kr(in, up, down), up, down), up, down)`,
                    thus resulting in a smoother transition. This saves on CPU as you only have to
                    calculate the decay factors once instead of three times.
                </text>
                <see>ugen.LagUD</see>
                <see>ugen.Lag3</see>
                <see>ugen.Lag2UD</see>
            </doc>
        </ugen>
        <ugen name="OnePole">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal to be processed
                </doc>
            </arg>
            <arg name="coeff" default="0.5">
                <doc>
                    feedback coefficient. Should be between -1 and +1
                </doc>
            </arg>
            <doc>
                <text>
                    A one pole (IIR) filter UGen.
                    Implements the formula :
                    {{{
                    out(i) = ((1 - abs(coef)) * in(i)) + (coef * out(i-1))
                    }}}
                </text>
                <see>ugen.OneZero</see>
                <see>ugen.Lag</see>
            </doc>
        </ugen>
        <ugen name="OneZero">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal to be processed
                </doc>
            </arg>
            <arg name="coeff" default="0.5">
                <doc>
                    feed forward coefficient. +0.5 makes a two point averaging filter (see also `LPZ1`),
                    -0.5 makes a differentiator (see also `HPZ1`),  +1 makes a single sample delay (see also `Delay1`),
                    -1 makes an inverted single sample delay.
                </doc>
            </arg>
            <doc>
                <text>
                    A one zero (FIR) filter UGen.
                    Implements the formula :
                    {{{
                    out(i) = ((1 - abs(coef)) * in(i)) + (coef * in(i-1))
                    }}}
                </text>
                <see>ugen.OnePole</see>
                <see>ugen.LPZ1</see>
                <see>ugen.HPZ1</see>
                <see>ugen.Delay1</see>
                <see>ugen.Integrator</see>
            </doc>
        </ugen>
        <ugen name="TwoPole">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal to be processed
                </doc>
            </arg>
            <arg name="freq" default="440"/>
            <arg name="radius" default="0.8"/>
        </ugen>
        <ugen name="TwoZero">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal to be processed
                </doc>
            </arg>
            <arg name="freq" default="440"/>
            <arg name="radius" default="0.8"/>
        </ugen>
        <ugen name="Decay">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal to be processed
                </doc>
            </arg>
            <arg name="time" default="1"/>
            <doc>
                <text>
                    An integrator UGen with exponential decay of past values. This is essentially the same
                    as `Integrator` except that instead of supplying the coefficient directly, it is calculated
                    from a 60 dB decay time. This is the time required for the integrator to lose 99.9 % of its
                    value or -60dB.

                    Note: This should not be confused with `Lag` which does not overshoot due to integration,
                    but asymptotically follows the input signal.
                </text>
                <see>ugen.Integrator</see>
                <see>ugen.Decay2</see>
                <see>ugen.Lag</see>
            </doc>
        </ugen>
        <ugen name="Decay2">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal to be processed
                </doc>
            </arg>
            <arg name="attack" default="0.01"/>
            <arg name="release" default="1"/>
            <doc>
                <text>
                    A integrator UGen with controllable attack and release times.
                    While `Decay` has a very sharp attack and can produce clicks, `Decay2` rounds off the attack by
                    subtracting one Decay from another. It can be seen as equivalent to
                    {{{
                    Decay.ar(in, release) - Decay.ar(in, attack)
                    }}}

                    Note: This should not be confused with `LagUD` which does not overshoot due to integration,
                    but asymptotically follows the input signal.
                </text>
                <see>ugen.Decay</see>
                <see>ugen.Integrator</see>
                <see>ugen.LagUD</see>
            </doc>
        </ugen>
        <!-- this should exist according to plugin sources...
        <ugen name="Flip"/>
        -->
        <ugen name="Delay1">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
        </ugen>
        <ugen name="Delay2">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
        </ugen>
        <ugen name="Integrator">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal to be processed
                </doc>
            </arg>
            <arg name="coeff" default="1">
                <doc>
                    the leak coefficient. Should be between -1 and +1
                </doc>
            </arg>
            <doc>
                <text>
                    A filter UGen to integrate an input signal with a leak.
                    Implements the formula :
                    {{{
                    out(i) = in(i) + (coef * out(i-1))
                    }}}
                </text>
                <see>ugen.OnePole</see>
                <see>ugen.HPZ1</see>
                <see>ugen.LPZ1</see>
            </doc>
        </ugen>
        <ugen name="LeakDC">
            <rate name="control">
                <arg name="coeff" default="0.9"/>
            </rate>
            <rate name="audio">
                <arg name="coeff" default="0.995"/>
            </rate>
            <arg name="in" rate="ugen"/>
            <arg name="coeff"/>
        </ugen>
        <ugen name="LPZ1">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal to be processed
                </doc>
            </arg>
            <doc>
                <text>
                    two point average filter UGen.
                    Implements the formula :
                    {{{
                    out(i) = 0.5 * (in(i) + in(i-1))
                    }}}
                </text>
                <see>ugen.OnePole</see>
                <see>ugen.HPZ1</see>
                <see>ugen.Integrator</see>
            </doc>
        </ugen>
        <ugen name="HPZ1">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal to be processed
                </doc>
            </arg>
            <doc>
                <text>
                    A two point difference filter UGen.
                    Implements the formula :
                    {{{
                    out(i) = 0.5 * (in(i) - in(i-1))
                    }}}
                </text>
                <see>ugen.OneZero</see>
                <see>ugen.LPZ1</see>
            </doc>
        </ugen>
        <ugen name="LPZ2">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
        </ugen>
        <ugen name="HPZ2">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
        </ugen>
        <ugen name="BPZ2">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
        </ugen>
        <ugen name="BRZ2">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
        </ugen>
        <ugen name="APF">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="freq" default="440"/>
            <arg name="radius" default="0.8"/>
        </ugen>
        <ugen name="LPF">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="freq" default="440"/>
        </ugen>
        <ugen name="HPF">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="freq" default="440"/>
        </ugen>
        <ugen name="BPF">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="freq" default="440"/>
            <arg name="rq" default="1"/>
        </ugen>
        <ugen name="BRF">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="freq" default="440"/>
            <arg name="rq" default="1"/>
        </ugen>
        <ugen name="RLPF">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="freq" default="440"/>
            <arg name="rq" default="1"/>
        </ugen>
        <ugen name="RHPF">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="freq" default="440"/>
            <arg name="rq" default="1"/>
        </ugen>

        <ugen name="Slew">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal
                </doc>
            </arg>
            <arg name="up" default="1">
                <doc>
                    maximum upward slope.
                </doc>
            </arg>
            <arg name="down" default="1">
                <doc>
                    maximum downward slope.
                </doc>
            </arg>
            <doc>
                <text>
                    A slew rate limiter UGen.
                    Limits the slope of an input signal. The slope is expressed in units per second.
                </text>
            </doc>
        </ugen>
        <ugen name="Slope">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal to be measured
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen measuring the slope of signal.
                    It calculates the rate of change per second of a signal, as given by the following formula:
                    {{{
                    out(i) = (in(i) - in(i-1)) * sampleRate
                    }}}
                    It thus equal to `HPZ1.ar(_) * 2 * SampleRate.ir`
                </text>
            </doc>
        </ugen>

        <ugen name="MidEQ">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="freq" default="440"/>
            <arg name="rq" default="1"/>
            <arg name="gain" default="0"/>
        </ugen>
        <ugen name="Median">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen" pos="0"/>
            <arg name="length" default="3" pos="1"/>
            <doc warnpos="true"/>
        </ugen>

        <ugen name="Resonz">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="freq" default="440"/>
            <arg name="rq" default="1"/>
        </ugen>
        <ugen name="Ringz">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="freq" default="440"/>
            <arg name="attack" default="1"/>
            <arg name="decay" default="1"/>
        </ugen>
        <ugen name="Formlet">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="freq" default="440"/>
            <arg name="attack" default="1"/>
            <arg name="decay" default="1"/>
        </ugen>

        <ugen name="FOS">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="a0" default="0"/>
            <arg name="a1" default="0"/>
            <arg name="b1" default="0"/>
        </ugen>
        <ugen name="SOS">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="a0" default="0"/>
            <arg name="a1" default="0"/>
            <arg name="a2" default="0"/>
            <arg name="b1" default="0"/>
            <arg name="b2" default="0"/>
        </ugen>

        <ugen name="Compander">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in">
                <doc>
                    The signal to be compressed / expanded / gated.
                </doc>
            </arg>
            <arg name="ctrl">
                <doc>
                    The signal whose amplitude controls the processor. Often the same as in, but one may wish
                    to apply equalization or delay to it to change the compressor character (side-chaining), or even feed
                    a completely different signal, for instance in a ducking application.
                </doc>
            </arg>
            <arg name="thresh" default="0.5">
                <doc>
                    Control signal amplitude threshold, which determines the break point between slopeBelow
                    and slopeAbove. Usually 0..1. The control signal amplitude is calculated using RMS.
                </doc>
            </arg>
            <arg name="ratioBelow" default="1">
                <doc>
                    Slope of the amplitude curve below the threshold. If this slope &gt; 1.0, the amplitude
                    will drop off more quickly the softer the control signal gets; when the control signal is close to 0
                    amplitude, the output should be exactly zero -- hence, noise gating. Values &lt; 1.0 are possible,
                    but it means that a very low-level control signal will cause the input signal to be amplified,
                    which would raise the noise floor.
                </doc>
            </arg>
            <arg name="ratioAbove" default="1">
                <doc>
                    Slope of the amplitude curve above the threshold. Values &lt; 1.0 achieve compression
                    (louder signals are attenuated); &gt; 1.0, you get expansion (louder signals are made even louder).
                    For 3:1 compression, you would use a value of 1/3 here.
                </doc>
            </arg>
            <arg name="attack" default="0.01">
                <doc>
                    The amount of time it takes for the amplitude adjustment to kick in fully. This is
                    usually pretty small, not much more than 10 milliseconds (the default value). I often set it as low as
                    2 milliseconds (0.002).
                </doc>
            </arg>
            <arg name="release" default="0.1">
                <doc>
                    The amount of time for the amplitude adjustment to be released. Usually a bit longer
                    than attack; if both times are too short, you can get some (possibly unwanted) artifacts.
                </doc>
            </arg>
            <doc>
                <text>
                    A compressor, expander, limiter, gate and ducking UGen. This dynamic processor uses a
                    hard-knee characteristic. All of the thresholds and ratios are given as direct
                    values, not in decibels!
                </text>
                <see>ugen.Limiter</see>
                <see>ugen.Normalizer</see>
            </doc>
        </ugen>
        <ugen name="Limiter">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="level" default="1"/>
            <arg name="dur" default="0.01"/>
        </ugen>
        <ugen name="Normalizer">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="level" default="1"/>
            <arg name="dur" default="0.01"/>
        </ugen>

        <ugen name="Amplitude">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="attack" default="0.01"/>
            <arg name="release" default="0.01"/>
        </ugen>
        <ugen name="DetectSilence" sideeffect="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="amp" default="0.0001"/>
            <arg name="dur" default="0.1"/>
            <arg name="doneAction" default="doNothing"/>
        </ugen>

        <ugen name="Hilbert">
            <outputs num="2"/>
            <rate name="audio"/>
            <arg name="in"/>
        </ugen>
        <ugen name="FreqShift">
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="freq" default="0"/>
            <arg name="phase" default="0"/>
        </ugen>
        <ugen name="MoogFF">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen"/>
            <arg name="freq" default="200"/>
            <arg name="gain" default="2"/>
            <arg name="reset" default="0"/>
        </ugen>

        <ugen name="BLowPass">
            <rate name="audio" implied="true"/>
            <arg name="in" rate="ugen">
                <doc>
                    input signal to be processed.
                </doc>
            </arg>
            <arg name="freq" default="440">
                <doc>
                    cutoff frequency.
                </doc>
            </arg>
            <arg name="rq" default="1">
                <doc>
                    the reciprocal of Q, hence bandwidth / cutoffFreq.
                </doc>
            </arg>
            <doc>
                <text>
                    A 2nd order (12db per oct rolloff) resonant low pass filter UGen.
                    The B equalization suite is based on the Second Order Section (SOS) biquad UGen.

                    Note: Biquad coefficient calculations imply certain amount of CPU overhead. These
                    plugin UGens contain optimizations such that the coefficients get updated only when
                    there has been a change to one of the filter's parameters. This can cause spikes in
                    CPU performance and should be considered when using several of these units.
                </text>
            </doc>
        </ugen>
        <ugen name="BHiPass">
            <rate name="audio" implied="true"/>
            <arg name="in" rate="ugen">
                <doc>
                     input signal to be processed.
                 </doc>
            </arg>
            <arg name="freq" default="440">
                <doc>
                    cutoff frequency.
                </doc>
            </arg>
            <arg name="rq" default="1">
                <doc>
                    the reciprocal of Q, hence bandwidth / cutoffFreq.
                </doc>
            </arg>
            <doc>
                <text>
                    A 2nd order (12db per oct rolloff) resonant high pass filter UGen.
                    The B equalization suite is based on the Second Order Section (SOS) biquad UGen.

                    Note: Biquad coefficient calculations imply certain amount of CPU overhead. These
                    plugin UGens contain optimizations such that the coefficients get updated only when
                    there has been a change to one of the filter's parameters. This can cause spikes in
                    CPU performance and should be considered when using several of these units.
                </text>
            </doc>
        </ugen>
        <ugen name="BBandPass">
            <rate name="audio" implied="true"/>
            <arg name="in" rate="ugen">
                <doc>
                     input signal to be processed.
                 </doc>
            </arg>
            <arg name="freq" default="440">
                <doc>
                    center frequency.
                </doc>
            </arg>
            <arg name="bw" default="1">
                <doc>
                    the bandwidth '''in octaves''' between -3 dB frequencies
                </doc>
            </arg>
            <doc>
                <text>
                    An band pass filter UGen.
                    The B equalization suite is based on the Second Order Section (SOS) biquad UGen.

                    Note: Biquad coefficient calculations imply certain amount of CPU overhead. These
                    plugin UGens contain optimizations such that the coefficients get updated only when
                    there has been a change to one of the filter's parameters. This can cause spikes in
                    CPU performance and should be considered when using several of these units.
                </text>
            </doc>
        </ugen>
        <ugen name="BBandStop">
            <rate name="audio" implied="true"/>
            <arg name="in" rate="ugen">
                <doc>
                     input signal to be processed.
                 </doc>
            </arg>
            <arg name="freq" default="440">
                <doc>
                    center frequency.
                </doc>
            </arg>
            <arg name="bw" default="1">
                <doc>
                    the bandwidth '''in octaves''' between -3 dB frequencies
                </doc>
            </arg>
            <doc>
                <text>
                    An band stop (reject) filter UGen.
                    The B equalization suite is based on the Second Order Section (SOS) biquad UGen.

                    Note: Biquad coefficient calculations imply certain amount of CPU overhead. These
                    plugin UGens contain optimizations such that the coefficients get updated only when
                    there has been a change to one of the filter's parameters. This can cause spikes in
                    CPU performance and should be considered when using several of these units.
                </text>
            </doc>
        </ugen>
        <ugen name="BPeakEQ">
            <rate name="audio" implied="true"/>
            <arg name="in" rate="ugen">
                <doc>
                     input signal to be processed.
                 </doc>
            </arg>
            <arg name="freq" default="440">
                <doc>
                    center frequency.
                </doc>
            </arg>
            <arg name="rq" default="1">
                <doc>
                    the reciprocal of Q, hence bandwidth / cutoffFreq.
                </doc>
            </arg>
            <arg name="gain" default="0">
                <doc>
                    boost/cut at the center frequency (in decibels).
                </doc>
            </arg>
            <doc>
                <text>
                    An parametric equalizer UGen.
                    The B equalization suite is based on the Second Order Section (SOS) biquad UGen.

                    Note: Biquad coefficient calculations imply certain amount of CPU overhead. These
                    plugin UGens contain optimizations such that the coefficients get updated only when
                    there has been a change to one of the filter's parameters. This can cause spikes in
                    CPU performance and should be considered when using several of these units.
                </text>
            </doc>
        </ugen>
        <ugen name="BAllPass">
            <rate name="audio" implied="true"/>
            <arg name="in" rate="ugen">
                <doc>
                     input signal to be processed.
                 </doc>
            </arg>
            <arg name="freq" default="440">
                <doc>
                    cutoff frequency.
                </doc>
            </arg>
            <arg name="rq" default="1">
                <doc>
                    the reciprocal of Q, hence bandwidth / cutoffFreq.
                </doc>
            </arg>
            <doc>
                <text>
                    An all pass filter UGen.
                    The B equalization suite is based on the Second Order Section (SOS) biquad UGen.

                    Note: Biquad coefficient calculations imply certain amount of CPU overhead. These
                    plugin UGens contain optimizations such that the coefficients get updated only when
                    there has been a change to one of the filter's parameters. This can cause spikes in
                    CPU performance and should be considered when using several of these units.
                </text>
            </doc>
        </ugen>
        <ugen name="BLowShelf">
            <rate name="audio" implied="true"/>
            <arg name="in" rate="ugen">
                <doc>
                     input signal to be processed.
                 </doc>
            </arg>
            <arg name="freq" default="440">
                <doc>
                    cutoff frequency.
                </doc>
            </arg>
            <arg name="rs" default="1">
                <doc>
                    the reciprocal of the slope S (Shell boost/cut slope).
                    When `S = 1`, the shelf slope is as steep as it can be and remain monotonically increasing
                    or decreasing gain with frequency.  The shelf slope, in dB/octave, remains proportional to
                    S for all other values for a fixed freq/sample-rate and `gain`.
                </doc>
            </arg>
            <arg name="gain" default="0">
                <doc>
                    boost/cut at the cutoff frequency (in decibels).
                </doc>
            </arg>
            <doc>
                <text>
                    A low shelf equalizer UGen.
                    The B equalization suite is based on the Second Order Section (SOS) biquad UGen.

                    Note: Biquad coefficient calculations imply certain amount of CPU overhead. These
                    plugin UGens contain optimizations such that the coefficients get updated only when
                    there has been a change to one of the filter's parameters. This can cause spikes in
                    CPU performance and should be considered when using several of these units.
                </text>
            </doc>
        </ugen>
        <ugen name="BHiShelf">
            <rate name="audio" implied="true"/>
            <arg name="in" rate="ugen">
                <doc>
                     input signal to be processed.
                 </doc>
            </arg>
            <arg name="freq" default="440">
                <doc>
                    cutoff frequency.
                </doc>
            </arg>
            <arg name="rs" default="1">
                <doc>
                    the reciprocal of the slope S (Shell boost/cut slope).
                    When `S = 1`, the shelf slope is as steep as it can be and remain monotonically increasing
                    or decreasing gain with frequency.  The shelf slope, in dB/octave, remains proportional to
                    S for all other values for a fixed freq/sample-rate and `gain`.
                </doc>
            </arg>
            <arg name="gain" default="0">
                <doc>
                    boost/cut at the cutoff frequency (in decibels).
                </doc>
            </arg>
            <doc>
                <text>
                    A high shelf equalizer UGen.
                    The B equalization suite is based on the Second Order Section (SOS) biquad UGen.

                    Note: Biquad coefficient calculations imply certain amount of CPU overhead. These
                    plugin UGens contain optimizations such that the coefficients get updated only when
                    there has been a change to one of the filter's parameters. This can cause spikes in
                    CPU performance and should be considered when using several of these units.
                </text>
            </doc>
        </ugen>
    </file>

    <file name="GendynUGens">
        <ugen name="Gendy1" random="true">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="ampDist" default="1"/>
            <arg name="durDist" default="1"/>
            <arg name="adParam" default="1"/>
            <arg name="ddParam" default="1"/>
            <arg name="minFreq" default="440"/>
            <arg name="maxFreq" default="660"/>
            <arg name="ampScale" default="0.5"/>
            <arg name="durScale" default="0.5"/>
            <arg name="initCPs" default="12"/>
            <arg name="kNum" default="12"/>
        </ugen>
        <ugen name="Gendy2" random="true">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="ampDist" default="1"/>
            <arg name="durDist" default="1"/>
            <arg name="adParam" default="1"/>
            <arg name="ddParam" default="1"/>
            <arg name="minFreq" default="440"/>
            <arg name="maxFreq" default="660"/>
            <arg name="ampScale" default="0.5"/>
            <arg name="durScale" default="0.5"/>
            <arg name="initCPs" default="12"/>
            <arg name="kNum" default="12"/>
            <arg name="a" default="1.17"/>
            <arg name="c" default="0.31"/>
        </ugen>
        <ugen name="Gendy3" random="true">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="ampDist" default="1"/>
            <arg name="durDist" default="1"/>
            <arg name="adParam" default="1"/>
            <arg name="ddParam" default="1"/>
            <arg name="freq" default="440"/>
            <arg name="ampScale" default="0.5"/>
            <arg name="durScale" default="0.5"/>
            <arg name="initCPs" default="12"/>
            <arg name="kNum" default="12"/>
        </ugen>
    </file>

    <file name="GrainUGens">
        <ugen name="GrainIn" readsbuf="true">  <!-- accepts demand rate -->
            <rate name="audio" implied="true"/>
            <outputs num="numChannels"/>
            <arg name="numChannels" type="Int" default="1" pos="1"/>
            <arg name="trig" default="0" pos="2"/>
            <arg name="dur" default="1" pos="3"/>
            <arg name="in" pos="0"/>
            <arg name="pan" default="0" pos="4"/>
            <arg name="envBuf" default="-1" pos="5"/>
            <arg name="maxGrains" default="512" pos="6"/>
            <doc warnpos="true"/>
        </ugen>
        <ugen name="GrainSin" readsbuf="true">  <!-- accepts demand rate -->
            <rate name="audio" implied="true"/>
            <outputs num="numChannels"/>
            <arg name="numChannels" type="Int" default="1"/>
            <arg name="trig" default="0"/>
            <arg name="dur" default="1"/>
            <arg name="freq" default="440"/>
            <arg name="pan" default="0"/>
            <arg name="envBuf" default="-1"/>
            <arg name="maxGrains" default="512"/>
        </ugen>
        <ugen name="GrainFM" readsbuf="true"> <!-- accepts demand rate -->
            <rate name="audio" implied="true"/>
            <outputs num="numChannels"/>
            <arg name="numChannels" type="Int" default="1"/>
            <arg name="trig" default="0"/>
            <arg name="dur" default="1"/>
            <arg name="carFreq" default="440"/>
            <arg name="modFreq" default="200"/>
            <arg name="index" default="1"/>
            <arg name="pan" default="0"/>
            <arg name="envBuf" default="-1"/>
            <arg name="maxGrains" default="512"/>
        </ugen>
        <ugen name="GrainBuf" readsbuf="true">  <!-- accepts demand rate -->
            <rate name="audio" implied="true"/>
            <outputs num="numChannels"/>
            <arg name="numChannels" type="Int" default="1" pos="1"/>
            <arg name="trig" default="0" pos="2"/>
            <arg name="dur" default="1" pos="3"/>
            <arg name="buf" pos="0"/>
            <arg name="speed" default="1" pos="4"/>
            <arg name="pos" default="0" pos="5"/>
            <arg name="interp" default="2" pos="6"/>
            <arg name="pan" default="0" pos="7"/>
            <arg name="envBuf" default="-1" pos="8"/>
            <arg name="maxGrains" default="512" pos="9"/>
            <doc warnpos="true"/>
        </ugen>
        <ugen name="Warp1" readsbuf="true">  <!-- accepts demand rate -->
            <rate name="audio" implied="true"/>
            <outputs num="numChannels"/>
            <arg name="numChannels" type="Int"/>
            <arg name="buf"/>
            <arg name="pos" default="0"/>
            <arg name="speed" default="1"/>
            <arg name="winSize" default="0.2"/>
            <arg name="envBuf" default="-1"/>
            <arg name="overlaps" default="8"/>
            <arg name="winRand" default="0"/>
            <arg name="interp" default="1"/>
        </ugen>
    </file>

    <file name="IOUGens">
        <ugen name="OffsetOut" writesbus="true">
            <outputs num="0"/>
            <rate name="audio" implied="true"/>
            <arg name="bus"/>
            <arg name="in" multi="true" rate="ugen"/>
        </ugen>
        <ugen name="LocalIn">
            <outputs num="numChannels"/>
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="numChannels" type="Int" default="1"/>
        </ugen>
        <ugen name="XOut" writesbus="true">
            <outputs num="0"/>
            <rate name="audio">
                <arg name="in" rate="ugen"/>
            </rate>
            <rate name="control"/>
            <arg name="bus" pos="0"/>
            <arg name="xfade" pos="2"/>
            <arg name="in" multi="true" pos="1"/>
            <doc warnpos="true"/>
        </ugen>

        <!-- XXX TODO: these could well be here, and only the ProxyFactories are manually coded...
        <ugen name="LagControl"/>
        <ugen name="AudioControl"/>
        <ugen name="Control"/>
        <ugen name="TrigControl"/>
        -->

        <ugen name="ReplaceOut" writesbus="true">
            <outputs num="0"/>
            <rate name="audio" implied="true"/>
            <arg name="bus"/>
            <arg name="in" multi="true" rate="ugen"/>
        </ugen>
        <ugen name="Out" writesbus="true">
            <outputs num="0"/>
            <rate name="audio">
                <arg name="in" rate="ugen"/>
            </rate>
            <rate name="control"/>
            <rate name="scalar"/>
            <arg name="bus"/>
            <arg name="in" multi="true"/>
        </ugen>
        <ugen name="LocalOut">
            <outputs num="0"/>
            <rate name="control"/>
            <rate name="audio">
                <arg name="in" rate="ugen"/>
            </rate>
            <arg name="in" multi="true"/>
        </ugen>
        <ugen name="In" readsbus="true">
            <outputs num="numChannels"/>
            <rate name="scalar"/>
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="bus"/>
            <arg name="numChannels" type="Int" default="1"/>
        </ugen>
        <ugen name="LagIn" readsbus="true">
            <outputs num="numChannels"/>
            <rate name="control"/>
            <arg name="bus"/>
            <arg name="numChannels" type="Int" default="1"/>
            <arg name="lag" default="0.1"/>
        </ugen>
        <ugen name="InFeedback" readsbus="true">
            <outputs num="numChannels"/>
            <rate name="audio" implied="true"/>
            <arg name="bus">
                <doc>
                    the index of the audio bus to read in from.
                </doc>
            </arg>
            <arg name="numChannels" type="Int" default="1">
                <doc>
                    the number of channels (i.e. adjacent buses) to read in. Since
                    this is a constant, a change in number of channels of the underlying bus must
                    be reflected by creating different SynthDefs.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen which reads a signal from an audio bus with a current or one cycle old timestamp

                    Audio buses adhere to the concept of a cycle timestamp, which increases for each audio block
                    calculated. When the various output ugens (`Out`, `OffsetOut`, `XOut`) write data to a bus,
                    they mix it with any data from the current cycle, but overwrite any data from the previous cycle.
                    (`ReplaceOut` overwrites all data regardless.) Thus depending on node order and what synths are
                    writing to the bus, the data on a given bus may be from the current cycle or be one cycle old at
                    the time of reading.

                    `In.ar` checks the timestamp of any data it reads in and zeros any data from the previous
                    cycle (for use within that node; the data remains on the bus). This is fine for audio data,
                    as it avoids feedback, but for control data it is useful to be able to read data from any place
                    in the node order. For this reason `In.kr` also reads data that is older than the current cycle.

                    In some cases one might also want to read audio from a node later in the current node order.
                    This can be achieved with `InFeedback`. It reads from the previous cycle, and hence introduces
                    a '''delay''' of one block size, which by default is 64 sample frames (equal to about 1.45 ms
                    at 44.1 kHz sample rate).
                </text>
                <see>ugen.In</see>
                <see>ugen.LocalIn</see>
                <see>ugen.ControlDur</see>
            </doc>
        </ugen>
        <ugen name="InTrig" readsbus="true">
            <outputs num="numChannels"/>
            <rate name="control" implied="true"/>
            <arg name="bus">
                <doc>
                    the index of the control bus to read in from.
                </doc>
            </arg>
            <arg name="numChannels" type="Int" default="1">
                <doc>
                    the number of channels (i.e. adjacent buses) to read in. Since
                    this is a constant, a change in number of channels of the underlying bus must
                    be reflected by creating different SynthDefs.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen which generates a trigger anytime a control bus is set.

                    Any time the bus is "touched" i.e. has its value set (using `"/c_set"` etc.), a single
                    impulse trigger will be generated. Its amplitude is the value that the bus was set to.
                    Note that if a signal is continuously written to that bus, for instance using
                    `Out.kr`, only one initial trigger is generated once that ugen starts writing, but
                    no successive triggers are generated.
                </text>
                <see>ugen.In</see>
            </doc>
        </ugen>
        <!-- XXX TODO:
        <ugen name="SharedOut"/>
        <ugen name="SharedIn"/>
        -->
    </file>

    <file name="KeyboardUGens">
        <ugen name="KeyState">
            <rate name="control" implied="true"/>
            <arg name="keyCode"/>
            <arg name="lo" default="0"/>
            <arg name="hi" default="1"/>
            <arg name="lag" default="0.2"/>
        </ugen>
    </file>

    <file name="LFUGens">
        <ugen name="Vibrato">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="440"/>
            <arg name="beat" default="6"/>
            <arg name="depth" default="0.02"/>
            <arg name="delay" default="0"/>
            <arg name="onset" default="0"/>
            <arg name="beatVar" default="0.04"/>
            <arg name="depthVar" default="0.1"/>
            <arg name="iphase" default="0"/>
        </ugen>
        <ugen name="LFPulse">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="440">
                <doc>
                    oscillator frequency in Hertz
                </doc>
            </arg>
            <arg name="iphase" default="0">
                <doc>
                    initial phase offset in cycles ( `0..1` ). If you think
                    of a buffer of one cycle of the waveform, this is the starting offset
                    into this buffer. Hence, an `iphase` of `0.25` means that you will hear
                    the first impulse after `0.75` periods! If you prefer to specify the
                    perceived delay instead, you could use an `iphase` of `-0.25 + 1` which
                    is more intuitive. Note that the phase is not automatically wrapped
                    into the range of `0..1`, so putting an `iphase` of `-0.25` currently
                    results in a strange initial signal which only stabilizes to the
                    correct behaviour after one period!
                </doc>
            </arg>
            <arg name="width" default="0.5">
                <doc>
                    pulse width duty cycle from zero to one. If you want to
                    specify the width rather in seconds, you can use the formula
                    `width = freq * dur`, e.g. for a single sample impulse use
                    `width = freq * SampleDur.ir`.
                </doc>
            </arg>
            <doc>
                <text>
                    A non-band-limited pulse oscillator UGen.
                    Outputs a high value of one and a low value of zero.
                </text>
                <see>ugen.Pulse</see>
            </doc>
        </ugen>
        <ugen name="LFSaw">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="440">
                <doc>
                    oscillator frequency in Hertz
                </doc>
            </arg>
            <arg name="iphase" default="0">
                <doc>
                    initial phase offset. For efficiency reasons this is a
                    value ranging from -1 to 1 (thus equal to the initial output value).
                    Note that a phase of zero (default) means the wave starts at 0 and
                    rises to +1 before jumping down to -1. Use a phase of 1 to have the wave start at -1.
                </doc>
            </arg>
            <doc>
                <text>
                    A sawtooth oscillator UGen. The oscillator is creating an aliased sawtooth,
                    that is it does not use band-limiting. For a band-limited version use
                    `Saw` instead. The signal range is -1 to +1.
                </text>
                <see>ugen.Saw</see>
            </doc>
        </ugen>
        <ugen name="LFPar">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="440"/>
            <arg name="iphase" default="0"/>
        </ugen>
        <ugen name="LFCub">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="440"/>
            <arg name="iphase" default="0"/>
        </ugen>
        <ugen name="LFTri">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="440"/>
            <arg name="iphase" default="0"/>
        </ugen>
        <ugen name="LFGauss">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="dur" default="1"/>
            <arg name="width" default="0.1"/>
            <arg name="iphase" default="0"/>
            <arg name="loop" default="1"/>
            <arg name="doneAction" default="doNothing"/>
        </ugen>
        <ugen name="Impulse">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="440"/>
            <arg name="phase" default="0"/>
        </ugen>
        <ugen name="VarSaw">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="440"/>
            <arg name="iphase" default="0"/>
            <arg name="width" default="0.5"/>
        </ugen>
        <ugen name="SyncSaw">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="syncFreq" default="440"/>
            <arg name="sawFreq" default="440"/>
        </ugen>
        <ugen name="K2A">
            <rate name="audio" implied="true"/>
            <arg name="in"/>
        </ugen>
        <ugen name="A2K">
            <rate name="control" implied="true"/>
            <arg name="in"/>
        </ugen>
        <ugen name="T2K">
            <rate name="control" implied="true"/>
            <arg name="in"/>
        </ugen>
        <ugen name="T2A">
            <rate name="audio" implied="true"/>
            <arg name="in"/>
        </ugen>
        <ugen name="DC">
            <rate name="control"/>
            <rate name="audio"/>
            <outputs num="in"/>
            <arg name="in" multi="true"/>
        </ugen>
        <ugen name="Silent">
            <rate name="audio" implied="true"/>
            <outputs num="numChannels"/>
            <arg name="numChannels" type="Int" default="1"/>
        </ugen>
        <ugen name="Line" sideeffect="true" doneflag="true">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="start" default="0">
                <doc>
                    Starting value. Note that this is read only once at initialization
                </doc>
            </arg>
            <arg name="end" default="1">
                <doc>
                    Ending value. Note that this is read only once at initialization
                </doc>
            </arg>
            <arg name="dur" default="1">
                <doc>
                    Duration in seconds. Note that this is read only once at initialization
                </doc>
            </arg>
            <arg name="doneAction" default="doNothing">
                <doc>
                    A done-action that is evaluated when the Line has reached the end value after the
                    given duration
                </doc>
            </arg>
            <doc>
                <text>
                    A line generator UGen that moves from a start value to the end value in a given duration.
                </text>
                <see>ugen.XLine</see>
                <see>ugen.EnvGen</see>
                <see>ugen.Ramp</see>
            </doc>
        </ugen>
        <ugen name="XLine" sideeffect="true" doneflag="true">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="start" default="1"/>
            <arg name="end" default="2"/>
            <arg name="dur" default="1"/>
            <arg name="doneAction" default="doNothing"/>
        </ugen>

        <ugen name="Wrap">
            <rate name="scalar"/>
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="lo" default="0"/>
            <arg name="hi" default="1"/>
        </ugen>
        <ugen name="Fold">
            <rate name="scalar"/>
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="lo" default="0"/>
            <arg name="hi" default="1"/>
        </ugen>
        <ugen name="Clip">
            <rate name="scalar"/>
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="lo" default="0"/>
            <arg name="hi" default="1"/>
        </ugen>
        <!-- this should exist according to plugin sources...
        <ugen name="Unwrap"/>
        -->
        <ugen name="AmpComp">
            <rate name="scalar"/>
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="60.midicps"/>
            <arg name="root" default="60.midicps"/>
            <arg name="expon" default="0.3333"/>
        </ugen>
        <ugen name="AmpCompA">
            <rate name="scalar"/>
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="1000"/>
            <arg name="root" default="0"/>
            <arg name="minAmp" default="0.32"/>
            <arg name="rootAmp" default="1"/>
        </ugen>
        <ugen name="InRange">
            <rate name="scalar"/>
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="lo" default="0"/>
            <arg name="hi" default="1"/>
        </ugen>
        <ugen name="InRect">
            <rate name="scalar"/>
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="x"/>
            <arg name="y"/>
            <arg name="left" default="0"/>
            <arg name="top" default="0"/>
            <arg name="right" default="1"/>
            <arg name="bottom" default="1"/>
        </ugen>
        <ugen name="LinExp">
            <rate name="scalar"/>
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                The input signal to convert.
            </arg>
            <arg name="srcLo" default="0">
                The lower limit of input range.
            </arg>
            <arg name="srcHi" default="1">
                The upper limit of input range.
            </arg>
            <arg name="dstLo" default="1">
                The lower limit of output range.
            </arg>
            <arg name="dstHi" default="2">
                The upper limit of output range.
            </arg>
            <doc>
                <text>
                    A UGen which maps a linear range to an exponential range.
                    The equivalent formula is `(dstHi / dstLo).pow((in - srcLo) / (srcHi - srcLo)) * dstLo`.

                    '''Note''': No clipping is performed. If the input signal exceeds the input range, the output will also exceed its range.
                </text>
                <see>ugen.LinExp</see>
                <see>ugen.Clip</see>
            </doc>
        </ugen>
        <ugen name="LinLin">
            <rate name="scalar"/>
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in" rate="ugen">
                <doc>
                    The input signal to convert.
                </doc>
            </arg>
            <arg name="srcLo" default="0">
                <doc>
                    The lower limit of input range.
                </doc>
            </arg>
            <arg name="srcHi" default="1">
                <doc>
                    The upper limit of input range.
                </doc>
            </arg>
            <arg name="dstLo" default="0">
                <doc>
                    The lower limit of output range.
                </doc>
            </arg>
            <arg name="dstHi" default="1">
                <doc>
                    The upper limit of output range.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen which maps a linear range to another linear range.
                    The equivalent formula is `(in - srcLo) / (srcHi - srcLo) * (dstHi - dstLo) + dstLo`.

                    '''Note''': No clipping is performed. If the input signal exceeds the input range, the output will also exceed its range.
                </text>
                <see>ugen.LinExp</see>
                <see>ugen.Clip</see>
            </doc>
        </ugen>
        <ugen name="EnvGen" sideeffect="true" doneflag="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="gate" default="1" pos="1"/>
            <arg name="levelScale" default="1" pos="2"/>
            <arg name="levelBias" default="0" pos="3"/>
            <arg name="timeScale" default="1" pos="4"/>
            <arg name="doneAction" default="doNothing" pos="5"/>
            <arg name="envelope" multi="true" pos="0"/>
        </ugen>
        <ugen name="Linen" sideeffect="true" doneflag="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="gate" default="1"/>
            <arg name="attack" default="0.01"/>
            <arg name="sustain" default="1"/>
            <arg name="release" default="1"/>
            <arg name="doneAction" default="doNothing"/>
        </ugen>
        <ugen name="IEnvGen">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="index" default="1" pos="1"/>
            <arg name="envelope" multi="true" pos="0"/>
        </ugen>
    </file>

    <file name="MachineListening">
        <ugen name="BeatTrack" readsfft="true">
            <rate name="control" implied="true"/>
            <arg name="chain">
                <doc>
                    the output (buffer) of an FFT UGen which transforms the audio input to track.
                    The expected size of FFT is 1024 for 44100 and 48000 sampling rate, and 2048 for double those.
                    No other sampling rates are supported.
                </doc>
            </arg>
            <arg name="lock" default="0">
                <doc>
                    If this argument is greater than 0.5, the tracker will lock at its current
                    periodicity and continue from the current phase. Whilst it updates the model's phase and period,
                    this is not reflected in the output until lock goes back below 0.5. Can be control-rate modulated.
                </doc>
            </arg>
            <doc>
                <text>
                    An autocorrelation based beat tracker UGen.

                    The underlying model assumes 4/4, but it should work on any isochronous beat structure, though
                    there are biases to 100-120 bpm; a fast 7/8 may not be tracked in that sense. There are '''four''' control-rate
                    outputs, being ticks at quarter, eighth and sixteenth level from the determined beat, and the current
                    detected tempo. Note that the sixteenth note output won't necessarily make much sense if the music
                    being tracked has swing; it is provided just as a convenience.

                    This beat tracker determines the beat, biased to the midtempo range by weighting functions. It does not
                    determine the measure level, only a tactus. It is also slow reacting, using a 6 second temporal window for
                    its autocorrelation maneouvres. Don't expect human musician level predictive tracking.

                    On the other hand, it is tireless, relatively general (though obviously best at transient 4/4 heavy material
                    without much expressive tempo variation), and can form the basis of computer processing that is decidedly
                    faster than human.

                    '''Warning''': This UGen only works properly at 44.1 or 48.0 kHz.
                </text>
            </doc>
        </ugen>
        <ugen name="Loudness" readsfft="true">
            <rate name="control" implied="true"/>
            <arg name="chain">
                <doc>
                    the output (buffer) of an FFT UGen which transforms the audio input to track.
                    The FFT size should be 1024 for 44.1 and 48 kHz sampling rate, and 2048 for 88.2 and 96 kHz sampling rate.
                </doc>
            </arg>
            <arg name="smask" default="0.25">
                <doc>
                    Spectral masking parameter: lower bins mask higher bin power within ERB bands, with a power
                    falloff (leaky integration multiplier) of smask per bin. Can be control-rate modulated.
                </doc>
            </arg>
            <arg name="tmask" default="1">
                <doc>
                    Temporal masking parameter: the phon level let through in an ERB band is the maximum of
                    the new measurement, and the previous minus tmask phons. Can be control-rate modulated.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen for the extraction of instantaneous loudness.
                    A perceptual loudness function which outputs loudness in sones; this is a variant of an MP3 perceptual model,
                    summing excitation in ERB bands. It models simple spectral and temporal masking, with equal loudness contour
                    correction in ERB bands to obtain phons (relative dB), then a phon to sone transform. The final output is
                    typically in the range of 0 to 64 sones, though higher values can occur with specific synthesised stimuli.

                    Note that despite running at control-rate, the output remains constant for each FFT frame. E.g.
                    with an FFT size of 1024 and 50% overlap, a new measure is generated every 512 audio frames,
                    or (at control block size 64) every 8 control blocks.
                </text>
            </doc>
        </ugen>
        <ugen name="KeyTrack" readsfft="true">
            <rate name="control" implied="true"/>
            <arg name="chain">
                <doc>
                    the output (buffer) of an FFT UGen which transforms the audio input to track.
                    For the FFT chain, with a standard hop of half FFT size, the FFT size should be
                    4096 at 44.1 or 48 kHz and 8192 at 88.2 or 96 kHz sampling rate.
                </doc>
            </arg>
            <arg name="keyDecay" default="2">
                <doc>
                    Number of seconds for the influence of a window on the final key decision to decay by
                    40dB (to 0.01 its original value). Can be control-rate modulated.
                </doc>
            </arg>
            <arg name="chromaLeak" default="0.5">
                <doc>
                    Each frame, the chroma values are set to the previous value multiplied by the chromadecay.
                    0.0 will start each frame afresh with no memory. Can be control-rate modulated.
                </doc>
            </arg>
            <doc>
                <text>
                    A (12TET major/minor) key tracker UGen.
                    It is based on a pitch class profile of energy across FFT bins and matching this to templates for major and
                    minor scales in all transpositions. It assumes a 440 Hz concert A reference. Output is 0-11  C major to B major,
                    12-23 C minor to B minor.
                </text>
            </doc>
        </ugen>
        <ugen name="MFCC" readsfft="true">
            <rate name="control" implied="true"/>
            <outputs num="numCoeffs"/>
            <arg name="chain">
                <doc>
                    the output (buffer) of an FFT UGen which transforms the audio input to track.
                    For the FFT chain, with a standard hop of half FFT size, the FFT size should be
                    1024 at 44.1 or 48 kHz and 2048 at 88.2 or 96 kHz sampling rate.
                </doc>
            </arg>
            <arg name="numCoeffs" type="Int" ugenin="true" default="13">
                <doc>
                    the number of coefficients, defaults to 13, maximum of 42; more efficient to use less of course!
                    Since this number determines the number of output channels of the UGen, it has to be an `Int`.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen for extracting mel frequency cepstral coefficients.
                    It generates a set of MFCCs; these are obtained from a band-based frequency representation (using the Mel scale
                    by default), and then a discrete cosine transform (DCT). The DCT is an efficient approximation for principal
                    components analysis, so that it allows a compression, or reduction of dimensionality, of the data, in this case
                    reducing 42 band readings to a smaller set of MFCCs. A small number of features (the coefficients) end up
                    describing the spectrum. The MFCCs are commonly used as timbral descriptors.

                    The output values are somewhat normalised for the range 0.0 to 1.0, but there are no guarantees on exact
                    conformance to this. Commonly, the first coefficient will be the highest value.
                    The number of output channels corresponds to the number of coefficients specified.
                    Technical note: The 0th coefficient is not generated as it consists of multiplying all bands by 1 and summing

                    Note that despite running at control-rate, the output remains constant for each FFT frame. E.g.
                    with an FFT size of 1024 and 50% overlap, a new measure is generated every 512 audio frames,
                    or (at control block size 64) every 8 control blocks.
                </text>
            </doc>
        </ugen>
        <ugen name="Onsets" readsfft="true">
            <rate name="control" implied="true"/>
            <arg name="chain">
                <doc>
                    the output (buffer) of an FFT UGen which transforms the audio input to track.
                    For the FFT chain, you should typically use a frame size of 512 or 1024 (at 44.1 kHz sampling rate)
                    and 50% hop size (which is the default setting in SC). For different sampling rates choose an FFT
                    size to cover a similar time-span (around 10 to 20 ms).
                </doc>
            </arg>
            <arg name="thresh" default="0.5">
                <doc>
                    the detection threshold, typically between 0 and 1, although in rare cases you may
                    find values outside this range useful
                </doc>
            </arg>
            <arg name="fun" default="3">
                <doc>
                    index of a function to be used to analyse the signal. See main paragraph for possible
                    values (usually can be left to default).
                </doc>
            </arg>
            <arg name="decay" default="1">
                <doc>
                    (advanced setting) Specifies the time (in seconds) for the normalisation to "forget"
                    about a recent onset. If you find too much re-triggering (e.g. as a note dies away unevenly) then
                    you might wish to increase this value. Not used with "mkl".
                </doc>
            </arg>
            <arg name="noiseFloor" default="0.1">
                <doc>
                    (advanced setting) This is a lower limit, connected to the idea of how quiet the
                    sound is expected to get without becoming indistinguishable from noise. For some cleanly-recorded
                    classical music with wide dynamic variations, it was found helpful to go down as far as 1e-6.
                    Not used with "mkl".
                </doc>
            </arg>
            <arg name="minGap" default="10">
                <doc>
                    (advanced setting) Specifies a minimum gap (in FFT frames) between onset detections,
                    a brute-force way to prevent too many doubled detections.
                </doc>
            </arg>
            <arg name="medianSpan" default="11">
                <doc>
                    (advanced setting) Specifies the size (in FFT frames) of the median window used for
                    smoothing the detection function before triggering.
                </doc>
            </arg>
            <arg name="whType" default="1">
                <doc>
                    (advanced setting) ?
                </doc>
            </arg>
            <arg name="raw" default="0">
                <doc>
                    (advanced setting) ?
                </doc>
            </arg>
            <doc>
                <text>
                    An onset detecting UGen for musical audio signals.
                    It detects the beginning of notes/drumbeats/etc. Outputs a control-rate trigger signal which is 1
                    when an onset is detected, and 0 otherwise.

                    The onset detection should work well for a general range of monophonic and polyphonic audio signals.
                    The onset detection is purely based on signal analysis and does not make use of any "top-down" inferences
                    such as tempo.

                    There are different functions available for the analysis:

                    - 0 "power" -- generally OK, good for percussive input, and also very efficient
                    - 1 "magsum" -- generally OK, good for percussive input, and also very efficient
                    - 2 "complex" -- performs generally very well, but more CPU-intensive
                    - 3 "rcomplex" (default) -- performs generally very well, and slightly more efficient than "complex"
                    - 4 "phase" -- generally good, especially for tonal input, medium efficiency
                    - 5 "wphase" -- generally very good, especially for tonal input, medium efficiency
                    - 6 "mkl" -- generally very good, medium efficiency, pretty different from the other methods

                    The differences aren't large, so it is recommended you stick with the default "rcomplex" unless you
                    find specific problems with it. Then maybe try "wphase". The "mkl" type is a bit different from the
                    others so maybe try that too. They all have slightly different characteristics, and in tests perform
                    at a similar quality level.
                </text>
            </doc>
        </ugen>

        <ugen name="BeatTrack2" readsfft="true">
            <rate name="control" implied="true"/>
            <outputs num="6"/>
            <arg name="bus">
                <doc>
                    index of a control bus to read from. the number of channels of that bus are expected
                    to match the `numChannels` argument. To track a particular audio signal, analyse it first
                    into `numChannels` features, that is onset-detection-triggers, as generated by `Onsets`, and write the
                    trigger-output to this control bus.
                </doc>
            </arg>
            <arg name="numChannels"> <!-- Int? -->
                <doc>
                    (scalar) How many features (ie how many control bus channels) are provided
                </doc>
            </arg>
            <arg name="winSize" default="2">
                <doc>
                    (scalar) Size of the temporal window desired (2.0 to 3.0 seconds models the human
                    temporal window). You might use longer values for stability of estimate at the expense of reactiveness.
                </doc>
            </arg>
            <arg name="phaseSpacing" default="0.02">
                <doc>
                    (scalar) Relates to how many different phases to test. At the default of 0.02 seconds,
                    50 different phases spaced by those 0.02 seconds would be tried out for 60bpm; 16 would be trialed for 180 bpm.
                    Larger phaseSpacing means more tests and more CPU cost.
                </doc>
            </arg>
            <arg name="lock" default="0">
                <doc>
                    If this argument is greater than 0.5, the tracker will lock at its current periodicity
                    and continue from the current phase. Whilst it updates the model's phase and period, this is not reflected
                    in the output until lock goes back below 0.5. Can be control-rate modulated.
                </doc>
            </arg>
            <arg name="weighting" default="-2.1">
                <doc>
                    (scalar) Use (-2.5) for flat weighting of tempi, (-1.5) for compensation weighting based
                    on the number of events tested (because different periods allow different numbers of events within the
                    temporal window). If an integer from 0 upwards is given, this is specifying the ID of a buffer containing
                    120 frames which represent individual tempo weights; tempi go from 60 to 179 bpm in steps of one bpm, so
                    you make sure the buffer has 120 frames.
                </doc>
            </arg>
            <doc>
                <text>
                    A template matching beat tracker UGen.
                    This beat tracker is based on exhaustively testing particular template patterns against feature streams;
                    the testing takes place every 0.5 seconds. The two basic templates are a straight (groove=0) and a swung
                    triplet (groove=1) pattern of 16th notes; this pattern is tried out at scalings corresponding to the tempi
                    from 60 to 180 bpm. This is the cross-corellation method of beat tracking. A majority vote is taken on the
                    best tempo detected, but this must be confirmed by a consistency check after a phase estimate. Such a
                    consistency check helps to avoid wild fluctuating estimates, but is at the expense of an additional half
                    second delay. The latency of the beat tracker with default settings is thus at least 2.5 seconds; because
                    of block-based amortisation of calculation, it is actually around 2.8 seconds latency for a 2.0 second
                    temporal window.

                    This beat tracker is designed to be flexible for user needs; you can try out different window sizes, tempo
                    weights and combinations of features. However, there are no guarantees on stability and effectiveness, and you
                    will need to explore such parameters for a particular situation.

                    The UGen has '''six outputs''' corresponding to beat-tick, eighth-tick, groove-tick, tempo, phase, and groove.
                    '''Warning''': it reads from input control bus instead of taking a regular control input signal as its first
                    argument!
                </text>
            </doc>
        </ugen>

        <ugen name="SpecFlatness" readsfft="true">
            <rate name="control" implied="true"/>
            <arg name="chain">
                <doc>
                    the fft signal (buffer) to analyze
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen to measure spectral flatness.
                    Given an FFT chain this calculates the Spectral Flatness measure, defined as a power spectrum's geometric
                    mean divided by its arithmetic mean. This gives a measure which ranges from approx 0 for a pure sinusoid,
                    to approx 1 for white noise.

                    The measure is calculated linearly. For some applications you may wish to convert the value to a decibel
                    scale. '''Note''' that this UGen may output NaN when the input is zero (probably due to division by zero).
                    In that case, `CheckBadValues` can be used to prevent further problems.

                    Note that despite running at control-rate, the output remains constant for each FFT frame. E.g.
                    with an FFT size of 1024 and 50% overlap, a new measure is generated every 512 audio frames,
                    or (at control block size 64) every 8 control blocks.
                </text>
                <see>ugen.CheckBadValues</see>
            </doc>
        </ugen>
        <ugen name="SpecPcile" readsfft="true">
            <rate name="control" implied="true"/>
            <arg name="chain">
                <doc>
                    the fft signal (buffer) to analyze
                </doc>
            </arg>
            <arg name="percent" default="0.5">
                <doc>
                    the percentage between 0.0 (0%) and 1.0 (100%)
                </doc>
            </arg>
            <arg name="interp" default="0">
                <doc>
                    specifies whether interpolation should be used to try and make the percentile
                    frequency estimate more accurate, at the cost of a little higher CPU usage. Set it to 1 to enable this.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen to find the percentile of a signal's magnitude spectrum.
                    Given an FFT chain this calculates the cumulative distribution of the frequency spectrum, and outputs
                    the frequency value which corresponds to the desired percentile. For example, to find the frequency at
                    which 90% of the spectral energy lies below that frequency, you want the 90-percentile, which means
                    the value of `percent` should be 0.9. The 90-percentile or 95-percentile is often used as a measure of
                    spectral roll-off.

                    Note that despite running at control-rate, the output remains constant for each FFT frame. E.g.
                    with an FFT size of 1024 and 50% overlap, a new measure is generated every 512 audio frames,
                    or (at control block size 64) every 8 control blocks.
                </text>
            </doc>
        </ugen>
        <ugen name="SpecCentroid" readsfft="true">
            <rate name="control" implied="true"/>
            <arg name="chain">
                <doc>
                    the fft signal (buffer) to analyze
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen to measure the spectral centroid.
                    Given an FFT chain, this measures the spectral centroid, which is the weighted mean frequency, or
                    the "centre of mass" of the spectrum. (DC is ignored.) This can be a useful indicator of the perceptual
                    brightness of a signal.

                    Note that the output frequency is pretty close to the correct value when feeding in a
                    sine signal, but the estimate is usually too high when using for example filtered noise.
                    In that case, you will get better results using `SpecPcile` at 50%.

                    Note that despite running at control-rate, the output remains constant for each FFT frame. E.g.
                    with an FFT size of 1024 and 50% overlap, a new measure is generated every 512 audio frames,
                    or (at control block size 64) every 8 control blocks.
                </text>
                <see>ugen.SpecPcile</see>
            </doc>
        </ugen>
    </file>

    <file name="MouseUGens">
        <ugen name="MouseX">
            <rate name="control" implied="true"/>
            <arg name="lo" default="0"/>
            <arg name="hi" default="1"/>
            <arg name="warp" default="0"/>
            <arg name="lag" default="0.2"/>
        </ugen>
        <ugen name="MouseY">
            <rate name="control" implied="true"/>
            <arg name="lo" default="0"/>
            <arg name="hi" default="1"/>
            <arg name="warp" default="0"/>
            <arg name="lag" default="0.2"/>
        </ugen>
        <ugen name="MouseButton">
            <rate name="control" implied="true"/>
            <arg name="lo" default="0"/>
            <arg name="hi" default="1"/>
            <arg name="lag" default="0.2"/>
        </ugen>
    </file>

    <file name="NoiseUGens">
        <ugen name="WhiteNoise" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="mul" default="1" expandbin="*"/>
        </ugen>
        <ugen name="GrayNoise" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="mul" default="1" expandbin="*"/>
        </ugen>
        <ugen name="ClipNoise" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="mul" default="1" expandbin="*"/>
        </ugen>
        <ugen name="PinkNoise" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="mul" default="1" expandbin="*"/>
        </ugen>
        <ugen name="BrownNoise" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="mul" default="1" expandbin="*"/>
        </ugen>
        <ugen name="Dust" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="density" default="1">
                <doc>
                    the average number of impulses per second
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen generating random impulses with values ranging from
                    `0` to `+1`. The pulse duration is one sample for audio-rate
                    and one block for control-rate operation.
                </text>
                <see>ugen.Dust2</see>
                <see>ugen.TRand</see>
            </doc>
        </ugen>
        <ugen name="Dust2" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="density" default="1">
                <doc>
                    the average number of impulses per second
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen generating random impulses with values ranging from
                    `-1` to `+1`. The pulse duration is one sample for audio-rate
                    and one block for control-rate operation.
                </text>
                <see>ugen.Dust</see>
                <see>ugen.TRand</see>
            </doc>
        </ugen>
        <ugen name="Crackle">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="chaos" default="1.5"/>
        </ugen>
        <ugen name="Logistic">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="chaos" default="3"/>
            <arg name="freq" default="1000"/>
            <arg name="init" default="0.5"/>
        </ugen>
        <ugen name="Hasher">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
        </ugen>
        <ugen name="MantissaMask">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="bits" default="3"/>
        </ugen>
        <ugen name="LFClipNoise" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="500"/>
        </ugen>
        <ugen name="LFNoise0" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="500"/>
        </ugen>
        <ugen name="LFNoise1" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="500"/>
        </ugen>
        <ugen name="LFNoise2" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="500"/>
        </ugen>
        <ugen name="Rand" random="true">
            <rate name="scalar" implied="true" method="apply"/>
            <arg name="lo" default="0"/>
            <arg name="hi" default="1"/>
        </ugen>
        <ugen name="IRand" random="true">
            <rate name="scalar" implied="true" method="apply"/>
            <arg name="lo" default="0"/>
            <arg name="hi" default="127"/>
        </ugen>
        <ugen name="TRand" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="lo" default="0"/>
            <arg name="hi" default="1"/>
            <arg name="trig"/>
        </ugen>
        <ugen name="TExpRand" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="lo" default="0.01"/>
            <arg name="hi" default="1.0"/>
            <arg name="trig"/>
        </ugen>
        <ugen name="TIRand" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="lo" default="0"/>
            <arg name="hi" default="127"/>
            <arg name="trig"/>
        </ugen>
        <ugen name="NRand" random="true">
            <rate name="scalar" implied="true" method="apply"/>
            <arg name="lo" default="0"/>
            <arg name="hi" default="127"/>
            <arg name="n" default="0"/>
        </ugen>
        <ugen name="LinRand" random="true">
            <rate name="scalar" implied="true" method="apply"/>
            <arg name="lo" default="0"/>
            <arg name="hi" default="127"/>
            <arg name="minMax" default="0"/>
        </ugen>
        <ugen name="ExpRand" random="true">
            <rate name="scalar" implied="true" method="apply"/>
            <arg name="lo" default="0.01"/>
            <arg name="hi" default="1.0"/>
        </ugen>
        <ugen name="CoinGate" random="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="prob" default="0.5" pos="1"/>
            <arg name="in" pos="0"/>
            <doc warnpos="true"/>
        </ugen>
        <ugen name="RandSeed" sideeffect="true">
            <rate name="scalar"/>
            <rate name="control"/>
            <arg name="trig" default="1"/>
            <arg name="seed" default="56789"/>
        </ugen>
        <ugen name="RandID" sideeffect="true">
            <rate name="scalar"/>
            <rate name="control"/>
            <arg name="id" default="0"/>
        </ugen>
    </file>

    <file name="OSCUGens">
        <ugen name="DegreeToKey" readsbuf="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in"/>
            <arg name="octave" default="12"/>
        </ugen>
        <ugen name="Select">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="index">
                <doc>
                    an index signal into the channels of the `multi` argument. The index
                    is automatically clipped to lie between `0` and `multi.numOutputs - 1`. The index
                    is truncated to its integer part (not rounded), hence using for instance an
                    index of `0.9` will still be interpreted as index `0`.
                </doc>
            </arg>
            <arg name="in" multi="true">
                <doc>
                    a graph element which is composed of the channels to be indexed.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen which selects among a sequence of inputs, according to an index signal.
                    Note that, although only one signal of the `multi` input is let through at
                    a time, sill all ugens are continuously running.
                </text>
                <see>ugen.TWindex</see>
            </doc>
        </ugen>
        <ugen name="TWindex">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="trig">
                <doc>
                    the trigger used to calculate a new index. a trigger occurs when passing
                    from non-positive to positive
                </doc>
            </arg>
            <arg name="prob">
                <doc>
                    a multi-channel graph element, where the output channels correspond to
                    to the probabilites of their respective indices being chosen.
                </doc>
            </arg>
            <arg name="normalize" default="0">
                <doc>
                    `0` if the seq argument already sums up to 1.0 and thus doesn't need
                    normalization, `1` if the sum is not guaranteed to be 1.0 and thus the ugen is asked
                    to provide the normalization.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen providing a probability-weighted index into a sequence upon receiving a trigger.

                    When triggered, returns a random index value based the values of the channels of the
                    `prob` argument functioning as probabilities. The index is zero based, hence goes from
                    `0` to `prob.numOutputs - 1`.

                    By default the sequence of probabilities should sum to 1.0, however for convenience, this
                    can be achieved by the ugen when the `normalize` flag is set to 1 (less efficient).
                </text>
                <see>ugen.Select</see>
            </doc>
        </ugen>
        <ugen name="Index" readsbuf="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in" default="0"/>
        </ugen>
        <!-- this should exist according to plugin sources...
        <ugen name="FoldIndex"/>
        -->
        <ugen name="WrapIndex" readsbuf="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in" default="0"/>
        </ugen>
        <ugen name="IndexInBetween" readsbuf="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in" default="0"/>
        </ugen>
        <ugen name="DetectIndex" readsbuf="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in" default="0"/>
        </ugen>
        <ugen name="Shaper" readsbuf="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="in" default="0"/>
        </ugen>
        <!-- this should exist according to plugin sources...
        <ugen name="SigOsc"/>
        -->
        <ugen name="FSinOsc">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="freq" default="440"/>
            <arg name="iphase" default="0"/>
        </ugen>
        <ugen name="SinOsc">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="freq" default="440">
                <doc>
                    frequency in Hertz
                </doc>
            </arg>
            <arg name="phase" default="0">
                <doc>
                    phase offset or modulator in radians
                </doc>
            </arg>
            <doc>
                <text>
                    A Sinusoidal (sine tone) oscillator UGen.
                    This is the same as `Osc` except that it uses a built-in interpolating sine table of 8192 entries.
                </text>
                <see>ugen.Osc</see>
                <see>ugen.FSinOsc</see>
            </doc>
        </ugen>
        <ugen name="SinOscFB">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="freq" default="440"/>
            <arg name="feedback" default="0"/>
        </ugen>
        <ugen name="VOsc" readsbuf="true">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="bufPos"/>
            <arg name="freq" default="440"/>
            <arg name="phase" default="0"/>
        </ugen>
        <ugen name="VOsc3" readsbuf="true">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="bufPos"/>
            <arg name="freq1" default="110"/>
            <arg name="freq2" default="220"/>
            <arg name="freq3" default="440"/>
        </ugen>
        <ugen name="Osc" readsbuf="true">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="buf"/>
            <arg name="freq" default="440"/>
            <arg name="phase" default="0"/>
        </ugen>
        <ugen name="OscN" readsbuf="true">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="buf"/>
            <arg name="freq" default="440"/>
            <arg name="phase" default="0"/>
        </ugen>
        <ugen name="COsc" readsbuf="true">
            <rate name="audio"/>
            <arg name="buf"/>
            <arg name="freq" default="440"/>
            <arg name="beats" default="0.5"/>
        </ugen>
        <ugen name="Formant">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="fundFreq" default="440"/>
            <arg name="formFreq" default="1760"/>
            <arg name="bw" default="880"/>
        </ugen>
        <ugen name="Blip">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="440"/>
            <arg name="numHarm" default="200"/>
        </ugen>
        <ugen name="Saw">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="440"/>
        </ugen>
        <ugen name="Pulse">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="freq" default="440"/>
            <arg name="width" default="0.5"/>
        </ugen>

        <ugen name="Klang">
            <rate name="audio" implied="true"/>
            <arg name="freqScale" default="1" pos="1"/>
            <arg name="freqOffset" default="0" pos="2"/>
            <arg name="specs" multi="true" pos="0"/>
        </ugen>
        <ugen name="Klank">
            <rate name="audio" implied="true"/>
            <arg name="in" pos="1"/>
            <arg name="freqScale" default="1" pos="2"/>
            <arg name="freqOffset" default="0" pos="3"/>
            <arg name="decayScale" default="1" pos="4"/>
            <arg name="specs" multi="true" pos="0"/>
        </ugen>
    </file>

    <file name="PanUGens">
        <ugen name="Pan2">
            <rate name="control"/>
            <rate name="audio">
                <arg name="in" rate="ugen"/>
            </rate>
            <outputs num="2"/>
            <arg name="in"/>
            <arg name="pos" default="0"/>
            <arg name="level" default="1"/>
        </ugen>
        <ugen name="Pan4">
            <rate name="control"/>
            <rate name="audio">
                <arg name="in" rate="ugen"/>
            </rate>
            <outputs num="4"/>
            <arg name="in"/>
            <arg name="xpos" default="0"/>
            <arg name="ypos" default="0"/>
            <arg name="level" default="1"/>
        </ugen>
        <ugen name="LinPan2">
            <rate name="control"/>
            <rate name="audio">
                <arg name="in" rate="ugen"/>
            </rate>
            <outputs num="2"/>
            <arg name="in"/>
            <arg name="pos" default="0"/>
            <arg name="level" default="1"/>
        </ugen>
        <ugen name="Balance2">
            <rate name="control"/>
            <rate name="audio">
                <arg name="left" rate="ugen"/>
                <arg name="right" rate="ugen"/>
            </rate>
            <outputs num="2"/>
            <arg name="left"/>
            <arg name="right"/>
            <arg name="pos" default="0"/>
            <arg name="level" default="1"/>
        </ugen>
        <ugen name="Rotate2">
            <rate name="control"/>
            <rate name="audio">
                <arg name="left" rate="ugen"/>
                <arg name="right" rate="ugen"/>
            </rate>
            <outputs num="2"/>
            <arg name="x"/>
            <arg name="y"/>
            <arg name="pos" default="0"/>
        </ugen>
        <ugen name="XFade2">
            <rate name="control">
                <arg name="inB" default="0"/>
            </rate>
            <rate name="audio">
                <arg name="inA" rate="ugen"/>
                <!-- DC.ar(0) and K2A.ar(0) take about the same amount of CPU,
                  where the latter is favorable as it is a singleout ugen.
                  In contrast, Silent.ar takes about 20% more CPU (measured 07-jan-10) -->
                <arg name="inB" rate="ugen" default="K2A.ar(0)"/>
            </rate>
            <arg name="inA">
                <doc>
                    The first input signal
                </doc>
            </arg>
            <arg name="inB">
                <doc>
                    The second input signal
                </doc>
            </arg>
            <arg name="pan" default="0">
                <doc>
                    the xfade position from `-1` (only input A audible) to
                    `+1` (only input B audible)
                </doc>
            </arg>
            <arg name="level" default="1">
                <doc>
                    An overall amplitude multiplier that is applied to the output signal
                </doc>
            </arg>
            <doc>
                <text>
                    An equal power two channel cross fading UGen.
                </text>
                <see>ugen.LinXFade2</see>
            </doc>
        </ugen>
        <ugen name="LinXFade2">
            <rate name="control">
                <arg name="inB" default="0"/>
            </rate>
            <rate name="audio">
                <arg name="inA" rate="ugen"/>
                <!-- DC.ar(0) and K2A.ar(0) take about the same amount of CPU,
                  where the latter is favorable as it is a singleout ugen.
                  In contrast, Silent.ar takes about 20% more CPU (measured 07-jan-10) -->
                <arg name="inB" rate="ugen" default="K2A.ar(0)"/>
            </rate>
            <arg name="inA">
                <doc>
                    The first input signal
                </doc>
            </arg>
            <arg name="inB">
                <doc>
                    The second input signal
                </doc>
            </arg>
            <arg name="pan" default="0">
                <doc>
                    the xfade position from `-1` (only input A audible) to
                    `+1` (only input B audible)
                </doc>
            </arg>
            <arg name="level" default="1">
                <doc>
                    An overall amplitude multiplier that is applied to the output signal
                </doc>
            </arg>
            <doc>
                <text>
                    An linear two channel cross fading UGen.
                </text>
                <see>ugen.LinXFade2</see>
            </doc>
        </ugen>
        <ugen name="PanB">
            <rate name="control"/>
            <rate name="audio">
                <arg name="in" rate="ugen"/>
            </rate>
            <outputs num="4"/>
            <arg name="in"/>
            <arg name="azimuth" default="0"/>
            <arg name="elevation" default="0"/>
            <arg name="level" default="1"/>
        </ugen>
        <ugen name="PanB2">
            <rate name="control"/>
            <rate name="audio">
                <arg name="in" rate="ugen"/>
            </rate>
            <outputs num="3"/>
            <arg name="in"/>
            <arg name="azimuth" default="0"/>
            <arg name="level" default="1"/>
        </ugen>
        <ugen name="BiPanB2">
            <rate name="control"/>
            <rate name="audio">
                <arg name="inA" rate="ugen"/>
                <arg name="inB" rate="ugen"/>
            </rate>
            <outputs num="3"/>
            <arg name="inA"/>
            <arg name="inB"/>
            <arg name="azimuth" default="0"/>
            <arg name="level" default="1"/>
        </ugen>
        <ugen name="PanAz">
            <rate name="control"/>
            <rate name="audio">
                <arg name="in" rate="ugen"/>
            </rate>
            <outputs num="numChannels"/>
            <arg name="numChannels" type="Int">
                <doc>
                    the number of output channels
                </doc>
            </arg>
            <arg name="in">
                <doc>
                    the input signal
                </doc>
            </arg>
            <arg name="pos" default="0">
                <doc>
                    the pan position. Channels are evenly spaced over a cyclic period of 2.0.
                    the output channel position is `pos / 2 * numChannels + orient`. Thus, assuming an `orient`
                    of `0.0`, and `numChannels` being for example `3`, a `pos` of `0*2.0/3 == 0.0` corresponds to the first
                    output channel, a `pos` of `1*2.0/3` corresponds to the second output channel,
                    a `pos` of `2*2.0/3=4.0/3` corresponds to the third and last output channel, and
                    a `pos` of `3*2.0/3=2.0` completes the circle and wraps again to the first channel.
                    Using a bipolar pan position, such as a sawtooth that ranges from -1 to +1, all channels will be
                    cyclically panned through.
                </doc>
            </arg>
            <arg name="level" default="1">
                <doc>
                    a control rate level input (linear multiplier).
                </doc>
            </arg>
            <arg name="width" default="2">
                <doc>
                    the width of the panning envelope. The default of 2.0 pans between pairs
                    of adjacent speakers. Width values greater than two will spread the pan over greater numbers
                    of speakers. Width values less than one will leave silent gaps between speakers.
                </doc>
            </arg>
            <arg name="orient" default="0">
                <doc>
                    the offset in the output channels regarding a pan position of zero.
                    Note that ScalaCollider uses a default of zero which means that a pan pos of zero outputs
                    the signal exactly on the first output channel. This is different in sclang where the default is
                    0.5 which means that a pan position of zero will output the signal inbetween the first and second
                    speaker. Accordingly, an `orient` of `1.0` would result in a channel offset of one, where a
                    pan position of zero would output the signal exactly on the second output channel, and so forth.
                </doc>
            </arg>
            <doc>
                <text>
                    An azimuth-based panorama UGen. It uses vector-based-amplitude panning where
                    the arbitrary number of speakers is supposed to be distributed in a circle
                    with even spacing between them. It uses an equal-power-curve to transition
                    between adjectant speakers. '''Note''' the different default value for
                    the `orient` argument!

                    Use case: To spread an multi-channel input signal across an output bus
                    with a different number of channels, such that the first input channel is played on the
                    first output channel (no spread to adjectant channels) and the last input channel is played
                    to the last output channel (no spread to adjectant channels), you would create a dedicated `PanAz` per
                    input channel where the pan position
                    is `inChanIdx * 2f / (inChannels - 1) * (outChannels - 1) / outChannels`.
                </text>
            </doc>
        </ugen>
        <ugen name="DecodeB2">
            <rate name="control"/>
            <rate name="audio">
                <arg name="w" rate="ugen"/>
                <arg name="x" rate="ugen"/>
                <arg name="y" rate="ugen"/>
            </rate>
            <outputs num="numChannels"/>
            <arg name="numChannels" type="Int"/>
            <arg name="w"/>
            <arg name="x"/>
            <arg name="y"/>
            <arg name="orient" default="0.5"/>
        </ugen>
    </file>

    <file name="PhysicalModellingUGens">
        <ugen name="Spring">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="spring" default="1"/>
            <arg name="damp" default="0"/>
        </ugen>
        <ugen name="Ball">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="g" default="1"/>
            <arg name="damp" default="0"/>
            <arg name="friction" default="0.01"/>
        </ugen>
        <ugen name="TBall">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="g" default="10"/>
            <arg name="damp" default="0"/>
            <arg name="friction" default="0.01"/>
        </ugen>
    </file>

    <file name="ReverbUGens">
        <ugen name="FreeVerb">
            <rate name="audio" implied="true"/>
            <arg name="in" rate="ugen"/>
            <arg name="mix" default="0.33"/>
            <arg name="room" default="0.5"/>
            <arg name="damp" default="0.5"/>
        </ugen>
        <ugen name="FreeVerb2">
            <rate name="audio" implied="true"/>
            <outputs num="2"/>
            <arg name="left" rate="ugen"/>
            <arg name="right" rate="ugen"/>
            <arg name="mix" default="0.33"/>
            <arg name="room" default="0.5"/>
            <arg name="damp" default="0.5"/>
        </ugen>
        <ugen name="GVerb">
            <rate name="audio" implied="true"/>
            <outputs num="2"/>
            <arg name="in" rate="ugen"/>
            <arg name="roomSize" default="10"/>
            <arg name="revTime" default="3"/>
            <arg name="damping" default="0.5"/>
            <arg name="inputBW" default="0.5"/>
            <arg name="spread" default="15"/>
            <arg name="dryLevel" default="1"/>
            <arg name="earlyRefLevel" default="0.7"/>
            <arg name="tailLevel" default="0.5"/>
            <arg name="maxRoomSize" default="300"/>
        </ugen>
    </file>

    <file name="TestUGens">
        <ugen name="CheckBadValues" sideeffect="true">
            <rate name="scalar"/>
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in">
                <doc>
                    the signal to be tested
                </doc>
            </arg>
            <arg name="id" default="0">
                <doc>
                    an identifier showing up with the values in the console
                </doc>
            </arg>
            <arg name="post" default="2">
                <doc>
                    One of three post modes: 0 = no posting; 1 = post a line for every bad value;
                    2 = post a line only when the floating-point classification changes (e.g., normal -&gt; NaN and vice versa)
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen to test for infinity, not-a-number (NaN), and denormals.
                    Its output is as follows: 0 = a normal float, 1 = NaN, 2 = infinity, and 3 = a denormal.
                    According to the post settings it will print the information to the console along
                    with a given identifier.
                </text>
            </doc>
        </ugen>
    </file>

    <file name="TriggerUGens">
        <ugen name="Trig1">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="in">
                <doc>
                    the trigger. This can be any signal. A trigger happens when the signal changes
                    from non-positive to positive.
                </doc>
            </arg>
            <arg name="dur" default="0.1">
                <doc>
                    the duration for which the ugens holds the value of 1 when triggered
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen which outputs a value of 1 for a given duration when triggered.

                    When a trigger occurs at the input, a value of 1 is output for the specified duration,
                    otherwise zero is output. When a new trigger occurs while this ugens outputs 1, the
                    hold-time is reset to the duration.
                </text>
                <see>ugen.Trig</see>
            </doc>
        </ugen>
        <ugen name="Trig">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="in">
                <doc>
                    the trigger. This can be any signal. A trigger happens when the signal changes
                    from non-positive to positive.
                </doc>
            </arg>
            <arg name="dur" default="0.1">
                <doc>
                    the duration for which the ugens holds the value of the input signal when triggered
                </doc>
            </arg>
        </ugen>
        <ugen name="SendTrig" sideeffect="true">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="trig" pos="0" rate="ugen">
                <doc>
                    the trigger signal causing the value to be read and sent. A trigger occurs
                    when passing from non-positive to positive.
                </doc>
            </arg>
            <arg name="value" default="0" pos="2">
                <doc>
                    a changing signal or constant that will be polled at the time of trigger,
                    and its value passed with the trigger message
                </doc>
            </arg>
            <arg name="id" default="0" pos="1">
                <doc>
                    an arbitrary integer that will be sent along with the `"/tr"` message.
                    This is useful to distinguish between several SendTrig instances per SynthDef.
                </doc>
            </arg>
            <doc warnpos="true">
                <text>
                    A UGen that sends a value from the server to all notified clients upon receiving triggers.
                    The message sent is `OSCMessage( "/tr", &lt;(Int) nodeID&gt;, &lt;(Int) trigID&gt;, &lt;(Float) value&gt; )`.

                    For sending an array of values, or using an arbitrary reply command, see `SendReply`.
                </text>
                <see>ugen.SendReply</see>
            </doc>
        </ugen>

        <ugen name="SendReply" sideeffect="true">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="trig" pos="0" rate="ugen">
                <doc>
                    a non-positive to positive transition triggers a message
                </doc>
            </arg>
            <arg name="id" default="0" pos="3">
                <doc>
                    an integer identifier which is contained in the reply message. While you can
                    distinguish different `SendReply` instances from the same Synth by choosing different
                    OSCMessage names, depending on the application you may use the same message name but
                    different ids (similar to `SendTrig`).
                </doc>
            </arg>
            <arg name="msgName" type="String" default="/reply" pos="2">
                <doc>
                    a string specifying the OSCMessage's name. by convention, this should
                    start with a forward slash and contain only 7-bit ascii characters.
                </doc>
            </arg>
            <arg name="values" multi="true" pos="1">
                <doc>
                    a graph element comprising the signal channels to be polled
                </doc>
            </arg>
            <doc warnpos="true">
                <text>
                    A UGen which sends an sequence of values from the server to all notified clients upon receiving triggers.
                    The message sent is `OSCMessage( &lt;(String) msgName&gt;, &lt;(Int) nodeID&gt;, &lt;(Int) replyID&gt;, &lt;(Float) values&gt;* )`.

                    For sending a single value, `SendTrig` provides an alternative.
                </text>
                <see>ugen.SendTrig</see>
            </doc>
        </ugen>

        <ugen name="Poll" sideeffect="true">
            <rate name="audio"/>
            <rate name="control"/>
            <arg name="trig" pos="0" rate="ugen">
                <doc>
                    a non-positive to positive transition telling Poll to return a value
                </doc>
            </arg>
            <arg name="in" pos="1">
                <doc>
                    the signal you want to poll
                </doc>
            </arg>
            <arg name="trigID" default="-1" pos="3">
                <doc>
                    if greater then 0, a `"/tr"` OSC message is sent back to the client
                    (similar to `SendTrig`)
                </doc>
            </arg>
            <arg name="label" type="String" default="poll" pos="2">
                <doc>
                    a string or symbol to be printed with the polled value
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen for printing the current output value of its input to the console.
                </text>
                <see>ugen.SendTrig</see>
            </doc>
        </ugen>

        <ugen name="ToggleFF">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="trig">
                <doc>
                    a signal to trigger the flip-flop. a trigger occurs when the signal
                    changes from non-positive to positive.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen that toggles like a flip-flop between zero and one upon receiving a trigger.
                    The flip-flop is initially outputing zero, so changes to one when the first trigger
                    arrives.
                </text>
            </doc>
        </ugen>
        <ugen name="SetResetFF">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="trig"/>
            <arg name="reset"/>
        </ugen>
        <ugen name="Latch">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in">
                <doc>
                    the input signal
                </doc>
            </arg>
            <arg name="trig">
                <doc>
                    the trigger. The can be any signal. A trigger happens when the signal changes from
                    non-positive to positive.
                </doc>
            </arg>
            <doc>
                <text>
                    A sample-and-hold UGen. When triggered, a new value is taken from the input and
                    hold until the next trigger occurs.
                </text>
                <see>ugen.Gate</see>
                <see>ugen.Demand</see>
            </doc>
        </ugen>
        <ugen name="Gate">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in">
                <doc>
                    the input signal to gate
                </doc>
            </arg>
            <arg name="gate">
                <doc>
                    the signal specifying whether to pass the input signal (when greater than zero) or
                    whether to close the gate and hold the last value (when less than or equal to zero)
                </doc>
            </arg>
            <doc>
                <text>
                    A gate or hold UGen.
                    It allows the input signal value to pass when the `gate` argument is positive,
                    otherwise it holds last value.
                </text>
                <see>ugen.Latch</see>
            </doc>
        </ugen>
        <ugen name="Schmidt">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in">
                The input signal to be analyzed.
            </arg>
            <arg name="lo" default="0">
                <doc>
                    The low threshold.
                </doc>
            </arg>
            <arg name="hi" default="1">
                <doc>
                    The high threshold.
                </doc>
            </arg>
            <doc>
                <text>
                    A Schmidt trigger UGen. Initially it outputs zero. When the input signal rises above `hi`,
                    its output switches to 1.0, which is hold until the signal falls below `lo`, switching the
                    output again to 0.0. The produces a kind of hysteresis behavior, preventing heavy
                    oscillations in a noisy system which might occur with a single-threshold trigger.
                </text>
            </doc>
        </ugen>
        <ugen name="PulseDivider">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="trig"/>
            <arg name="div" default="2"/>
            <arg name="start" default="0"/>
        </ugen>
        <ugen name="PulseCount">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="trig"/>
            <arg name="reset" default="0"/>
        </ugen>
        <ugen name="Stepper">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="trig">
                <doc>
                    The trigger signal which increments the counter. A trigger happens when the signal
                    changes from non-positive to positive. Note that if the UGen is created with the
                    trigger initially high, the counter will also be incremented immediately. Thus
                    a `Stepper.kr(Impulse.kr(1))` will begin by outputting `1`. If you want to avoid this,
                    you could their subtract `Impulse.kr(0)` from the trigger input, or set `resetVal`
                    to `hi`. E.g. `Stepper.kr(Impulse.kr(1), lo = 0, hi = 4, resetVal = 4)` will produce
                    the sequence 0, 1, 2, 4, 0, ...
                </doc>
            </arg>
            <arg name="reset" default="0">
                <doc>
                    A trigger which resets the counter to `resetVal` immediately.
                </doc>
            </arg>
            <arg name="lo" default="0">
                <doc>
                    The minimum value output. For a decremental `step` value, the counter jumps
                    to `hi` if it were to fall below `lo`.
                </doc>
            </arg>
            <arg name="hi" default="7">
                <doc>
                    The maximum value output. For an incremental `step` value, the counter jumps
                    to `lo` if it were to rise beyond `hi`.
                </doc>
            </arg>
            <arg name="step" default="1">
                <doc>
                    The amount by which the counter increases or decreases upon receiving triggers.
                    Note that if you use a decremental counter, still `lo` must be the minimum and
                    `hi` must be the maximum value output. If `lo` > `hi`, the UGen behaves wrongly.
                    In the case of decremental counter, set `resetVal` to `hi`. E.g. to count
                    from 4 down to 0, use `Stepper.kr(trig, lo = 0, hi = 4, step = -1, resetVal = 4)`, or,
                    if you want to ignore an initial high trigger, you could do
                    `Stepper.kr(Impulse.kr(1), lo = 0, hi = 4, step = -1, resetVal = 0)` --
                    so `resetVal` is `lo` but due to the initial trigger from `Impulse`
                    the `Stepper` will in fact start outputting from `4`.
                </doc>
            </arg>
            <arg name="resetVal" default="0"/>
            <doc>
                <text>
                    A pulse counting UGen. Each trigger increments a counter which is output as a signal.
                    The counter wraps inside the interval from `lo` to `hi` (inclusive). That if you
                    use a `lo` other than zero, you might want to adjust `resetVal` as well. `Stepper`
                    always starts with the value in `resetVal`, no matter what `lo` is or whether
                    the `reset` trigger is high or not.
                </text>
                <see>ugen.PulseCount</see>
            </doc>
        </ugen>
        <ugen name="TDelay">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="trig">
                <doc>
                    The input trigger. A trigger is recognized when the signal passes from
                    non-positive to positive. Note that, no matter what the amplitude of
                    the input trigger is, the UGen will output a delayed trigger of
                    amplitude 1.0.
                </doc>
            </arg>
            <arg name="dur" default="0.1">
                <doc>
                    The delay time in seconds.
                </doc>
            </arg>
            <doc>
                <text>
                    A delay UGen for trigger signals. Other than a normal buffer delay,
                    any new trigger arriving in the time between the previous trigger
                    and the passing of the delay time is ignored.
                </text>
            </doc>
        </ugen>
        <ugen name="ZeroCrossing">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
        </ugen>
        <ugen name="Timer">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="trig">
                <doc>
                    the trigger to update the output signal.
                    A trigger occurs when trig signal crosses from non-positive to positive.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen that returns time since last triggered.
                    The time returned is in seconds and is measured from the last received trigger.
                    Note that currently it seems the initial memory is at -1 sample, so for
                    `Impulse.ar(1)` the result (at 44.1 kHz) is 2.26757e-05, followed strangely
                    by 1.00002, and then (as expected) 1.0.
                </text>
            </doc>
        </ugen>
        <ugen name="Sweep">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="trig">
                <doc>
                    the trigger that restarts the ramp, when passing from
                    non-positive to positive
                </doc>
            </arg>
            <arg name="speed">
                <doc>
                    the amount of increment of the output signal per second.
                    In SCLang this argument is named `rate`, while ScalaCollider uses
                    `speed` to avoid conflict with the UGen's calculation rate.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen which starts a linear raise from zero each time it is
                    triggered.
                </text>
                <see>ugen.Ramp</see>
                <see>ugen.Phasor</see>
                <see>ugen.Line</see>
            </doc>
        </ugen>
        <ugen name="Phasor">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="trig">
                <doc>
                    Warning: SC 3.4 has a bug where an initial trig value of 1 will
                    be ignored (you need to feed it zero first)
                </doc>
            </arg>
            <arg name="speed" default="1"/>
            <arg name="lo" default="0"/>
            <arg name="hi" default="1"/>
            <arg name="resetVal" default="0"/>
        </ugen>
        <ugen name="Peak">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="trig"/>
        </ugen>
        <ugen name="RunningMin">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="trig"/>
        </ugen>
        <ugen name="RunningMax">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="trig"/>
        </ugen>
        <ugen name="PeakFollower">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="decay" default="0.999"/>
        </ugen>
        <ugen name="MostChange">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="a"/>
            <arg name="b"/>
        </ugen>
        <ugen name="LeastChange">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="a"/>
            <arg name="b"/>
        </ugen>
        <ugen name="LastValue">
            <rate name="control"/>
            <rate name="audio"/>
            <arg name="in"/>
            <arg name="thresh" default="0.01"/>
        </ugen>
        <ugen name="Done" sideeffect="true">
            <rate name="control" implied="true"/>
            <arg name="src" doneflag="true">
                <doc>
                    the UGen to track
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen which monitors another UGen to see when it is finished.
                    Some UGens, such as `PlayBuf`, `RecordBuf`, `Line`, `XLine`, `EnvGen`, `Linen`, `BufRd`, `BufWr`, `DbufRd`,
                    and the Buffer delay UGens set a 'done' flag when they are finished playing. This UGen echoes that flag
                    as an explicit output signal when it is set to track a particular UGen. When the tracked UGen changes
                    to done, the output signal changes from zero to one.
                </text>
                <see>ugen.PlayBuf</see>
                <see>ugen.Line</see>
                <see>ugen.EnvGen</see>
            </doc>
        </ugen>
        <ugen name="Pause" sideeffect="true">
            <rate name="control" implied="true"/>
            <arg name="gate">
                <doc>
                    when 0, node is paused, when 1, node is resumed
                </doc>
            </arg>
            <arg name="node">
                <doc>
                    the id of the node to be paused or resumed
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen which pauses and resumes another node.
                    Note that the UGen initially assumes the node is running, that is,
                    if `gate` is initially 1, this will '''not''' resume a paused node.
                    Instead, the gate must go to zero and back to one to resume the node.
                    Additionally, this UGen will only cause action if the gate value
                    changes, that is, if the node is paused or resumed otherwise, this
                    UGen will not interfere with that action, unless the gate value is
                    adjusted.
                </text>
                <see>ugen.Free</see>
                <see>ugen.PauseSelf</see>
            </doc>
        </ugen>
        <ugen name="FreeSelf" sideeffect="true">
            <rate name="control" implied="true"/>
            <arg name="trig">
                <doc>
                    the input signal which will trigger the action.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen that, when triggered, frees enclosing synth.
                    It frees the enclosing synth when the input signal crosses from non-positive to positive.

                    This UGen outputs its input signal for convenience.
                </text>
                <see>ugen.Free</see>
                <see>ugen.PauseSelf</see>
            </doc>
        </ugen>
        <ugen name="PauseSelf" sideeffect="true">
            <rate name="control" implied="true"/>
            <arg name="trig">
                <doc>
                    the input signal which will trigger the action.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen that, when triggered, pauses enclosing synth.
                    It pauses the enclosing synth when the input signal crosses from non-positive to positive.

                    This UGen outputs its input signal for convenience.
                </text>
                <see>ugen.Pause</see>
                <see>ugen.FreeSelf</see>
            </doc>
        </ugen>
        <ugen name="Free" sideeffect="true">
            <rate name="control" implied="true"/>
            <arg name="trig">
                <doc>
                    the trigger to cause the action
                </doc>
            </arg>
            <arg name="node">
                <doc>
                    the id of the target node to free upon receiving the trigger
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen that, when triggered, frees a given node.

                    This UGen outputs its trig input signal for convenience.
                </text>
                <see>ugen.Pause</see>
                <see>ugen.FreeSelf</see>
            </doc>
        </ugen>
        <ugen name="FreeSelfWhenDone" sideeffect="true">
            <rate name="control" implied="true"/>
            <arg name="src" doneflag="true">
                <doc>
                    the input UGen which when finished will trigger the action.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen that, when its input UGen is finished, frees enclosing synth.
                    This is essentially a shortcut for `FreeSelf.kr( Done.kr( src ))`, so instead
                    of providing a trigger signal it reads directly the done flag of an
                    appropriate ugen (such as `Line` or `PlayBuf`).

                    This UGen outputs its input signal for convenience.
                </text>
                <see>ugen.Free</see>
                <see>ugen.FreeSelf</see>
                <see>ugen.PauseSelfWhenDone</see>
                <see>ugen.Done</see>
            </doc>
        </ugen>
        <ugen name="PauseSelfWhenDone" sideeffect="true">
            <rate name="control" implied="true"/>
            <arg name="src" doneflag="true">
                <doc>
                    the input UGen which when finished will trigger the action.
                </doc>
            </arg>
            <doc>
                <text>
                    A UGen that, when its input UGen is finished, pauses enclosing synth.
                    This is essentially a shortcut for `PauseSelf.kr( Done.kr( src ))`, so instead
                    of providing a trigger signal it reads directly the done flag of an
                    appropriate ugen (such as `Line` or `PlayBuf`).

                    This UGen outputs its input signal for convenience.
                </text>
                <see>ugen.Pause</see>
                <see>ugen.PauseSelf</see>
                <see>ugen.FreeSelfWhenDone</see>
                <see>ugen.Done</see>
            </doc>
        </ugen>
    </file>

    <file name="UnpackFFTUGens">
        <ugen name="Unpack1FFT" readsfft="true">
            <rate name="demand" implied="true" method="apply"/>
            <arg name="chain"/>
            <arg name="fftSize"/>
            <arg name="bin"/>
            <arg name="which" default="0"/>
        </ugen>

        <!-- XXX TODO:
        <ugen name="PackFFT"/>
        NOTE: the multi arg is preceded by its size for fuck's sake
        -->  <!-- accepts demand rate -->
    </file>
</ugens>